local DiscordLib =
	loadstring(game:HttpGet "https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/discord")()

local win = DiscordLib:Window("PermaHub")

local serv = win:Server("PermaHub", "")

local reanims = serv:Channel("ReAnimations")

local scripts = serv:Channel("Scripts")

scripts:Button(
	"Wanderer",
	function()
		DiscordLib:Notification("PermAnim", "Script Succsesful", "Done!")


local FavIDs = {
	340106355, --Nefl Crystals
	927529620, --Dimension
	876981900, --Fantasy
	398987889, --Ordinary Days
	1117396305, --Oh wait, it's you.
	885996042, --Action Winter Journey
	919231299, --Sprawling Idiot Effigy
	743466274, --Good Day Sunshine
	727411183, --Knife Fight
	1402748531, --The Earth Is Counting On You!
	595230126 --Robot Language
}

_G.Fling = true


loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/GelatekV2/main/LoadLibrary.lua"))()





--The reality of my life isn't real but a Universe -makhail07
wait(0.2)
local plr = game:service'Players'.LocalPlayer
warn("this script converted by NenWadra")
local char = plr.Character.PermAnimated
local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Cool yellow")

-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then

		hit.Parent:FindFirstChild("Head"):BreakJoints()
	end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
		if insta == true then
			hit.Parent:FindFirstChild("Head"):BreakJoints()
		end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game:service("Players").LocalPlayer,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "Firedmg" then
			coroutine.resume(coroutine.create(function()
				for i = 1, 18 do
					if hit.Parent:FindFirstChild("Torso") ~= nil then
						BlockEffect(BrickColor.new("Daisy orange"), hit.Parent.Head.CFrame, 0, 0, 0, 2, 2, 2, 0.035, 1)
						wait()
					end
				end
			end))
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
	for _, c in pairs(workspace:children()) do
		local hum = c:findFirstChild("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("Head")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if magni >= mag and c.Name ~= plr.Name then
					Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
				end
			end
		end
	end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
	Block = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
			local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			if Type == 1 or Type == nil then
				table.insert(Effects, {
					prt,
					"Block1",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			elseif Type == 2 then
				table.insert(Effects, {
					prt,
					"Block2",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			else
				table.insert(Effects, {
					prt,
					"Block3",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		end
	},
	Sphere = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	},
	Cylinder = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	},
	Wave = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3 / 60,
				y3 / 60,
				z3 / 60,
				msh
			})
		end
	},
	Ring = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	},
	Break = {
		Create = function(brickcolor, cframe, x1, y1, z1)
			local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
			prt.Anchored = true
			prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			local num = math.random(10, 50) / 1000
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Shatter",
				num,
				prt.CFrame,
				math.random() - math.random(),
				0,
				math.random(50, 100) / 100
			})
		end
	},
	Spiral = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	},
	Push = {
		Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	}
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 

function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
		if meshid ~= "nil" then
			mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end

function Eviscerate(dude)
	if dude.Name ~= char then
		local bgf = IT("BodyGyro", dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
			dude:WaitForChild("Head"):BreakJoints()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
					end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
						v:Destroy()
					end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
						for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
								o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://284205403"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0.75, 0),
								NumberSequenceKeypoint.new(1, 0, 0)
							})
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							v.Color = maincolor.Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v.Transparency = v.Transparency + 0.08
								end
								wait(0.5)
								PartEmmit1.Enabled = false
								wait(3)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)
	if dude.Name ~= char then
		local bgf = IT("BodyGyro", dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
		local soulst = coroutine.wrap(function()
			local soul = Instance.new("Part",dude)
			soul.Size = Vector3.new(1,1,1)
			soul.CanCollide = false
			soul.Anchored = false
			soul.Position = torso.Position
			soul.Transparency = 1
			local PartEmmit1 = IT("ParticleEmitter", soul)
			PartEmmit1.LightEmission = 1
			PartEmmit1.Texture = "rbxassetid://569507414"
			PartEmmit1.Color = ColorSequence.new(maincolor.Color)
			PartEmmit1.Rate = 250
			PartEmmit1.Lifetime = NumberRange.new(1.6)
			PartEmmit1.Size = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 1, 0),
				NumberSequenceKeypoint.new(1, 0, 0)
			})
			PartEmmit1.Transparency = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 0, 0),
				NumberSequenceKeypoint.new(1, 1, 0)
			})
			PartEmmit1.Speed = NumberRange.new(0, 0)
			PartEmmit1.VelocitySpread = 30000
			PartEmmit1.Rotation = NumberRange.new(-360, 360)
			PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
			local BodPoss = IT("BodyPosition", soul)
			BodPoss.P = 3000
			BodPoss.D = 1000
			BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
			BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
			wait(1.6)
			soul.Touched:connect(function(hit)
				if hit.Parent == char then
					soul:Destroy()
				end
			end)
			wait(1.2)
			while soul do
				swait()
				PartEmmit1.Color = ColorSequence.new(maincolor.Color)
				BodPoss.Position = tors.Position
			end
		end)
		soulst()
	end
end
function FaceMouse()
	local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
	local prt = CreatePart(3, workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	if Type == 1 or Type == nil then
		table.insert(Effects, {
			prt,
			"Block1",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	elseif Type == 2 then
		table.insert(Effects, {
			prt,
			"Block2",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	elseif Type == 3 then
		table.insert(Effects, {
			prt,
			"Block3",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------

--[[
		Thanks for using Build-To-Lua by jarredbcv.
]]--

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end

Lamp = New("Model",char,"Lamp",{})
Handle = New("Part",Lamp,"Handle",{FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(0.600000024, 0.610000014, 0.539999962),CFrame = CFrame.new(-109.839981, 1.79380095, -43.7700005, 0.999977291, -2.22814856e-06, -2.28935824e-06, -7.29543899e-07, -0.999977469, -5.85511816e-06, 1.10829581e-06, 4.96105622e-06, -1.00000715),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
Mesh = New("SpecialMesh",Handle,"Mesh",{Scale = Vector3.new(0.600000024, 0.600000024, 1),MeshId = "http://www.roblox.com/asset/?id=3270017",MeshType = Enum.MeshType.FileMesh,})
Lampo = New("Part",Lamp,"Lampo",{BrickColor = BrickColor.new("Cool yellow"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(1, 1, 1),CFrame = CFrame.new(-109.859985, 1.05100787, -43.7600021, 0.999969721, -9.99071062e-07, -2.26510087e-06, 9.99070835e-07, -0.999969959, -5.96146037e-07, 2.2651011e-06, -5.96145583e-07, -1.00000954),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.992157, 0.917647, 0.552941),})
Mesh = New("CylinderMesh",Lampo,"Mesh",{Scale = Vector3.new(0.800000012, 1, 0.800000012),})
mot = New("Motor",Lampo,"mot",{Part0 = Lampo,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, 0, 0, -0, -1, -0, -0, -0, -1),C1 = CFrame.new(-0.0200042725, 0.742809892, -0.00999450684, 0.99999243, -1.22910137e-06, -2.42515625e-08, -1.72864145e-06, -0.99999249, 5.25910491e-06, -1.15681405e-06, -5.55712631e-06, -1.00000238),})
--PointLight = New("PointLight",Lampo,"PointLight",{Color = Color3.new(1, 0.835294, 0),Brightness = 34.9849996566772,Range = 25.060000419617,})
Lampo.Transparency = 1



			--------------------align-------------------------------

    local AlignChar = game.Players.LocalPlayer.Character
    local Hat = AlignChar:FindFirstChild("InternationalFedora")

local Count = 1
function Align(Part0,Part1,Position,Angle)
    local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP"..Count
    AlignPos.ApplyAtCenterOfMass = true;
    AlignPos.MaxForce = 5772000--67752;
    AlignPos.MaxVelocity = math.huge/9e110;
    AlignPos.ReactionForceEnabled = false;
    AlignPos.Responsiveness = 200;
    AlignPos.RigidityEnabled = false;
    local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO"..Count
    AlignOri.MaxAngularVelocity = math.huge/9e110;
    AlignOri.MaxTorque = 5772000
    AlignOri.PrimaryAxisOnly = false;
    AlignOri.ReactionTorqueEnabled = false;
    AlignOri.Responsiveness = 200;
    AlignOri.RigidityEnabled = false;
    local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP"..Count
    local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP"..Count
    local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO"..Count
    local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO"..Count
    AttachmentC.Orientation = Angle
    AttachmentA.Position = Position
    AlignPos.Attachment1 = AttachmentA;
    AlignPos.Attachment0 = AttachmentB;
    AlignOri.Attachment1 = AttachmentC;
    AlignOri.Attachment0 = AttachmentD;
    Count = Count + 1
end


	Hat.Handle.AccessoryWeld:Destroy()
Align(Hat.Handle,AlignChar.PermAnimated.Lamp.Lampo,Vector3.new(0,-0.1,0),Vector3.new(0,0,0))

game.Players.LocalPlayer.Character.InternationalFedora.Handle.SpecialMesh:Destroy()

local NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance,parent)
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

--local HW = NewInstance('Weld',char,{Part0 = tors, Part1 = Handle, C0 = CF(1, -0.8, -0.2) * angles(Rad(180), Rad(60), Rad(-40))})
local HW = NewInstance('Weld',char,{Part0 = ra, Part1 = Handle, C0 = CF(0, -0.8, 0.6) * angles(Rad(90), Rad(0), Rad(0))})

-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
	root.Size = root.Size * Player_Size
	tors.Size = tors.Size * Player_Size
	hed.Size = hed.Size * Player_Size
	ra.Size = ra.Size * Player_Size
	la.Size = la.Size * Player_Size
	rl.Size = rl.Size * Player_Size
	ll.Size = ll.Size * Player_Size
	----------------------------------------------------------------------------------
	rootj.Parent = root
	neck.Parent = tors
	RW.Parent = tors
	LW.Parent = tors
	RH.Parent = tors
	LH.Parent = tors
	----------------------------------------------------------------------------------
	rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
	rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
	neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
	neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
	RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
	LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
	----------------------------------------------------------------------------------
	RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
	LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
	RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
	LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
	--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 3166020186
local SONG2 = 0
local Music = Instance.new("Sound",tors)
Music.Volume = 1
Music.Looped = true
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
local Mode = "Latern"
----------------------------------------------------------------------------------
hum.WalkSpeed = 12
hum.JumpPower = 57
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local ANIMATOR = hum.Animator
local ANIMATE = char.Animate
ANIMATE.Parent = nil
----------------------------------------------------------------------------------
local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,35)
naeeym2.StudsOffset = Vector3.new(0,1,0)
naeeym2.Adornee = hed
naeeym2.Name = "Name"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Font = "Fantasy"
tecks2.TextSize = 30
tecks2.TextTransparency = 0
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.fromRGB(253, 234, 141)
tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Text = "who am i?"
tecks2.Parent = naeeym2

----------------------------------------------------------------------------------
game:service'Lighting'.TimeOfDay = "00:00:00"
local light = Instance.new("PointLight", Lampo)
light.Name = "Light"
light.Range = 8
light.Brightness = 5
light.Color = Color3.fromRGB(253, 234, 141)
light.Shadows = true
----------------------------------------------------------------------------------
Reaper = IT("Model")
Reaper.Parent = char
Reaper.Name = "Reaper"
RHe = IT("Part")
RHe.Parent = Reaper
RHe.BrickColor = BrickColor.new("Dark stone grey")
RHe.Locked = true
RHe.CanCollide = false
RHe.Transparency = 1
PMesh = IT("SpecialMesh")
RHe.formFactor =  "Symmetric"
PMesh.MeshType = "FileMesh"
PMesh.MeshId = "rbxassetid://77353021"
--PMesh.TextureId = "rbxassetid://116524836"
PMesh.Scale = Vector3.new(1.5, 1.5, 1.5)
PMesh.Parent = RHe
local RWeld = IT("Weld")
RWeld.Parent = RHe
RWeld.Part0 = RHe
RWeld.Part1 = tors
RWeld.C0 = CF(-0.9, 1, -0.6) * angles(Rad(0), Rad(-20), Rad(90))


			--------------------align-------------------------------

    local AlignChar = game.Players.LocalPlayer.Character
    local Hat = AlignChar:FindFirstChild("Meshes/KanaboFinal (1)Accessory")

local Count = 1
function Align(Part0,Part1,Position,Angle)
    local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP"..Count
    AlignPos.ApplyAtCenterOfMass = true;
    AlignPos.MaxForce = 5772000--67752;
    AlignPos.MaxVelocity = math.huge/9e110;
    AlignPos.ReactionForceEnabled = false;
    AlignPos.Responsiveness = 200;
    AlignPos.RigidityEnabled = false;
    local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO"..Count
    AlignOri.MaxAngularVelocity = math.huge/9e110;
    AlignOri.MaxTorque = 5772000
    AlignOri.PrimaryAxisOnly = false;
    AlignOri.ReactionTorqueEnabled = false;
    AlignOri.Responsiveness = 200;
    AlignOri.RigidityEnabled = false;
    local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP"..Count
    local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP"..Count
    local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO"..Count
    local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO"..Count
    AttachmentC.Orientation = Angle
    AttachmentA.Position = Position
    AlignPos.Attachment1 = AttachmentA;
    AlignPos.Attachment0 = AttachmentB;
    AlignOri.Attachment1 = AttachmentC;
    AlignOri.Attachment0 = AttachmentD;
    Count = Count + 1
end


	Hat.Handle.AccessoryWeld:Destroy()
Align(Hat.Handle,AlignChar.PermAnimated.Reaper.Part,Vector3.new(0,-0.1,0),Vector3.new(0,90,60))


-------------------------------------------------------
--End Customization--
-------------------------------------------------------


-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
function HitboxFunction(Pose, lifetime, siz1, siz2, siz3, Radie, Min, Max, kb, atype)
	local  Hitboxpart = Instance.new("Part", EffectModel)
	RemoveOutlines(Hitboxpart)
	Hitboxpart.Size = Vector3.new(siz1, siz2, siz3)
	Hitboxpart.CanCollide = false
	Hitboxpart.Transparency = 1
	Hitboxpart.Anchored = true
	Hitboxpart.CFrame = Pose
	game:GetService("Debris"):AddItem(Hitboxpart, lifetime)
	MagniDamage(Hitboxpart, Radie, Min, Max, kb, atype)
end
function LaternSmack()
	attack = true
	hum.WalkSpeed = 3.01
	for i = 0, 1.4, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-6), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-8 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(60), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-9)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(186), Rad(13 + 4.5 * Sin(sine / 20)), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-36), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
		HW.C0 = clerp(HW.C0, CF(0, -1, -0.4) * angles(Rad(235), Rad(-.6), Rad(0)), 0.2)
	end
	local Flame = Cso("213656638", Lampo, 1.7, .9)
	if Flame then
		Flame.TimePosition = .5
	end
	Cso("145878848", Lampo, 3, 1)
	HitboxFunction(Lampo.CFrame * CF(0, 0, 1), 0.01, 1, 1, 1, 7, 10, 20, 3, "Firedmg")
	for i = 0, 1.7, 0.1 do
		swait()
		BlockEffect(maincolor, Lampo.CFrame, 21, 41, 21, -3.5, -3.5, -3.5, 0.08, 3)
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(6), Rad(0), Rad(10)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(21 - 2.5 * Sin(sine / 20)), Rad(0), Rad(-10)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(60), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(9)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(26)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-18 + 4.5 * Sin(sine / 20))), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-16), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-13 - 4.5 * Sin(sine / 20))), 0.2)
		HW.C0 = clerp(HW.C0, CF(0, -1.1, 0) * angles(Rad(148 + 4.5 * Cos(sine / 20)), Rad(-.6), Rad(0)), 0.2)
	end
	attack = false
	hum.WalkSpeed = 12
end
function LaternSpin()
	attack = true
end
function Taunt()
	attack = true
	hum.WalkSpeed = 1.0
	coroutine.resume(coroutine.create(function()
		for i = 0, 0.3, 0.1 do
			swait(35)
			Cso("145878848", Lampo, 3, 1)
		end
	end))
	for i = 0, 16, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(6), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(8 - 2.5 * Sin(sine / 20)), Rad(0), Rad(-20)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(60), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-9)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(125 + 25 * Cos(sine / 7)), Rad(13 + 4.5 * Sin(sine / 20)), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(16), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
		HW.C0 = clerp(HW.C0, CF(0, -0.6, 0.6) * angles(Rad(67 + 35 * Cos(sine / 7)), Rad(-.6), Rad(0)), 0.1)
	end
	hum.WalkSpeed = 12
	attack = false
end
function EquipBlade()
	attack = true
	hum.WalkSpeed = 0
	for i = 0, 4, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(6), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(15 - 2.5 * Sin(sine / 20)), Rad(0), Rad(-20)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(60), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-9)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-6 + 4.5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(16), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
		HW.C0 = clerp(HW.C0, CF(0, -1.1, 0.4) * angles(Rad(175), Rad(0), Rad(0)), 0.1)
	end
	coroutine.resume(coroutine.create(function()
		HW.Part0 = tors
		for i = 0, 3, 0.1 do
			swait()
			HW.C0 = clerp(HW.C0, CF(1, -0.8, -0.2) * angles(Rad(180 + 4.5 * Sin(sine / 20)), Rad(60), Rad(-40)), 0.15)
		end
	end))
	for i = 0, 5, 0.1 do
		swait()
		RWeld.C0 = CF(-0.9, 1, -0.6) * angles(Rad(-34), Rad(-20), Rad(90))
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(6), Rad(0), Rad(-20)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(15 - 2.5 * Sin(sine / 20)), Rad(0), Rad(20)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(60), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-9)), 0.15)
		RW.C0 = clerp(RW.C0, CF(0.9* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, -1.1* Player_Size) * angles(Rad(58), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-45 + 4.5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(16), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
		HW.C0 = clerp(HW.C0, CF(1, -0.8, -0.2) * angles(Rad(180 + 8.5 * Cos(sine / 20)), Rad(60), Rad(-40)), 0.1)
	end
	RWeld.Part1 = ra
	for i = 0, 5, 0.1 do
		swait()
		RWeld.C0 = CF(-1, 0, -1.9) * angles(Rad(-90), Rad(0), Rad(90))
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(6), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(15 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(60), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-9)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(58), Rad(13 + 4.5 * Sin(sine / 20)), Rad(24 + 4.5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(16), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
		HW.C0 = clerp(HW.C0, CF(1, -0.8, -0.2) * angles(Rad(180 + 8.5 * Cos(sine / 20)), Rad(60), Rad(-40)), 0.1)
	end
	attack = false
	Mode = "Blade"
	hum.WalkSpeed = 12
end
function DequipBlade()
	attack = true
	hum.WalkSpeed = 0
	RWeld.Part1 = tors
	for i = 0, 5, 0.1 do
		swait()
		RWeld.C0 = CF(-0.9, 1, -0.6) * angles(Rad(-34), Rad(-20), Rad(90))
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(6), Rad(0), Rad(-20)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(15 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.15)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(60), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-9)), 0.15)
		RW.C0 = clerp(RW.C0, CF(0.9* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, -1.1* Player_Size) * angles(Rad(58), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-45 + 4.5 * Sin(sine / 20))), 0.15)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-36), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-13 - 4.5 * Sin(sine / 20))), 0.15)
		HW.C0 = clerp(HW.C0, CF(1, -0.8, -0.2) * angles(Rad(180 + 8.5 * Cos(sine / 20)), Rad(60), Rad(-40)), 0.1)
	end
	HW.Part0 = ra
	RWeld.C0 = CF(-0.9, 1, -0.6) * angles(Rad(0), Rad(-20), Rad(90))
	for i = 0, 4, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(6), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(15 - 2.5 * Sin(sine / 20)), Rad(0), Rad(-20)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(60), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-9)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-6 + 4.5 * Sin(sine / 20))), 0.15)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(16), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
		HW.C0 = clerp(HW.C0, CF(0, -1.1, 0.4) * angles(Rad(175), Rad(0), Rad(0)), 0.1)
	end
	attack = false
	Mode = "Latern"
	hum.WalkSpeed = 12
end
-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.Button1Down:connect(function(key)
	if attack == false then
		if Mode == "Latern" then
			LaternSmack()
		end
	end
end)
mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == 't' and Mode == "Latern" then
			Taunt()
		elseif key == 'p' and Mode == "Latern" then
			EquipBlade()
		elseif key == 'p' and Mode == "Blade" then
			DequipBlade()
		end
	end
end)







-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
print("By Makhail07")
while true do
	swait()
	sine = sine + change
	--ANIMATE.Parent = nil
	--local IDLEANIMATION = hum:LoadAnimation(ROBLOXIDLEANIMATION)
	--IDLEANIMATION:Play()
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				if Mode == "Latern" then
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
					HW.C0 = clerp(HW.C0, CF(0, -1.1, 0.4) * angles(Rad(147), Rad(0), Rad(0)), 0.1)
				elseif Mode == "Blade" then
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
					HW.C0 = clerp(HW.C0, CF(1, -0.8, -0.2) * angles(Rad(180 + 8.5 * Cos(sine / 20)), Rad(60), Rad(-40)), 0.1)
				end
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				if Mode == "Latern" then
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
					HW.C0 = clerp(HW.C0, CF(0, -1.1, 0.4) * angles(Rad(175), Rad(0), Rad(0)), 0.1)
				elseif Mode == "Blade" then
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
					HW.C0 = clerp(HW.C0, CF(1, -0.8, -0.2) * angles(Rad(195 + 8.5 * Cos(sine / 20)), Rad(60), Rad(-40)), 0.1)
				end
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
				if Mode == "Latern" then
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(6), Rad(0), Rad(0)), 0.15)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(8 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(60), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.15)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-9)), 0.15)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(125), Rad(13 + 4.5 * Sin(sine / 20)), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(16), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
					HW.C0 = clerp(HW.C0, CF(0, -0.8, 0.6) * angles(Rad(67), Rad(-.6), Rad(10 * Cos(sine / 20))), 0.1)
				elseif Mode == "Blade" then
					RWeld.C0 = CF(-1, 0, -2.1) * angles(Rad(-180), Rad(0), Rad(90))
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(6), Rad(0), Rad(0)), 0.15)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(15 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(60), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.15)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-9)), 0.15)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(13 + 4.5 * Sin(sine / 20)), Rad(24 + 4.5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(16), Rad(13 + 4.5 * Sin(sine / 20)), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
					HW.C0 = clerp(HW.C0, CF(1, -0.8, -0.2) * angles(Rad(180 + 8.5 * Cos(sine / 20)), Rad(60), Rad(-40)), 0.1)
				end
			end
		elseif (tors.Velocity).magnitude < 200 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
				if Mode == "Latern" then
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.10 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(4 * Cos(sine / 7))), 0.15)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-15 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(125), Rad(13 + 4.5 * Sin(sine / 12)), Rad(13 + 4.5 * Sin(sine / 12))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-37)  * Cos(sine / 7) , Rad(8 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
					HW.C0 = clerp(HW.C0, CF(0, -0.7, 0.6) * angles(Rad(67 + 8 * Cos(sine / 7)), Rad(0), Rad(18 * Cos(sine / 7))), 0.1)
				elseif Mode == "Blade" then
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.10 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(4 * Cos(sine / 7))), 0.15)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-15 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(13 + 4.5 * Sin(sine / 20)), Rad(24 + 4.5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-37)  * Cos(sine / 7) , Rad(8 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
					HW.C0 = clerp(HW.C0, CF(1, -0.8, -0.2) * angles(Rad(180 + 15 * Cos(sine / 3.5)), Rad(60), Rad(-40)), 0.1)
				end
			end
		end
	end
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Volume = 1
	Music.Parent = tors
	Music:Resume()
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end

	end)

scripts:Button(
	"Creep (really creepy)",
	function()
		DiscordLib:Notification("PermAnim", "Script Succsesful", "Done!")
		-- I leaked this because Noki sold it without permission.

		-- Created by Nebula_Zorua --
		-- Noki's Custom (Preech) --
		-- yeet he paid me $7 --
		-- Not like that matters anymore, of course. --
		-- Discord: Nebula the Zorua#6969
		-- Youtube: https://www.youtube.com/channel/UCo9oU9dCw8jnuVLuy4_SATA


		local S = setmetatable({},{__index = function(s,i) return game:service(i) end})

		loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/GelatekV2/main/LoadLibrary.lua"))()

		local plr = S.Players.LocalPlayer
		local char = plr.Character.PermAnimated
		local hum = char.Humanoid
		local rarm = char["Right Arm"]
		local larm= char["Left Arm"]
		local rleg= char["Right Leg"]
		local lleg = char["Left Leg"]	
		local root = char:FindFirstChild'HumanoidRootPart'
		local torso = char.Torso
		local head = char.Head
		local sine = 0;
		local combo = 1;
		local lastClick = time()
		local change = 1;
		local runService = S.RunService
		local mouse = plr:GetMouse()
		local Attack = false
		local neutralAnims = true
		local PaintBody = "Really black"
		local PlayerSize = 2.5
		local Debounces = {Debounces={}}
		local Hit = {}
		local BloodPuddles = {}
		local Teamed = {}
		local WalkSpeed = 8
		local Puddle = nil;
		local Alpha = 0.3
		function Debounces:New(name,cooldown)
			local aaaaa = {Usable=true,Cooldown=cooldown or 2,CoolingDown=false,LastUse=0}
			setmetatable(aaaaa,{__index = Debounces})
			Debounces.Debounces[name] = aaaaa
			return aaaaa
		end

		function Debounces:Use(overrideUsable)
			assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
			if(self.Usable or overrideUsable)then
				self.Usable = false
				self.CoolingDown = true
				local LastUse = time()
				self.LastUse = LastUse
				delay(self.Cooldown or 2,function()
					if(self.LastUse == LastUse)then
						self.CoolingDown = false
						self.Usable = true
					end
				end)
			end
		end

		function Debounces:Get(name)
			assert(typeof(name) == 'string',("bad argument #1 to 'get' (string expected, got %s)"):format(typeof(name) == nil and "no value" or typeof(name)))
			for i,v in next, Debounces.Debounces do
				if(i == name)then
					return v;
				end
			end
		end

		function Debounces:GetProgressPercentage()
			assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
			if(self.CoolingDown and not self.Usable)then
				return math.max(
					math.floor(
						(
							(time()-self.LastUse)/self.Cooldown or 2
						)*100
					)
				)
			else
				return 100
			end
		end

		local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
		local V3 = {N=Vector3.new}
		local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge}

		local Effects,Sounds = {},{};
		--Stop animations
		for _,v in next, hum:GetPlayingAnimationTracks() do
			v:Stop();
		end

		pcall(game.Destroy,char:FindFirstChild'Animate')
		pcall(game.Destroy,hum:FindFirstChild'Animator')

		-- Sounds
		Sounds['Wet'] = {Id=256738023,Loop=false,Pitch=1}
		Sounds['Swoosh1'] = {Id=320557353,Loop=false,Pitch=1,Volume=6}
		Sounds['Swoosh2'] = {Id=320557382,Loop=false,Pitch=1,Volume=6}
		Sounds['Swoosh3'] = {Id=320557413,Loop=false,Pitch=1,Volume=6}
		Sounds['Swoosh4'] = {Id=320557453,Loop=false,Pitch=1,Volume=6}
		Sounds['Swoosh5'] = {Id=320557487,Loop=false,Pitch=1,Volume=6}
		Sounds['Swoosh6'] = {Id=320557537,Loop=false,Pitch=1,Volume=6}
		Sounds['Swoosh7'] = {Id=320557563,Loop=false,Pitch=1,Volume=6}
		Sounds['Swoosh8'] = {Id=320557518,Loop=false,Pitch=1,Volume=6}
		Sounds['SmallBoom'] = {Id=341336485,Loop=false,Volume=5,Pitch=1}
		Sounds['ChaosBuster'] = {Id=333534812,Loop=false,Volume=5,Pitch=0.75}
		Sounds['Magic'] = {Id=315743350,Loop=false,Volume=5,Pitch=1}
		Sounds['ShrekRemix'] = {Id=163306929,Loop=true,Pitch=1,Volume = 4}
		Sounds['CreoDimension'] = {Id=927529620,Loop=true,Pitch=1,Volume=4}
		Sounds['BlackBlizzard'] = {Id=657626121,Loop=true,Pitch=1,Volume=4}
		Sounds['ColbreakzFantasy'] = {Id=876981900,Loop=true,Pitch=1,Volume=4}
		Sounds['NeflCrystals'] = {Id=340106355,Loop=true,Pitch=1,Volume=4}
		Sounds['EvilMortyRemix'] = {Id=1057401232,Loop=true,Pitch=1,Volume=10}
		Sounds['Creep'] = {Id=421358540, Loop=true,Pitch=1,Volume=5}
		-- Functions
		local NewInstance = function(instance,parent,properties)
			local inst = Instance.new(instance)
			if(properties)then
				for i,v in next, properties do
					pcall(function() inst[i] = v end)
				end
			end
			inst.Parent = parent
			return inst;
		end


		ArtificialHB = NewInstance("BindableEvent", script,{
			Parent = script,
			Name = "Heartbeat",
		})

		script:WaitForChild("Heartbeat")

		frame = 1 / 60
		tf = 0
		allowframeloss = false
		tossremainder = false
		lastframe = tick()
		script.Heartbeat:Fire()

		game:GetService("RunService").Heartbeat:connect(function(s, p)
			tf = tf + s
			if tf >= frame then
				if allowframeloss then
					script.Heartbeat:Fire()
					lastframe = tick()
				else
					for i = 1, math.floor(tf / frame) do
						script.Heartbeat:Fire()
					end
					lastframe = tick()
				end
				if tossremainder then
					tf = 0
				else
					tf = tf - frame * math.floor(tf / frame)
				end
			end
		end)

		function swait(num)
			if num == 0 or num == nil then
				ArtificialHB.Event:wait()
			else
				for i = 0, num do
					ArtificialHB.Event:wait()
				end
			end
		end


		function clerp(startCF,endCF,alpha)
			return startCF:lerp(endCF, alpha)
		end
		local sndFromData = function(data,parent)
			assert(typeof(data) == 'table',"sndFromData's first argument must be a table!")
			local snd = NewInstance("Sound",parent or char,{SoundId = "rbxassetid://"..data.Id,Looped=data.Loop or false,Pitch = data.Pitch or 1,Volume = data.Volume or 1})
			if(not snd.Looped)then
				snd.Ended:connect(function()
					snd:Stop()
					snd:destroy()
				end)
			end
			return snd;
		end
		local FX = function(ID,vol,pitch,parent)
			return coroutine.wrap(function()
				local snd = NewInstance("Sound",parent or torso, {Pitch=pitch or 1, Volume = vol or 1,SoundId = "rbxassetid://"..ID})
				snd:Play()

				delay(snd.TimeLength+2,function()
					snd:Stop()
					snd:Destroy()
				end)
				return snd
			end)()
		end
		function ClearChildrenWithClass(where,class,recursive)
			local children = (recursive and where:GetDescendants() or where:GetChildren())
			for _,v in next, children do
				if(v:IsA(class))then
					v:destroy()
				end
			end
		end

		function UnbindLoops()
			pcall(runService.UnbindFromRenderStep,runService,"N_Effects")
			pcall(runService.UnbindFromRenderStep,runService,"N_Animations")
		end;

		UnbindLoops() -- Just so if the loops already exist from previously running a script using this template, there's no errors

		-- Joints, etc
		char:WaitForChild'Body Colors':destroy()
		swait(30)
		for _,v in next, char:children() do
			if(v:IsA'BasePart')then
				v.Color = Color3.new(0,0,0)
			end
		end
		ClearChildrenWithClass(char,"Clothing")
		ClearChildrenWithClass(char,"Decal",true)
		if(PlayerSize ~= 1)then
			for _,v in next, char:GetDescendants() do
				if(v:IsA'BasePart' and v ~= head)then
					v.Size = v.Size + V3.N(0,PlayerSize,0)
				end
			end
		end


		-- Model

		local Music = sndFromData(Sounds.Creep,torso) -- incase u want music
		Music.MaxDistance = 150
		Music:Play()

		New = function(Object, Parent, Name, Data)
			local Object = Instance.new(Object)
			for Index, Value in pairs(Data or {}) do
				Object[Index] = Value
			end
			Object.Parent = Parent
			Object.Name = Name
			return Object
		end


		RightHand = New("Model",char,"RightHand",{})
		RightThumb3 = New("Part",RightHand,"RightThumb3",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.506300628, 0.122097097, 0.0965319052),CFrame = CFrame.new(-2.88806152, 3.8542099, 40.4611397, -0.556201279, 0.830963016, -0.0114059215, -0.77162528, -0.511289954, 0.37838766, 0.308594495, 0.219260782, 0.925572097),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightThumb3,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RT3 = New("Motor",RightThumb3,"RT3",{Part0 = RightThumb3,Part1 = rarm,C0 = CFrame.new(0, 0, 0, -0.556202769, -0.77162528, 0.3085953, 0.830965281, -0.511289954, 0.219261378, -0.0114059523, 0.37838766, 0.925574541),C1 = CFrame.new(-0.0785162449, -2.89579725, 0.67080307, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		RightThumb1 = New("Part",RightHand,"RightThumb1",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.691401064, 0.182097122, 0.146531895),CFrame = CFrame.new(-2.74397039, 4.38701391, 40.2574272, 9.31322575e-10, 0.999929607, -0.0114095779, -0.925635219, 0.00431760168, 0.378392458, 0.378415048, 0.0105611067, 0.925570071),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightThumb1,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RT1 = New("Motor",RightThumb1,"RT1",{Part0 = RightThumb1,Part1 = rarm,C0 = CFrame.new(0, 0, 0, 4.65661287e-10, -0.925635219, 0.378416061, 0.999932289, 0.00431760168, 0.0105611347, -0.0114096077, 0.378392458, 0.925572515),C1 = CFrame.new(0.0632407665, -2.36299324, 0.465457916, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		RightThumb2 = New("Part",RightHand,"RightThumb2",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.506300628, 0.182097122, 0.146531895),CFrame = CFrame.new(-2.78564548, 4.1021471, 40.3736534, -0.265260637, 0.964103878, -0.0114056403, -0.893617094, -0.241390631, 0.378390133, 0.36205411, 0.110564254, 0.925571144),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightThumb2,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RT2 = New("Motor",RightThumb2,"RT2",{Part0 = RightThumb2,Part1 = rarm,C0 = CFrame.new(0, 0, 0, -0.265261322, -0.893617094, 0.362055063, 0.964106381, -0.241390631, 0.110564545, -0.011405671, 0.378390133, 0.925573587),C1 = CFrame.new(0.0228948593, -2.64786005, 0.58215332, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		RightRing1 = New("Part",RightHand,"RightRing1",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.903318703, 0.237910748, 0.191444606),CFrame = CFrame.new(-2.70223427, 4.42609978, 39.6372681, -8.74571682e-16, 0.999929726, -0.01140894, -1, 8.7280996e-16, 4.78783679e-16, -4.85722573e-16, 0.01140894, 0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightRing1,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RR1 = New("Motor",RightRing1,"RR1",{Part0 = RightRing1,Part1 = rarm,C0 = CFrame.new(0, 0, 0, -4.36662425e-16, -1, -2.42861287e-16, 0.999932349, 4.35659617e-16, 0.0114089698, -0.0114089698, 2.42861287e-16, 0.999932349),C1 = CFrame.new(0.0978963375, -2.32390738, -0.155139923, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		RightRing2 = New("Part",RightHand,"RightRing2",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.661484122, 0.237910748, 0.191444606),CFrame = CFrame.new(-2.75668097, 4.02412987, 39.6369858, -0.265260428, 0.964103818, -0.0114074284, -0.964171648, -0.265279233, -2.93453445e-06, -0.00302898232, 0.0109979399, 0.999929607),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightRing2,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RR2 = New("Motor",RightRing2,"RR2",{Part0 = RightRing2,Part1 = rarm,C0 = CFrame.new(0, 0, 0, -0.265261173, -0.964171648, -0.0030289907, 0.964106381, -0.265279233, 0.0109979697, -0.0114074592, -2.93453445e-06, 0.999932289),C1 = CFrame.new(0.0434498787, -2.72587729, -0.154800415, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		RightRing3 = New("Part",RightHand,"RightRing3",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.661484122, 0.187910721, 0.121444605),CFrame = CFrame.new(-2.9025352, 3.68893909, 39.6421776, -0.556200862, 0.830963194, -0.0114040468, -0.831021726, -0.556240082, -5.50785398e-06, -0.00634796359, 0.00947394595, 0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightRing3,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RR3 = New("Motor",RightRing3,"RR3",{Part0 = RightRing3,Part1 = rarm,C0 = CFrame.new(0, 0, 0, -0.556202352, -0.831021726, -0.00634798082, 0.830965459, -0.556240082, 0.00947397202, -0.0114040766, -5.50785398e-06, 0.999932349),C1 = CFrame.new(-0.102335691, -3.06106806, -0.147941589, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		RightSmall3 = New("Part",RightHand,"RightSmall3",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.492783368, 0.139987156, 0.090472132),CFrame = CFrame.new(-2.89148712, 3.86882091, 39.3824615, -0.556200862, 0.830963194, -0.0114040468, -0.831021726, -0.556240082, -5.50785398e-06, -0.00634796359, 0.00947394595, 0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightSmall3,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RS3 = New("Motor",RightSmall3,"RS3",{Part0 = RightSmall3,Part1 = rarm,C0 = CFrame.new(0, 0, 0, -0.556202352, -0.831021726, -0.00634798082, 0.830965459, -0.556240082, 0.00947397202, -0.0114040766, -5.50785398e-06, 0.999932349),C1 = CFrame.new(-0.0942525864, -2.88118625, -0.40776825, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		RightSmall2 = New("Part",RightHand,"RightSmall2",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.492783368, 0.177235484, 0.142619774),CFrame = CFrame.new(-2.78283048, 4.11852694, 39.3785858, -0.265260428, 0.964103818, -0.0114074284, -0.964171648, -0.265279233, -2.93453445e-06, -0.00302898232, 0.0109979399, 0.999929607),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightSmall2,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RS2 = New("Motor",RightSmall2,"RS2",{Part0 = RightSmall2,Part1 = rarm,C0 = CFrame.new(0, 0, 0, -0.265261173, -0.964171648, -0.0030289907, 0.964106381, -0.265279233, 0.0109979697, -0.0114074592, -2.93453445e-06, 0.999932289),C1 = CFrame.new(0.0143530369, -2.63148022, -0.412883759, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		RightSmall1 = New("Part",RightHand,"RightSmall1",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.672941983, 0.177235484, 0.142619774),CFrame = CFrame.new(-2.74226999, 4.41798067, 39.3787918, -8.74571682e-16, 0.999929726, -0.01140894, -1, 8.7280996e-16, 4.78783679e-16, -4.85722573e-16, 0.01140894, 0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightSmall1,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RS1 = New("Motor",RightSmall1,"RS1",{Part0 = RightSmall1,Part1 = rarm,C0 = CFrame.new(0, 0, 0, -4.36662425e-16, -1, -2.42861287e-16, 0.999932349, 4.35659617e-16, 0.0114089698, -0.0114089698, 2.42861287e-16, 0.999932349),C1 = CFrame.new(0.0549132824, -2.33202648, -0.413139343, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		RightMiddle2 = New("Part",RightHand,"RightMiddle2",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.661484122, 0.237910748, 0.191444606),CFrame = CFrame.new(-2.75668097, 4.02412987, 39.8659973, -0.265260428, 0.964103818, -0.0114074284, -0.964171648, -0.265279233, -2.93453445e-06, -0.00302898232, 0.0109979399, 0.999929607),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightMiddle2,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RM2 = New("Motor",RightMiddle2,"RM2",{Part0 = RightMiddle2,Part1 = rarm,C0 = CFrame.new(0, 0, 0, -0.265261173, -0.964171648, -0.0030289907, 0.964106381, -0.265279233, 0.0109979697, -0.0114074592, -2.93453445e-06, 0.999932289),C1 = CFrame.new(0.0460636616, -2.72587729, 0.0741958618, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		RightMiddle3 = New("Part",RightHand,"RightMiddle3",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.661484122, 0.187910721, 0.121444605),CFrame = CFrame.new(-2.9025352, 3.68893909, 39.8711929, -0.556200862, 0.830963194, -0.0114040468, -0.831021726, -0.556240082, -5.50785398e-06, -0.00634796359, 0.00947394595, 0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightMiddle3,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RM3 = New("Motor",RightMiddle3,"RM3",{Part0 = RightMiddle3,Part1 = rarm,C0 = CFrame.new(0, 0, 0, -0.556202352, -0.831021726, -0.00634798082, 0.830965459, -0.556240082, 0.00947397202, -0.0114040766, -5.50785398e-06, 0.999932349),C1 = CFrame.new(-0.099722147, -3.06106806, 0.0810585022, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		RightMiddle1 = New("Part",RightHand,"RightMiddle1",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.903318703, 0.237910748, 0.191444606),CFrame = CFrame.new(-2.70223451, 4.42609978, 39.8662796, -8.74571682e-16, 0.999929726, -0.01140894, -1, 8.7280996e-16, 4.78783679e-16, -4.85722573e-16, 0.01140894, 0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightMiddle1,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RM1 = New("Motor",RightMiddle1,"RM1",{Part0 = RightMiddle1,Part1 = rarm,C0 = CFrame.new(0, 0, 0, -4.36662425e-16, -1, -2.42861287e-16, 0.999932349, 4.35659617e-16, 0.0114089698, -0.0114089698, 2.42861287e-16, 0.999932349),C1 = CFrame.new(0.100509882, -2.32390738, 0.0738601685, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		RightPoint2 = New("Part",RightHand,"RightPoint2",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.661484122, 0.237910748, 0.191444606),CFrame = CFrame.new(-2.75668097, 4.02412987, 40.1189232, -0.265260428, 0.964103818, -0.0114074284, -0.964171648, -0.265279233, -2.93453445e-06, -0.00302898232, 0.0109979399, 0.999929607),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightPoint2,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RP2 = New("Motor",RightPoint2,"RP2",{Part0 = RightPoint2,Part1 = rarm,C0 = CFrame.new(0, 0, 0, -0.265261173, -0.964171648, -0.0030289907, 0.964106381, -0.265279233, 0.0109979697, -0.0114074592, -2.93453445e-06, 0.999932289),C1 = CFrame.new(0.0489501953, -2.72587729, 0.327106476, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		RightPoint1 = New("Part",RightHand,"RightPoint1",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.903318703, 0.237910748, 0.191444606),CFrame = CFrame.new(-2.70223427, 4.42609978, 40.1192055, -8.74571682e-16, 0.999929726, -0.01140894, -1, 8.7280996e-16, 4.78783679e-16, -4.85722573e-16, 0.01140894, 0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightPoint1,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RP1 = New("Motor",RightPoint1,"RP1",{Part0 = RightPoint1,Part1 = rarm,C0 = CFrame.new(0, 0, 0, -4.36662425e-16, -1, -2.42861287e-16, 0.999932349, 4.35659617e-16, 0.0114089698, -0.0114089698, 2.42861287e-16, 0.999932349),C1 = CFrame.new(0.103396654, -2.32390738, 0.326766968, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		RightPoint3 = New("Part",RightHand,"RightPoint3",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.661484122, 0.187910721, 0.121444605),CFrame = CFrame.new(-2.9025352, 3.68893909, 40.1241188, -0.556200862, 0.830963194, -0.0114040468, -0.831021726, -0.556240082, -5.50785398e-06, -0.00634796359, 0.00947394595, 0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",RightPoint3,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		RP3 = New("Motor",RightPoint3,"RP3",{Part0 = RightPoint3,Part1 = rarm,C0 = CFrame.new(0, 0, 0, -0.556202352, -0.831021726, -0.00634798082, 0.830965459, -0.556240082, 0.00947397202, -0.0114040766, -5.50785398e-06, 0.999932349),C1 = CFrame.new(-0.0968353748, -3.06106806, 0.333969116, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})

		LeftHand = New("Model",char,"LeftHand",{})
		LeftRing3 = New("Part",LeftHand,"LeftRing3",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.661484122, 0.187910721, 0.121444605),CFrame = CFrame.new(-5.87245798, 3.68893909, 39.6276245, 0.556200862, -0.830963194, 0.0114040468, -0.831021726, -0.556240082, -5.50785398e-06, 0.00634796359, -0.00947394595, -0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftRing3,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LR3 = New("Motor",LeftRing3,"LR3",{Part0 = LeftRing3,Part1 = larm,C0 = CFrame.new(0, 0, 0, 0.556202352, -0.831021726, 0.00634798082, -0.830965459, -0.556240082, -0.00947397202, 0.0114040766, -5.50785398e-06, -0.999932349),C1 = CFrame.new(-0.0719299316, -3.06106091, -0.128562927, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		LeftThumb3 = New("Part",LeftHand,"LeftThumb3",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.506300628, 0.122097097, 0.0965319052),CFrame = CFrame.new(-5.84988785, 3.84491587, 40.4669914, 0.556201041, -0.830963075, 0.0114058144, -0.763831854, -0.516578019, -0.386921287, 0.327409238, 0.206493899, -0.922037423),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftThumb3,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LT3 = New("Motor",LeftThumb3,"LT3",{Part0 = LeftThumb3,Part1 = larm,C0 = CFrame.new(0, 0, 0, 0.556202531, -0.763831854, 0.327410102, -0.83096534, -0.516578019, 0.206494436, 0.0114058452, -0.386921287, -0.922039866),C1 = CFrame.new(-0.0397815704, -2.90508413, 0.71049118, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		LeftThumb1 = New("Part",LeftHand,"LeftThumb1",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.691401064, 0.182097122, 0.146531895),CFrame = CFrame.new(-5.99397993, 4.36571169, 40.2342873, 0, -0.999929726, 0.0114097474, -0.92210412, -0.00441493373, -0.386916876, 0.386939973, -0.0105209723, -0.922039211),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftThumb1,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LT1 = New("Motor",LeftThumb1,"LT1",{Part0 = LeftThumb1,Part1 = larm,C0 = CFrame.new(0, 0, 0, 0, -0.92210412, 0.386941016, -0.999932349, -0.00441493373, -0.0105210003, 0.0114097772, -0.386916876, -0.922041655),C1 = CFrame.new(-0.186520576, -2.38428831, 0.479446411, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		LeftThumb2 = New("Part",LeftHand,"LeftThumb2",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.506300628, 0.182097122, 0.146531895),CFrame = CFrame.new(-5.95230389, 4.08209562, 40.3535271, 0.265260607, -0.964103758, 0.0114053031, -0.887895226, -0.24887003, -0.386918515, 0.375868112, 0.0925075412, -0.922038496),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftThumb2,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LT2 = New("Motor",LeftThumb2,"LT2",{Part0 = LeftThumb2,Part1 = larm,C0 = CFrame.new(0, 0, 0, 0.265261352, -0.887895226, 0.375869095, -0.964106321, -0.24887003, 0.0925077796, 0.0114053339, -0.386918515, -0.922040939),C1 = CFrame.new(-0.143486023, -2.66790438, 0.598205566, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		LeftRing2 = New("Part",LeftHand,"LeftRing2",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.661484122, 0.237910748, 0.191444606),CFrame = CFrame.new(-6.0183115, 4.02412987, 39.6328354, 0.265260428, -0.964103818, 0.0114074284, -0.964171648, -0.265279233, -2.93453445e-06, 0.00302898232, -0.0109979399, -0.999929607),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftRing2,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LR2 = New("Motor",LeftRing2,"LR2",{Part0 = LeftRing2,Part1 = larm,C0 = CFrame.new(0, 0, 0, 0.265261173, -0.964171648, 0.0030289907, -0.964106381, -0.265279233, -0.0109979697, 0.0114074592, -2.93453445e-06, -0.999932289),C1 = CFrame.new(-0.217714787, -2.72587013, -0.121688843, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		LeftRing1 = New("Part",LeftHand,"LeftRing1",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.903318703, 0.237910748, 0.191444606),CFrame = CFrame.new(-6.07275867, 4.42609978, 39.6325493, -8.74571682e-16, -0.999929726, 0.01140894, -1, -8.7280996e-16, -4.78783679e-16, -4.85722573e-16, -0.01140894, -0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftRing1,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LR1 = New("Motor",LeftRing1,"LR1",{Part0 = LeftRing1,Part1 = larm,C0 = CFrame.new(0, 0, 0, -4.36662425e-16, -1, -2.42861287e-16, -0.999932349, -4.35659617e-16, -0.0114089698, 0.0114089698, -2.42861287e-16, -0.999932349),C1 = CFrame.new(-0.272161484, -2.32390022, -0.121353149, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		LeftSmall1 = New("Part",LeftHand,"LeftSmall1",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.672941983, 0.177235484, 0.142619774),CFrame = CFrame.new(-6.03272295, 4.41798019, 39.3710022, -8.74571682e-16, -0.999929726, 0.01140894, -1, -8.7280996e-16, -4.78783679e-16, -4.85722573e-16, -0.01140894, -0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftSmall1,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LS1 = New("Motor",LeftSmall1,"LS1",{Part0 = LeftSmall1,Part1 = larm,C0 = CFrame.new(0, 0, 0, -4.36662425e-16, -1, -2.42861287e-16, -0.999932349, -4.35659617e-16, -0.0114089698, 0.0114089698, -2.42861287e-16, -0.999932349),C1 = CFrame.new(-0.235113621, -2.33201981, -0.383338928, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		LeftMiddle3 = New("Part",LeftHand,"LeftMiddle3",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.661484122, 0.187910721, 0.121444605),CFrame = CFrame.new(-5.8724575, 3.68893909, 39.8385582, 0.556200862, -0.830963194, 0.0114040468, -0.831021726, -0.556240082, -5.50785398e-06, 0.00634796359, -0.00947394595, -0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftMiddle3,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LM3 = New("Motor",LeftMiddle3,"LM3",{Part0 = LeftMiddle3,Part1 = larm,C0 = CFrame.new(0, 0, 0, 0.556202352, -0.831021726, 0.00634798082, -0.830965459, -0.556240082, -0.00947397202, 0.0114040766, -5.50785398e-06, -0.999932349),C1 = CFrame.new(-0.0695223808, -3.06106091, 0.0823554993, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		LeftSmall3 = New("Part",LeftHand,"LeftSmall3",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.492783368, 0.139987156, 0.090472132),CFrame = CFrame.new(-5.88350391, 3.86882091, 39.3673401, 0.556200862, -0.830963194, 0.0114040468, -0.831021726, -0.556240082, -5.50785398e-06, 0.00634796359, -0.00947394595, -0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftSmall3,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LS3 = New("Motor",LeftSmall3,"LS3",{Part0 = LeftSmall3,Part1 = larm,C0 = CFrame.new(0, 0, 0, 0.556202352, -0.831021726, 0.00634798082, -0.830965459, -0.556240082, -0.00947397202, 0.0114040766, -5.50785398e-06, -0.999932349),C1 = CFrame.new(-0.0859460831, -2.88117909, -0.388706207, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		LeftPoint2 = New("Part",LeftHand,"LeftPoint2",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.661484122, 0.237910748, 0.191444606),CFrame = CFrame.new(-6.01831102, 4.02412987, 40.0808601, 0.265260428, -0.964103818, 0.0114074284, -0.964171648, -0.265279233, -2.93453445e-06, 0.00302898232, -0.0109979399, -0.999929607),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftPoint2,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LP2 = New("Motor",LeftPoint2,"LP2",{Part0 = LeftPoint2,Part1 = larm,C0 = CFrame.new(0, 0, 0, 0.265261173, -0.964171648, 0.0030289907, -0.964106381, -0.265279233, -0.0109979697, 0.0114074592, -2.93453445e-06, -0.999932289),C1 = CFrame.new(-0.212601185, -2.72587013, 0.326309204, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		LeftPoint1 = New("Part",LeftHand,"LeftPoint1",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.903318703, 0.237910748, 0.191444606),CFrame = CFrame.new(-6.07275915, 4.42609978, 40.080574, -8.74571682e-16, -0.999929726, 0.01140894, -1, -8.7280996e-16, -4.78783679e-16, -4.85722573e-16, -0.01140894, -0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftPoint1,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LP1 = New("Motor",LeftPoint1,"LP1",{Part0 = LeftPoint1,Part1 = larm,C0 = CFrame.new(0, 0, 0, -4.36662425e-16, -1, -2.42861287e-16, -0.999932349, -4.35659617e-16, -0.0114089698, 0.0114089698, -2.42861287e-16, -0.999932349),C1 = CFrame.new(-0.267048836, -2.32390022, 0.326644897, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		LeftMiddle1 = New("Part",LeftHand,"LeftMiddle1",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.903318703, 0.237910748, 0.191444606),CFrame = CFrame.new(-6.07275915, 4.42609978, 39.8434753, -8.74571682e-16, -0.999929726, 0.01140894, -1, -8.7280996e-16, -4.78783679e-16, -4.85722573e-16, -0.01140894, -0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftMiddle1,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LM1 = New("Motor",LeftMiddle1,"LM1",{Part0 = LeftMiddle1,Part1 = larm,C0 = CFrame.new(0, 0, 0, -4.36662425e-16, -1, -2.42861287e-16, -0.999932349, -4.35659617e-16, -0.0114089698, 0.0114089698, -2.42861287e-16, -0.999932349),C1 = CFrame.new(-0.269754887, -2.32390022, 0.0895614624, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		LeftSmall2 = New("Part",LeftHand,"LeftSmall2",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.492783368, 0.177235484, 0.142619774),CFrame = CFrame.new(-5.99216223, 4.11852694, 39.3712234, 0.265260428, -0.964103818, 0.0114074284, -0.964171648, -0.265279233, -2.93453445e-06, 0.00302898232, -0.0109979399, -0.999929607),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftSmall2,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LS2 = New("Motor",LeftSmall2,"LS2",{Part0 = LeftSmall2,Part1 = larm,C0 = CFrame.new(0, 0, 0, 0.265261173, -0.964171648, 0.0030289907, -0.964106381, -0.265279233, -0.0109979697, 0.0114074592, -2.93453445e-06, -0.999932289),C1 = CFrame.new(-0.194552898, -2.63147306, -0.383583069, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		LeftMiddle2 = New("Part",LeftHand,"LeftMiddle2",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.661484122, 0.237910748, 0.191444606),CFrame = CFrame.new(-6.01831198, 4.02412987, 39.8437614, 0.265260428, -0.964103818, 0.0114074284, -0.964171648, -0.265279233, -2.93453445e-06, 0.00302898232, -0.0109979399, -0.999929607),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftMiddle2,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LM2 = New("Motor",LeftMiddle2,"LM2",{Part0 = LeftMiddle2,Part1 = larm,C0 = CFrame.new(0, 0, 0, 0.265261173, -0.964171648, 0.0030289907, -0.964106381, -0.265279233, -0.0109979697, 0.0114074592, -2.93453445e-06, -0.999932289),C1 = CFrame.new(-0.215307713, -2.72587013, 0.089225769, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})
		LeftPoint3 = New("Part",LeftHand,"LeftPoint3",{BrickColor = BrickColor.new("Institutional white"),Size = Vector3.new(0.661484122, 0.187910721, 0.121444605),CFrame = CFrame.new(-5.87245798, 3.68893909, 40.0756569, 0.556200862, -0.830963194, 0.0114040468, -0.831021726, -0.556240082, -5.50785398e-06, 0.00634796359, -0.00947394595, -0.999929726),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0,0,0),})
		Mesh = New("SpecialMesh",LeftPoint3,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		LP3 = New("Motor",LeftPoint3,"LP3",{Part0 = LeftPoint3,Part1 = larm,C0 = CFrame.new(0, 0, 0, 0.556202352, -0.831021726, 0.00634798082, -0.830965459, -0.556240082, -0.00947397202, 0.0114040766, -5.50785398e-06, -0.999932349),C1 = CFrame.new(-0.0668168068, -3.06106091, 0.319438934, 0.999933541, -3.70949382e-11, 0.011412913, 3.63313581e-11, 1, 6.71462261e-11, -0.011412913, -6.67270544e-11, 0.999933541),})

		EyeModel = New("Model",char,"Model",{})
		Eye = New("Part",EyeModel,"Eye",{BrickColor = BrickColor.new("Bright violet"),Material = Enum.Material.Neon,Size = Vector3.new(0.427516103, 0.102584302, 0.371444672),CFrame = CFrame.new(-4.31106234, 9.50574684, 39.2028084, -1.44810004e-08, -6.24196239e-15, -1, -1, -8.88213606e-07, -1.44810004e-08, 8.88213606e-07, 1, 6.24196112e-15),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.419608, 0.196078, 0.486275),})
		Mesh = New("SpecialMesh",Eye,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		Part = New("Part",EyeModel,"Part",{BrickColor = BrickColor.new("Really black"),Size = Vector3.new(0.427516103, 0.132767469, 0.155850768),CFrame = CFrame.new(-4.31104565, 9.50574684, 39.2092743, -4.34430021e-08, -5.73125531e-14, -1, -1, -2.66464076e-06, -4.34430021e-08, 2.66464076e-06, 1, 5.73125531e-14),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.0666667, 0.0666667, 0.0666667),})
		Mesh = New("SpecialMesh",Part,"Mesh",{MeshType = Enum.MeshType.Sphere,})
		mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Eye,C0 = CFrame.new(0, 0, 0, -1.44810004e-08, -1, 8.88213606e-07, -6.24196239e-15, -8.88213606e-07, 1, -1, -1.44810004e-08, 6.24196112e-15),C1 = CFrame.new(0, 0.00646591187, -1.66893005e-05, -1.44810004e-08, -1, 8.88213606e-07, -6.24196239e-15, -8.88213606e-07, 1, -1, -1.44810004e-08, 6.24196112e-15),})
		-- joints
		local LS = NewInstance('Motor',char,{Part0=torso,Part1=larm,C0 = CF.N(-1.5,0.5,0),C1 = CF.N(0,.5,0)})
		local RS = NewInstance('Motor',char,{Part0=torso,Part1=rarm,C0 = CF.N(1.5,0.5,0),C1 = CF.N(0,.5,0)})
		local NK = NewInstance('Motor',char,{Part0=torso,Part1=head,C0 = CF.N(0,torso.Size.y/2+.5,0)})
		local LH = NewInstance('Motor',char,{Part0=torso,Part1=lleg,C0 = CF.N(-.5,-1 - PlayerSize,0),C1 = CF.N(0,1,0)})
		local RH = NewInstance('Motor',char,{Part0=torso,Part1=rleg,C0 = CF.N(.5,-1 - PlayerSize,0),C1 = CF.N(0,1,0)})
		local RJ = NewInstance('Motor',char,{Part0=root,Part1=torso})
		local EW = NewInstance('Motor',char,{Part0=head,Part1=Eye,C0=CF.N(0,0,-.6)*CF.A(M.R(90),M.R(90),0)})

		for _,v in next, LeftHand:GetDescendants() do
			if(v:IsA'JointInstance')then
				v.C0 = v.C0 * v.C1:inverse()
				v.C1 = CF.N()
			end
		end
		for _,v in next, RightHand:GetDescendants() do
			if(v:IsA'JointInstance')then
				v.C0 = v.C0 * v.C1:inverse()
				v.C1 = CF.N()
			end
		end

		--local HW = NewInstance('Motor',char,{Part0=rarm,Part1=Handle,C0 = CF.N(0,.5,0)})
		hum.CameraOffset = V3.N(0,PlayerSize/2,0)

		-- Default C0s
		local LSD=LS.C0
		local RSD=RS.C0	
		local HD=NK.C0
		local TD=RJ.C0
		local LHD=LH.C0
		local RHD=RH.C0

		-- Check State
		function CheckState(rPart)
			if(rPart.Velocity.y > .35 and hum:GetState() == Enum.HumanoidStateType.Freefall)then
				return 'Jump';		
			elseif(rPart.Velocity.y < -.35 and hum:GetState() == Enum.HumanoidStateType.Freefall)then
				return 'Fall';
			elseif(math.abs(rPart.Velocity.x) > 2 or math.abs(rPart.Velocity.z) > 2 and hum:GetState() ~= Enum.HumanoidStateType.Freefall)then
				return 'Walk';
			end
			return 'Idle';
		end

		-- Effect Functions
		function SphereFX(duration,color,scale,pos,endScale)
			local rng = Instance.new("Part", char)
			rng.Anchored = true
			rng.BrickColor = color
			rng.CanCollide = false
			rng.FormFactor = 3
			rng.Name = "Ring"
			rng.Size = Vector3.new(1,1,1)
			rng.Transparency = 0
			rng.TopSurface = 0
			rng.BottomSurface = 0
			rng.CFrame = pos
			local rngm = Instance.new("SpecialMesh", rng)
			rngm.MeshType = "Sphere"
			rngm.Scale = scale
			table.insert(Effects, {Frame = 0, Effect="Sphere", Duration = duration or 30, Part=rng, Mesh = rngm, Scale = scale, EndScale = endScale or scale*2, Position = pos})
			return rng
		end

		function BlastFX(duration,color,scale,pos,endScale)
			local rng = Instance.new("Part", char)
			rng.Anchored = true
			rng.BrickColor = color
			rng.CanCollide = false
			rng.FormFactor = 3
			rng.Name = "Ring"
			rng.Size = Vector3.new(1,1,1)
			rng.Transparency = 0
			rng.TopSurface = 0
			rng.BottomSurface = 0
			rng.CFrame = pos
			local rngm = Instance.new("SpecialMesh", rng)
			rngm.MeshType = "FileMesh"
			rngm.MeshId = 'rbxassetid://20329976'
			rngm.Scale = scale
			table.insert(Effects, {Frame = 0, Effect="Sphere", Duration = duration or 30, Part=rng, Mesh = rngm, Scale = scale, EndScale = endScale or scale*2, Position = pos})
			return rng
		end

		function BlockFX(duration,color,scale,pos,endScale)
			local rng = Instance.new("Part", char)
			rng.Anchored = true
			rng.BrickColor = color
			rng.CanCollide = false
			rng.FormFactor = 3
			rng.Name = "Ring"
			rng.Size = Vector3.new(1,1,1)
			rng.Transparency = 0
			rng.TopSurface = 0
			rng.BottomSurface = 0
			rng.CFrame = pos
			local rngm = Instance.new("BlockMesh", rng)
			rngm.Scale = scale
			table.insert(Effects, {Frame = 0, Effect="Block", Duration = duration or 30, Part=rng, Mesh = rngm, Scale = scale, EndScale = endScale or scale*2, Position = pos})
			return rng
		end


		function BloodDrop(pos,dir,maxsize)
			local owo = NewInstance("Part",char,{Material=BloodMaterial,BrickColor=BloodColor,Shape=Enum.PartType.Ball,Size=V3.N(.25,.25,.25), CanCollide = false})
			owo.CFrame=CF.N(pos,dir)
			local bv = Instance.new("BodyVelocity",owo) 
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = CF.N(pos,dir+V3.N(M.RNG(-3,3)/30,M.RNG(-3,3)/30,M.RNG(-3,3)/30)).lookVector*15
			bv.Name = "MOVE"
			game:service'Debris':AddItem(bv,0.05)
			local touch 
			touch = owo.Touched:connect(function(hit)
				if(hit.Anchored==true)then
					touch:disconnect()
					BloodPuddle(owo.Position+V3.N(0,1,0),10,maxsize,owo)
					owo:destroy()
				end
			end)
		end
		function BloodPuddle(position,range,maxSize,where)
			local hit, pos, norm = workspace:FindPartOnRayWithIgnoreList(Ray.new(
				position,CF.N(position,position+V3.N(0,-1,0)).lookVector * range			
				),{where,char},false,true)
			if(hit)then
				if(BloodPuddles[hit])then
					BloodPuddles[hit].Frame = 0
					if(hit:FindFirstChild'CylinderMesh' and hit.CylinderMesh.Scale.Z < BloodPuddles[hit].MaxSize)then
						hit.CylinderMesh.Scale = hit.CylinderMesh.Scale + V3.N(.1,0,.1)
					end
				else
					local Puddle = NewInstance('Part',workspace,{Material=BloodMaterial,BrickColor=BloodColor,Size=V3.N(1,.1,1),CFrame=CF.N(pos,pos+norm)*CF.A(90*M.P/180,0,0),Anchored=true,CanCollide=false,Archivable=false,Locked=true,Name='BloodPuddle'})
					local Cyl = NewInstance('CylinderMesh',Puddle,{Name='CylinderMesh'})
					BloodPuddles[Puddle] = {MaxSize=maxSize or 7,Frame=0}
				end
			end
		end

		function AcidDrop(pos,dir,maxsize)
			print'acid'
			local owo = NewInstance("Part",char,{Material=Enum.Material.Glass,BrickColor=BrickColor.new'Royal purple',Shape=Enum.PartType.Ball,Size=V3.N(.4,.4,.4), CanCollide = false})
			owo.CFrame=CF.N(pos,dir)
			local bv = Instance.new("BodyVelocity",owo) 
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = CF.N(pos,dir+V3.N(M.RNG(-3,3)/30,M.RNG(-3,3)/30,M.RNG(-3,3)/30)).lookVector*15
			bv.Name = "MOVE"
			game:service'Debris':AddItem(bv,0.05)
			local touch 
			touch = owo.Touched:connect(function(hit)
				if(hit.Anchored==true and hit.Parent ~= char and hit.CanCollide)then
					touch:disconnect()
					AcidPuddle(owo.Position+V3.N(0,1,0),10,maxsize,owo)
					owo:destroy()
				end
			end)
		end
		function AcidPuddle(position,range,maxSize,where)
			local hit, pos, norm = workspace:FindPartOnRayWithIgnoreList(Ray.new(
				position,CF.N(position,position+V3.N(0,-1,0)).lookVector * range			
				),{where,char},false,true)
			if(hit)then
				if(not BloodPuddles[hit] and hit.Anchored and hit.CanCollide)then
					Puddle = NewInstance('Part',workspace,{Material=Enum.Material.Glass,BrickColor=BrickColor.new'Royal purple',Size=V3.N(6,.05,6),CFrame=CF.N(pos,pos+norm)*CF.A(90*M.P/180,0,0),Anchored=true,CanCollide=false,Archivable=false,Locked=true,Name='BloodPuddle'})
					local Cyl = NewInstance('CylinderMesh',Puddle,{Name='CylinderMesh'})
					coroutine.wrap(function()
						local Puddle = Puddle
						swait(60*5)
						for i = 0, 1, .05 do
							Puddle.Transparency = i
							Puddle.Size = Puddle.Size - V3.N(.29,0,.29)
							swait()
						end
						Puddle:destroy()
					end)()
				end
			end
		end

		function LaserFX(duration,color,cframe,scale,endScale)
			local rng = Instance.new("Part", char)
			rng.Anchored = true
			rng.BrickColor = color
			rng.CanCollide = false
			rng.FormFactor = 3
			rng.Material = Enum.Material.Neon
			rng.Name = "Laser"
			rng.Size = Vector3.new(.5,.5,.5)
			rng.Transparency = 0
			rng.TopSurface = 0
			rng.BottomSurface = 0
			rng.CFrame = cframe
			local rngm = Instance.new("CylinderMesh", rng)
			rngm.Scale = scale
			table.insert(Effects, {Frame = 0, Effect="Sphere", Duration = duration or 30, Part=rng, Mesh = rngm, Scale = scale, EndScale = endScale or scale*2, Position = cframe})
			return rng
		end

		function ShatterFX(duration,color,scale,cframe)
			local rng = Instance.new("Part", char)
			rng.Anchored = true
			rng.BrickColor = color
			rng.CanCollide = false
			rng.FormFactor = 3
			rng.Name = "Ring"
			rng.Size = Vector3.new(1,1,1)
			rng.Transparency = 0
			rng.TopSurface = 0
			rng.BottomSurface = 0
			rng.CFrame = cframe * CF.fEA(M.RNG(-50, 50), M.RNG(-50, 50), M.RNG(-50, 50))
			local rngm = Instance.new("SpecialMesh", rng)
			rngm.Scale = scale
			rngm.MeshType = "Sphere"
			table.insert(Effects, {Frame = 0, Effect="Shatter", Duration = duration or 30, Part=rng, Mesh = rngm, Scale = scale,Position=rng.CFrame})
		end

		function RingFX(duration,color,scale,pos,endScale)
			local type = type
			local rng = Instance.new("Part", char)
			rng.Anchored = true
			rng.BrickColor = color
			rng.CanCollide = false
			rng.FormFactor = 3
			rng.Name = "Ring"
			rng.Size = Vector3.new(1,1,1)
			rng.Transparency = 0
			rng.TopSurface = 0
			rng.BottomSurface = 0
			rng.CFrame = pos
			local rngm = Instance.new("SpecialMesh", rng)
			rngm.MeshId = "rbxassetid://3270017"
			rngm.Scale = scale
			table.insert(Effects, {Frame = 0, Effect="Sphere", Duration = duration or 30, Part=rng, Mesh = rngm, Scale = scale, EndScale = endScale or scale*2, Position = pos})
			return rng
		end

		function Shoot(StartCF,EndCF,Spread,Speed,Num,Color,Drop,MinDamage,MaxDamage)
			local Spread = V3.N(M.RNG(-Spread,Spread),M.RNG(-Spread,Spread),M.RNG(-Spread,Spread))
			local Start = StartCF.p
			local End = EndCF.p
			local SpreadPos = End + Spread
			local Look = CF.N((Start + SpreadPos) / 2, SpreadPos)
			local Count = Num
			spawn(function()
				repeat
					wait()
					local hit, pos = workspace:findPartOnRay(Ray.new(
						Start,(Look.lookVector).unit * Speed		
						),char,false,true)
					local dist = (Start-pos).magnitude
					local yScale = dist * (Speed / (Speed/2))
					local aa = CF.N((Start + pos) / 2, pos) * CFrame.Angles(1.57, 0, 0)
					LaserFX(25,Color,aa,Vector3.new(1,yScale,1),Vector3.new(-1,yScale,-1))
					Start = Start + Look.lookVector	* Speed
					Look = Look * CF.A(M.R(Drop or -1),0,0)
					Count = Count - 1

					if(hit)then
						Count = 0
						MagniDamage(pos,10,MinDamage,MaxDamage,0,'Normal')
					end
					if(Count <= 0)then
						local sphere = SphereFX(25,Color,Vector3.new(5,5,5),CF.N(pos),Vector3.new(15,15,15))
						local ring = RingFX(25,Color,Vector3.new(6,6,6),CF.N(pos) * CF.A(0,M.R(90),0)  * CF.A(M.R(M.RNG(-360,360)),M.R(M.RNG(-360,360)),M.R(M.RNG(-360,360))),Vector3.new(16,16,16))
					end
				until Count <= 0
			end)
		end

		-- Effect Loop

		runService:BindToRenderStep("N_Effects",Enum.RenderPriority.Character.Value + 2,function()
			for _,data in next, Effects do
				local frame,effect,duration = data.Frame,data.Effect,data.Duration
				local transparency = (frame / duration)
				local opacity = 1 - transparency
				if(frame > duration)then
					Effects[_] = nil
				end
				frame = frame + 1
				data.Frame = frame	
				if(effect == 'Sphere')then
					local Part,Mesh,Scale,CF,eScale = data.Part,data.Mesh,data.Scale,data.Position,data.EndScale 
					Mesh.Scale = Mesh.Scale:lerp(eScale, transparency/6)
					Part.Transparency = transparency
					if(frame > duration)then
						Part:destroy()
					end
				elseif(effect == 'Shatter')then	
					local Part,Mesh,Scale,Position,Thingie,Thingie2,Inc = data.Part,
					data.Mesh,
					data.Scale,
					data.Position,
					(data.Thingie or 0),
					(data.Thingie2 or M.RNG(50, 100) / 100),
					(data.Inc or M.RNG() - M.RNG())
					Part.Transparency = transparency
					Position = Position * CF.N(0,Thingie2,0)
					Part.CFrame = Position * CF.fEA(Thingie,0,0)
					Thingie = Thingie + Inc

					data.Position = Position
					data.Thingie = Thingie
					data.Thingie2 = Thingie2
					data.Inc = Inc
				elseif(effect == 'Block')then
					local Part,Mesh,Scale,CF,eScale = data.Part,data.Mesh,data.Scale,data.Position,data.EndScale 
					Mesh.Scale = Mesh.Scale:lerp(eScale, transparency/6)
					Part.Transparency = transparency
					Part.CFrame = CF * CFrame.Angles(M.R(M.RNG(-360,360)),M.R(M.RNG(-360,360)),M.R(M.RNG(-360,360)))
					if(frame > duration)then
						Part:destroy()
					end
				end
			end
			for puddle,data in next, BloodPuddles do
				if(puddle.Transparency > 0.9)then
					BloodPuddles[puddle] = nil
					puddle:destroy()
				end
				data.Frame = data.Frame + 1
				if(data.Frame > 105)then
					local trans = (data.Frame-105)/90
					puddle.Transparency = trans
					if(puddle:FindFirstChild'CylinderMesh' and puddle.CylinderMesh.Scale.Z > 0)then
						puddle.CylinderMesh.Scale = puddle.CylinderMesh.Scale-V3.N(.1,0,.1)
					end
				else
					puddle.Transparency = 0
				end
			end
			if(Puddle and Puddle.Parent)then
				for _,v in next, workspace:children() do
					if(v:IsA'Model')then
						local h = v:FindFirstChild'Head'
						local hu = v:FindFirstChildOfClass'Humanoid'
						if(h and h:IsA'BasePart' and hu)then
							if((h.CFrame.p-Puddle.CFrame.p).magnitude < 7)then
								DealDamage(v,3,6,1,"Freeze")
							end
						end
					end
				end
			end
		end)

		-- Animation Loop
		runService:BindToRenderStep("N_Animations",Enum.RenderPriority.Character.Value + 1,function()
			sine=sine+change
			hum.WalkSpeed = WalkSpeed
			local hitfloor,posfloor = workspace:FindPartOnRay(Ray.new(root.CFrame.p,((CFrame.new(root.Position,root.Position - Vector3.new(0,1,0))).lookVector).unit * 8), char)
			local State = (not hitfloor and root.Velocity.y < -1 and "Fall" or not hitfloor and root.Velocity.y > 1 and "Jump" or hitfloor and (math.abs(root.Velocity.x) > 1 or math.abs(root.Velocity.z) > 1) and "Walk" or hitfloor and "Idle")


			local wsVal = 6 / (hum.WalkSpeed / 16)
			local exactVel = CFrame.new(root.CFrame:vectorToObjectSpace(root.Velocity))
			if(State == 'Walk')then
				change = 2/3
				RH.C1 = clerp(RH.C1,CF.N(0,0.8-.25*M.S(sine/wsVal),-M.R(15+65*M.C(sine/wsVal)))*CF.A(M.R(15+65*M.C(sine/wsVal)),0,0)*CF.A(M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7))),.2*(hum.WalkSpeed/16))
				LH.C1 = clerp(LH.C1,CF.N(0,0.8+.25*M.S(sine/wsVal),M.R(15+65*M.C(sine/wsVal)))*CF.A(M.R(15+65*-M.C(sine/wsVal)),0,0)*CF.A(M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7))),.2*(hum.WalkSpeed/16))
			else	
				RH.C1 = clerp(RH.C1,CF.N(0,1,0),.1)
				LH.C1 = clerp(LH.C1,CF.N(0,1,0),.1)
			end
			if(neutralAnims)then
				if(State == 'Idle')then
					-- Idle anim
					local Alpha = .2
					RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00653425185, -0.367415309, -0.572485209, 0.999995291, -0.00257562893, -0.000296123326, 0.00257599982, 0.974187136, 0.22572732, -0.000292910263, -0.225727022, 0.974189222),Alpha)
					LH.C0 = clerp(LH.C0,CFrame.new(-0.503953636, -3.23575497, -0.0791287646, 1, 0.000350067159, -1.45565718e-06, -0.00034994795, 0.999533594, -0.0305390507, -9.23592597e-06, 0.0305390656, 0.999533653)*CF.A(M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7))),Alpha)
					RH.C0 = clerp(RH.C0,CFrame.new(0.49835059, -3.15593815, -0.187087312, 0.999996603, 0.00258975197, -0.000121647492, -0.00257564802, 0.987003267, -0.160680294, -0.000296056271, 0.1606801, 0.987006545)*CF.A(M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7))),Alpha)
					LS.C0 = clerp(LS.C0,CFrame.new(-1.43127036, 0.451340854, -0.462174714, 0.997353315, 0.0727057606, -0.000517063774, -0.0693833008, 0.949603021, -0.305679858, -0.0217336789, 0.304906696, 0.952134252)*CF.A(M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7))),Alpha)
					RS.C0 = clerp(RS.C0,CFrame.new(1.41581738, 0.455256999, -0.457439601, 0.996124089, -0.0879578516, -0.000504340976, 0.0835438147, 0.947897792, -0.307425261, 0.0275185313, 0.306191564, 0.95157218)*CF.A(M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7))),Alpha)
					NK.C0 = clerp(NK.C0,CFrame.new(-1.90670835e-06, 2.74999475, -7.62939453e-06, 1, 2.32830644e-10, -9.31322575e-10, 2.32830644e-10, 1, 0, -9.31322575e-10, 0, 1)*CF.A(M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7))),Alpha)
					RT3.C0 = clerp(RT3.C0,CFrame.new(1.61375785, -1.76555657, -0.513190091, -0.55665189, 0.810403109, 0.182717308, -0.771965683, -0.585860789, 0.24665007, 0.306932837, -0.00375326723, 0.951723814),Alpha)
					RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36366892, -0.0526333712, 0.463351786, 0.00432222337, -0.925635338, 0.378392518, 0.999990284, 0.00432161195, -0.000850837678, -0.000847693533, 0.378392458, 0.925644875),Alpha)
					RT2.C0 = clerp(RT2.C0,CFrame.new(1.2538718, -2.21410918, -0.524856687, -0.771987855, 0.583863854, 0.251272887, -0.556619704, -0.811843097, 0.176310748, 0.306935579, -0.00375370681, 0.95172298),Alpha)
					RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32391119, -0.0978909656, 0.155143276, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RR2.C0 = clerp(RR2.C0,CFrame.new(1.25468278, -2.23918462, 0.480947077, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RR3.C0 = clerp(RR3.C0,CFrame.new(1.53806043, -1.79355478, 0.474106222, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RS3.C0 = clerp(RS3.C0,CFrame.new(1.49055731, -1.77398741, 0.730609715, -0.660822511, 0.739318788, -0.129311174, -0.748390913, -0.662110388, 0.0389984399, -0.0567859784, 0.12254636, 0.990836978),Alpha)
					RS2.C0 = clerp(RS2.C0,CFrame.new(1.12350154, -2.19243288, 0.735727072, -0.863375664, 0.492343336, -0.110365942, -0.501357257, -0.861730874, 0.0778523907, -0.0567756221, 0.122548625, 0.990837216),Alpha)
					RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33202672, -0.0549109876, 0.413173437, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RM2.C0 = clerp(RM2.C0,CFrame.new(1.255373, -2.24170375, 0.251963019, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RM3.C0 = clerp(RM3.C0,CFrame.new(1.5395211, -1.79571998, 0.245096236, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RM1.C0 = clerp(RM1.C0,CFrame.new(-2.323915, -0.100503564, -0.0738568455, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP2.C0 = clerp(RP2.C0,CFrame.new(1.25615263, -2.2444911, -0.000960677862, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32391214, -0.103389643, -0.32676369, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP3.C0 = clerp(RP3.C0,CFrame.new(1.54112804, -1.79812348, -0.0077983737, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					LR3.C0 = clerp(LR3.C0,CFrame.new(1.45705879, -1.89598083, -0.385099679, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LT3.C0 = clerp(LT3.C0,CFrame.new(1.40952325, -1.97281897, 0.526059091, 0.671315253, 0.714624286, 0.196591273, 0.679187477, -0.699324131, 0.222823307, 0.296715915, -0.0160623491, -0.954830825),Alpha)
					LT1.C0 = clerp(LT1.C0,CFrame.new(-2.3832376, -0.197773144, -0.480284959, 0.00441737333, -0.922104299, 0.38691628, -0.999989927, -0.00441598753, 0.000892503187, 0.000885637477, -0.38691628, -0.922114491),Alpha)
					LT2.C0 = clerp(LT2.C0,CFrame.new(0.99463892, -2.34625196, 0.514375746, 0.851474643, 0.457154393, 0.256906241, 0.432377875, -0.889242351, 0.14932391, 0.296715945, -0.0160649493, -0.954830766),Alpha)
					LR2.C0 = clerp(LR2.C0,CFrame.new(1.14547455, -2.31078553, -0.378219754, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390952, -0.272462696, -0.121384747, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33202744, -0.23541376, -0.383374184, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM3.C0 = clerp(LM3.C0,CFrame.new(1.45572555, -1.89398086, -0.174214169, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LS3.C0 = clerp(LS3.C0,CFrame.new(1.49722528, -1.81738269, -0.636980891, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LP2.C0 = clerp(LP2.C0,CFrame.new(1.14411652, -2.30584955, 0.0697559863, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32390475, -0.267352402, 0.326590419, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32390952, -0.270056516, 0.0895184278, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS2.C0 = clerp(LS2.C0,CFrame.new(1.11611402, -2.23573709, -0.631830394, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LM2.C0 = clerp(LM2.C0,CFrame.new(1.14484239, -2.30846381, -0.167330459, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP3.C0 = clerp(LP3.C0,CFrame.new(1.45421648, -1.89172983, 0.0628871024, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
				elseif(State == 'Walk')then		
					-- Walk anim
					local Alpha = .2*(hum.WalkSpeed/16)

					RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00653425185, -0.367415309+.2*M.C(sine/wsVal), -0.572485209, 0.999995291, -0.00257562893, -0.000296123326, 0.00257599982, 0.974187136, 0.22572732, -0.000292910263, -0.225727022, 0.974189222),Alpha)
					LH.C0 = clerp(LH.C0,CFrame.new(-0.503953636, -3.23575497-.2*M.C(sine/wsVal), -0.0791287646, 1, 0.000350067159, -1.45565718e-06, -0.00034994795, 0.999533594, -0.0305390507, -9.23592597e-06, 0.0305390656, 0.999533653)*CF.A(M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7))),Alpha)
					RH.C0 = clerp(RH.C0,CFrame.new(0.49835059, -3.15593815-.2*M.C(sine/wsVal), -0.187087312, 0.999996603, 0.00258975197, -0.000121647492, -0.00257564802, 0.987003267, -0.160680294, -0.000296056271, 0.1606801, 0.987006545)*CF.A(M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7))),Alpha)
					LS.C0 = clerp(LS.C0,CFrame.new(-1.43127036, 0.451340854+M.R(0+25*-M.C(sine/wsVal)), -0.462174714-M.R(0+25*-M.C(sine/wsVal)), 0.997353315, 0.0727057606, -0.000517063774, -0.0693833008, 0.949603021, -0.305679858, -0.0217336789, 0.304906696, 0.952134252)*CF.A(M.R(0+25*-M.C(sine/wsVal)),0,0),Alpha)
					RS.C0 = clerp(RS.C0,CFrame.new(1.41581738, 0.455256999+M.R(0+25*M.C(sine/wsVal)), -0.457439601-M.R(0+25*M.C(sine/wsVal)), 0.996124089, -0.0879578516, -0.000504340976, 0.0835438147, 0.947897792, -0.307425261, 0.0275185313, 0.306191564, 0.95157218)*CF.A(M.R(0+25*M.C(sine/wsVal)),0,0),Alpha)
					NK.C0 = clerp(NK.C0,CFrame.new(-1.90670835e-06, 2.74999475, -7.62939453e-06, 1, 2.32830644e-10, -9.31322575e-10, 2.32830644e-10, 1, 0, -9.31322575e-10, 0, 1)*CF.A(M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7)),M.R(M.RNG(-7,7))),Alpha)
					RT3.C0 = clerp(RT3.C0,CFrame.new(1.61375785, -1.76555657, -0.513190091, -0.55665189, 0.810403109, 0.182717308, -0.771965683, -0.585860789, 0.24665007, 0.306932837, -0.00375326723, 0.951723814),Alpha)
					RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36366892, -0.0526333712, 0.463351786, 0.00432222337, -0.925635338, 0.378392518, 0.999990284, 0.00432161195, -0.000850837678, -0.000847693533, 0.378392458, 0.925644875),Alpha)
					RT2.C0 = clerp(RT2.C0,CFrame.new(1.2538718, -2.21410918, -0.524856687, -0.771987855, 0.583863854, 0.251272887, -0.556619704, -0.811843097, 0.176310748, 0.306935579, -0.00375370681, 0.95172298),Alpha)
					RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32391119, -0.0978909656, 0.155143276, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RR2.C0 = clerp(RR2.C0,CFrame.new(1.25468278, -2.23918462, 0.480947077, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RR3.C0 = clerp(RR3.C0,CFrame.new(1.53806043, -1.79355478, 0.474106222, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RS3.C0 = clerp(RS3.C0,CFrame.new(1.49055731, -1.77398741, 0.730609715, -0.660822511, 0.739318788, -0.129311174, -0.748390913, -0.662110388, 0.0389984399, -0.0567859784, 0.12254636, 0.990836978),Alpha)
					RS2.C0 = clerp(RS2.C0,CFrame.new(1.12350154, -2.19243288, 0.735727072, -0.863375664, 0.492343336, -0.110365942, -0.501357257, -0.861730874, 0.0778523907, -0.0567756221, 0.122548625, 0.990837216),Alpha)
					RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33202672, -0.0549109876, 0.413173437, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RM2.C0 = clerp(RM2.C0,CFrame.new(1.255373, -2.24170375, 0.251963019, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RM3.C0 = clerp(RM3.C0,CFrame.new(1.5395211, -1.79571998, 0.245096236, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RM1.C0 = clerp(RM1.C0,CFrame.new(-2.323915, -0.100503564, -0.0738568455, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP2.C0 = clerp(RP2.C0,CFrame.new(1.25615263, -2.2444911, -0.000960677862, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32391214, -0.103389643, -0.32676369, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP3.C0 = clerp(RP3.C0,CFrame.new(1.54112804, -1.79812348, -0.0077983737, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					LR3.C0 = clerp(LR3.C0,CFrame.new(1.45705879, -1.89598083, -0.385099679, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LT3.C0 = clerp(LT3.C0,CFrame.new(1.40952325, -1.97281897, 0.526059091, 0.671315253, 0.714624286, 0.196591273, 0.679187477, -0.699324131, 0.222823307, 0.296715915, -0.0160623491, -0.954830825),Alpha)
					LT1.C0 = clerp(LT1.C0,CFrame.new(-2.3832376, -0.197773144, -0.480284959, 0.00441737333, -0.922104299, 0.38691628, -0.999989927, -0.00441598753, 0.000892503187, 0.000885637477, -0.38691628, -0.922114491),Alpha)
					LT2.C0 = clerp(LT2.C0,CFrame.new(0.99463892, -2.34625196, 0.514375746, 0.851474643, 0.457154393, 0.256906241, 0.432377875, -0.889242351, 0.14932391, 0.296715945, -0.0160649493, -0.954830766),Alpha)
					LR2.C0 = clerp(LR2.C0,CFrame.new(1.14547455, -2.31078553, -0.378219754, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390952, -0.272462696, -0.121384747, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33202744, -0.23541376, -0.383374184, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM3.C0 = clerp(LM3.C0,CFrame.new(1.45572555, -1.89398086, -0.174214169, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LS3.C0 = clerp(LS3.C0,CFrame.new(1.49722528, -1.81738269, -0.636980891, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LP2.C0 = clerp(LP2.C0,CFrame.new(1.14411652, -2.30584955, 0.0697559863, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32390475, -0.267352402, 0.326590419, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32390952, -0.270056516, 0.0895184278, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS2.C0 = clerp(LS2.C0,CFrame.new(1.11611402, -2.23573709, -0.631830394, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LM2.C0 = clerp(LM2.C0,CFrame.new(1.14484239, -2.30846381, -0.167330459, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP3.C0 = clerp(LP3.C0,CFrame.new(1.45421648, -1.89172983, 0.0628871024, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
				elseif(State == 'Jump' or State == 'Fall')then
					RJ.C0 = clerp(RJ.C0,CFrame.new(0, 0, 0, 0.999989688, 1.3632216e-15, 0, 1.3632216e-15, 1, 2.56739074e-16, 0, 2.56739074e-16, 0.999989688),0.3)
					LH.C0 = clerp(LH.C0,CFrame.new(-0.499998271, -2.86761332, -0.423956037, 0.999994934, -3.7997961e-07, 1.88313425e-06, 3.7084294e-11, 0.980262458, 0.197700962, -1.92131847e-06, -0.197699949, 0.980257392),0.3)
					RH.C0 = clerp(RH.C0,CFrame.new(0.500029027, -1.90648031, -0.953526855, 0.999994934, 2.6863534e-05, -3.10875475e-05, 3.70871632e-11, 0.756630182, 0.653843105, 4.1087158e-05, -0.653839707, 0.756626308),0.3)
					LS.C0 = clerp(LS.C0,CFrame.new(-1.38248646, 0.493521869, -1.50245069e-05, 0.993936718, 0.109907441, -3.99537385e-07, -0.109908015, 0.993941784, -1.59255274e-06, 2.21654773e-07, 1.62678771e-06, 0.999994814),0.3)
					RS.C0 = clerp(RS.C0,CFrame.new(1.41221583, 0.513182044, 6.27265626e-06, 0.994822443, -0.101577446, -8.69855285e-07, 0.101577975, 0.994827569, -2.39775818e-06, 1.10827386e-06, 2.29699071e-06, 0.999994814),0.3)
					NK.C0 = clerp(NK.C0,CFrame.new(-3.79963094e-05, 2.73334718, -0.0034930706, 0.999994874, -1.12627167e-05, -4.15872782e-05, 3.7087295e-11, 0.965229452, -0.261404276, 4.30857763e-05, 0.261402935, 0.965224504),0.3)
					RT3.C0 = clerp(RT3.C0,CFrame.new(-2.48913026, -1.5558306, 0.47474587, -0.552640975, -0.771628797, 0.314923763, 0.833418965, -0.511285722, 0.209760875, -0.000841505826, 0.378385961, 0.925647557),0.3)
					RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36366272, -0.0526191629, 0.463347465, 0.00431827921, -0.925636768, 0.378388733, 0.999990344, 0.00431696139, -0.000851770863, -0.000845058821, 0.378388762, 0.925646424),0.3)
					RT2.C0 = clerp(RT2.C0,CFrame.new(-2.57271767, -0.719182789, 0.463071942, -0.261110842, -0.893618882, 0.365056634, 0.965308487, -0.24138996, 0.0995513573, -0.000839968212, 0.37838617, 0.925647497),0.3)
					RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32390428, -0.097856693, 0.155154705, 2.66222014e-06, -1, -3.41096893e-08, 1, 2.65463132e-06, -4.00096178e-06, 4.00003046e-06, -3.3993274e-08, 1),0.3)
					RR2.C0 = clerp(RR2.C0,CFrame.new(-2.61669111, -0.764986992, 0.154791445, -0.265275598, -0.964172542, -1.34762377e-06, 0.964172661, -0.265275627, -7.10878521e-06, 6.49597496e-06, -3.18500679e-06, 1),0.3)
					RR3.C0 = clerp(RR3.C0,CFrame.new(-2.60074496, -1.61762106, 0.147935733, -0.556236446, -0.83102411, 1.56415626e-06, 0.83102411, -0.556236386, -1.0849908e-05, 9.88598913e-06, -4.73484397e-06, 1),0.3)
					RS3.C0 = clerp(RS3.C0,CFrame.new(-2.44675827, -1.52428663, 0.407759368, -0.556236446, -0.83102411, 1.56415626e-06, 0.83102411, -0.556236386, -1.0849908e-05, 9.88598913e-06, -4.73484397e-06, 1),0.3)
					RS2.C0 = clerp(RS2.C0,CFrame.new(-2.53339791, -0.711884439, 0.41287148, -0.265275598, -0.964172542, -1.34762377e-06, 0.964172661, -0.265275627, -7.10878521e-06, 6.49597496e-06, -3.18500679e-06, 1),0.3)
					RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33202195, -0.0548965856, 0.413165748, 2.66222014e-06, -1, -3.41096893e-08, 1, 2.65463132e-06, -4.00096178e-06, 4.00003046e-06, -3.3993274e-08, 1),0.3)
					RM2.C0 = clerp(RM2.C0,CFrame.new(-2.61600137, -0.767494082, -0.0741972104, -0.265275598, -0.964172542, -1.34762377e-06, 0.964172661, -0.265275627, -7.10878521e-06, 6.49597496e-06, -3.18500679e-06, 1),0.3)
					RM3.C0 = clerp(RM3.C0,CFrame.new(-2.59929419, -1.61978698, -0.081060566, -0.556236446, -0.83102411, 1.56415626e-06, 0.83102411, -0.556236386, -1.0849908e-05, 9.88598913e-06, -4.73484397e-06, 1),0.3)
					RM1.C0 = clerp(RM1.C0,CFrame.new(-2.32390523, -0.100487918, -0.0738377646, 2.66222014e-06, -1, -3.41096893e-08, 1, 2.65463132e-06, -4.00096178e-06, 4.00003046e-06, -3.3993274e-08, 1),0.3)
					RP2.C0 = clerp(RP2.C0,CFrame.new(-2.61523294, -0.770287812, -0.327115476, -0.265275598, -0.964172542, -1.34762377e-06, 0.964172661, -0.265275627, -7.10878521e-06, 6.49597496e-06, -3.18500679e-06, 1),0.3)
					RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32390428, -0.103370823, -0.326767474, 2.66222014e-06, -1, -3.41096893e-08, 1, 2.65463132e-06, -4.00096178e-06, 4.00003046e-06, -3.3993274e-08, 1),0.3)
					RP3.C0 = clerp(RP3.C0,CFrame.new(-2.59769011, -1.62218094, -0.333978832, -0.556236446, -0.83102411, 1.56415626e-06, 0.83102411, -0.556236386, -1.0849908e-05, 9.88598913e-06, -4.73484397e-06, 1),0.3)
					LR3.C0 = clerp(LR3.C0,CFrame.new(-2.50364566, -1.76268733, -0.128605217, 0.556235969, -0.831024528, -2.17696652e-06, -0.831024587, -0.556235909, 9.77423042e-06, -9.33278352e-06, -3.62750143e-06, -1),0.3)
					LT3.C0 = clerp(LT3.C0,CFrame.new(-2.42466164, -1.68733382, -0.468865991, 0.559901595, -0.763835311, 0.321038753, -0.828558743, -0.516576529, 0.215961084, 0.000882378779, -0.386916399, -0.922114372),0.3)
					LT1.C0 = clerp(LT1.C0,CFrame.new(-2.38324189, -0.197767839, -0.480271369, 0.00441723922, -0.922106087, 0.386912167, -0.999989986, -0.00441567414, 0.000892929733, 0.000885100104, -0.386912197, -0.92211616),0.3)
					LT2.C0 = clerp(LT2.C0,CFrame.new(-2.55308509, -0.864325583, -0.480534732, 0.269532174, -0.887898088, 0.372813046, -0.962990999, -0.248868316, 0.103503212, 0.000881056301, -0.386913002, -0.922115803),0.3)
					LR2.C0 = clerp(LR2.C0,CFrame.new(-2.57038689, -0.933300614, -0.121713795, 0.265275717, -0.964172661, -1.28813554e-06, -0.964172781, -0.265275747, 5.76023012e-06, -5.89434057e-06, -2.8591603e-07, -1),0.3)
					LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390785, -0.272437274, -0.12138094, -1.29211003e-07, -1.00000012, 1.16415322e-10, -1.00000012, 1.36600647e-07, 4.00003046e-06, -4.00096178e-06, 0, -1),0.3)
					LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33202553, -0.23541078, -0.383358955, -1.29211003e-07, -1.00000012, 1.16415322e-10, -1.00000012, 1.36600647e-07, 4.00003046e-06, -4.00096178e-06, 0, -1),0.3)
					LM3.C0 = clerp(LM3.C0,CFrame.new(-2.50498247, -1.76070154, 0.0823208541, 0.556235969, -0.831024528, -2.17696652e-06, -0.831024587, -0.556235909, 9.77423042e-06, -9.33278352e-06, -3.62750143e-06, -1),0.3)
					LS3.C0 = clerp(LS3.C0,CFrame.new(-2.34636188, -1.67428231, -0.388740361, 0.556235969, -0.831024528, -2.17696652e-06, -0.831024587, -0.556235909, 9.77423042e-06, -9.33278352e-06, -3.62750143e-06, -1),0.3)
					LP2.C0 = clerp(LP2.C0,CFrame.new(-2.57174277, -0.928374887, 0.326284289, 0.265275717, -0.964172661, -1.28813554e-06, -0.964172781, -0.265275747, 5.76023012e-06, -5.89434057e-06, -2.8591603e-07, -1),0.3)
					LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32390833, -0.267327368, 0.326617122, -1.29211003e-07, -1.00000012, 1.16415322e-10, -1.00000012, 1.36600647e-07, 4.00003046e-06, -4.00096178e-06, 0, -1),0.3)
					LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32390881, -0.27002722, 0.0895336792, -1.29211003e-07, -1.00000012, 1.16415322e-10, -1.00000012, 1.36600647e-07, 4.00003046e-06, -4.00096178e-06, 0, -1),0.3)
					LS2.C0 = clerp(LS2.C0,CFrame.new(-2.48551011, -0.88594687, -0.38360405, 0.265275717, -0.964172661, -1.28813554e-06, -0.964172781, -0.265275747, 5.76023012e-06, -5.89434057e-06, -2.8591603e-07, -1),0.3)
					LM2.C0 = clerp(LM2.C0,CFrame.new(-2.57101965, -0.931007206, 0.0892008319, 0.265275717, -0.964172661, -1.28813554e-06, -0.964172781, -0.265275747, 5.76023012e-06, -5.89434057e-06, -2.8591603e-07, -1),0.3)
					LP3.C0 = clerp(LP3.C0,CFrame.new(-2.5064826, -1.75845838, 0.319396675, 0.556235969, -0.831024528, -2.17696652e-06, -0.831024587, -0.556235909, 9.77423042e-06, -9.33278352e-06, -3.62750143e-06, -1),0.3)
				end
			end
		end)

		-- Died event

		hum.Died:connect(function() -- When the player dies
			UnbindLoops() -- Unbind all of the loops used
		end)


		-- Everything else


		FindNearestTorso = function(pos)
			local list = (workspace:children())
			local torso = nil
			local dist = 1000
			local temp, human, temp2 = nil, nil, nil
			for x = 1, #list do
				temp2 = list[x]
				if temp2.className == "Model" and temp2 ~= char then
					temp = GetTorso(temp2)
					human = temp2:findFirstChildOfClass("Humanoid")
					if temp ~= nil and human ~= nil and human.Health > 0 and (temp.Position - pos).magnitude < dist then
						local dohit = true
						if dohit == true then
							torso = temp
							dist = (temp.Position - pos).magnitude
						end
					end
				end
			end
			return torso, dist
		end

		function Eat()
			Attack = true
			neutralAnims = false
			WalkSpeed = 0
			local hd = Instance.new("SpecialMesh",head)
			hd.MeshId,hd.Scale = "rbxasset://fonts/head.mesh",V3.N(1,1,1)
			for i = 0, 1, 0.1 do
				swait()
				root.Anchored = true
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0101976926, -2.47471642, -0.893443644, 0.999990284, -0.00300977356, -0.000401013531, 0.00300900009, 0.964597106, 0.263710856, -0.00040689297, -0.263709486, 0.964596748),0.3)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.498538464, -3.07820082, 1.32450998, 0.99999541, 0.00170646049, 0.00251151482, -0.00300980965, 0.66629684, 0.74568063, -0.000400940888, -0.745684743, 0.666298866),0.3)
				RH.C0 = clerp(RH.C0,CFrame.new(0.500001013, -1.22442114, -0.705207109, 1.00000012, 0, 0, 2.32830644e-10, 0.976968884, -0.213381797, 0, 0.213381797, 0.976968884),0.3)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.49999487, 0.499998093, 7.64429569e-06, 1.00000012, 2.32830644e-10, 0, 2.32830644e-10, 1, 2.98023224e-08, 0, 2.98023224e-08, 1),0.3)
				RS.C0 = clerp(RS.C0,CFrame.new(2.25000691, 1.27095723, -0.543794036, 0.70252949, -0.711654782, 1.53109431e-06, 0.366290569, 0.361591935, -0.857369542, 0.610150456, 0.602327943, 0.514701426),0.3)
				NK.C0 = clerp(NK.C0,CFrame.new(4.29084639e-06, 2.72478557, -0.152842045, 1.00000012, -4.65661287e-10, 9.31322575e-10, 2.32830644e-10, 0.962414801, 0.271584034, 0, -0.271584034, 0.962414801),0.3)
				RT3.C0 = clerp(RT3.C0,CFrame.new(-2.48910928, -1.55584359, 0.474784255, -0.552643597, -0.771626472, 0.314925104, 0.833417356, -0.511287332, 0.209764272, -0.000842422247, 0.378388971, 0.925646305),0.3)
				RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36365271, -0.0526320674, 0.463361204, 0.00431946665, -0.925634444, 0.378394425, 0.999990284, 0.00431928039, -0.000849217176, -0.000848323107, 0.378394485, 0.92564404),0.3)
				RT2.C0 = clerp(RT2.C0,CFrame.new(-2.57269263, -0.719203055, 0.46306473, -0.261112005, -0.893619657, 0.365054309, 0.96530813, -0.241389707, 0.0995550901, -0.000844031572, 0.378385007, 0.925647974),0.3)
				RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32387304, -0.097885251, 0.155142546, -1.07288361e-06, -1.00000012, 4.17232513e-06, 1.00000012, -1.10268593e-06, 3.54647636e-06, -3.51667404e-06, 4.2617321e-06, 1),0.3)
				RR2.C0 = clerp(RR2.C0,CFrame.new(-2.61666203, -0.764983475, 0.154808551, -0.265274137, -0.964173198, 2.41398811e-06, 0.964173079, -0.265274137, -5.96046448e-08, 7.15255737e-07, 2.29477882e-06, 1),0.3)
				RR3.C0 = clerp(RR3.C0,CFrame.new(-2.60072613, -1.61763632, 0.147929713, -0.556239188, -0.831022382, -3.81469727e-06, 0.831022322, -0.556239247, -9.4845891e-06, 5.75184822e-06, -8.43405724e-06, 1),0.3)
				RS3.C0 = clerp(RS3.C0,CFrame.new(-2.44672871, -1.52428532, 0.407729238, -0.556239188, -0.831022382, -3.81469727e-06, 0.831022322, -0.556239247, -9.4845891e-06, 5.75184822e-06, -8.43405724e-06, 1),0.3)
				RS2.C0 = clerp(RS2.C0,CFrame.new(-2.53335905, -0.71188271, 0.412876427, -0.265274137, -0.964173198, 2.41398811e-06, 0.964173079, -0.265274137, -5.96046448e-08, 7.15255737e-07, 2.29477882e-06, 1),0.3)
				RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33200312, -0.054913681, 0.413159013, -1.07288361e-06, -1.00000012, 4.17232513e-06, 1.00000012, -1.10268593e-06, 3.54647636e-06, -3.51667404e-06, 4.2617321e-06, 1),0.3)
				RM2.C0 = clerp(RM2.C0,CFrame.new(-2.61599159, -0.767508984, -0.074164845, -0.265274137, -0.964173198, 2.41398811e-06, 0.964173079, -0.265274137, -5.96046448e-08, 7.15255737e-07, 2.29477882e-06, 1),0.3)
				RM3.C0 = clerp(RM3.C0,CFrame.new(-2.59927201, -1.61979878, -0.0810761154, -0.556239188, -0.831022382, -3.81469727e-06, 0.831022322, -0.556239247, -9.4845891e-06, 5.75184822e-06, -8.43405724e-06, 1),0.3)
				RM1.C0 = clerp(RM1.C0,CFrame.new(-2.32387781, -0.100504853, -0.0738613531, -1.07288361e-06, -1.00000012, 4.17232513e-06, 1.00000012, -1.10268593e-06, 3.54647636e-06, -3.51667404e-06, 4.2617321e-06, 1),0.3)
				RP2.C0 = clerp(RP2.C0,CFrame.new(-2.61522508, -0.770296931, -0.32709071, -0.265274137, -0.964173198, 2.41398811e-06, 0.964173079, -0.265274137, -5.96046448e-08, 7.15255737e-07, 2.29477882e-06, 1),0.3)
				RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32390761, -0.103397295, -0.326749057, -1.07288361e-06, -1.00000012, 4.17232513e-06, 1.00000012, -1.10268593e-06, 3.54647636e-06, -3.51667404e-06, 4.2617321e-06, 1),0.3)
				RP3.C0 = clerp(RP3.C0,CFrame.new(-2.59765124, -1.62218916, -0.334011555, -0.556239188, -0.831022382, -3.81469727e-06, 0.831022322, -0.556239247, -9.4845891e-06, 5.75184822e-06, -8.43405724e-06, 1),0.3)
				LR3.C0 = clerp(LR3.C0,CFrame.new(-2.50362992, -1.76269734, -0.128634736, 0.556237459, -0.831023574, 4.00841236e-06, -0.831023574, -0.556237459, 1.33663416e-05, -8.86525959e-06, -1.07884407e-05, -1),0.3)
				LT3.C0 = clerp(LT3.C0,CFrame.new(-2.42464662, -1.68733966, -0.468871891, 0.559900582, -0.763834238, 0.321043193, -0.828559458, -0.516575158, 0.21596168, 0.000884024426, -0.386920452, -0.922112703),0.3)
				LT1.C0 = clerp(LT1.C0,CFrame.new(-2.38322973, -0.197773054, -0.480284244, 0.0044150874, -0.922103882, 0.386917174, -0.999989986, -0.00441437121, 0.000890459865, 0.000886899419, -0.386917293, -0.922114015),0.3)
				LT2.C0 = clerp(LT2.C0,CFrame.new(-2.55306935, -0.864338696, -0.480546713, 0.269532502, -0.887895465, 0.372818857, -0.96299094, -0.24887079, 0.103498176, 0.000888162293, -0.386917353, -0.922114015),0.3)
				LR2.C0 = clerp(LR2.C0,CFrame.new(-2.57037282, -0.933312833, -0.121727049, 0.265276462, -0.964172423, 6.33299351e-06, -0.964172423, -0.265276462, 3.02866101e-06, -1.24704093e-06, -6.91413879e-06, -1.00000012),0.3)
				LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390285, -0.272462189, -0.121371761, 1.28755346e-07, -1, 9.83476639e-07, -1.00000012, -1.28755346e-07, 4.12110239e-06, -4.12203372e-06, -9.53674316e-07, -1.00000012),0.3)
				LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33201838, -0.235411346, -0.383384138, 1.28755346e-07, -1, 9.83476639e-07, -1.00000012, -1.28755346e-07, 4.12110239e-06, -4.12203372e-06, -9.53674316e-07, -1.00000012),0.3)
				LM3.C0 = clerp(LM3.C0,CFrame.new(-2.50496888, -1.76070094, 0.0822837129, 0.556237459, -0.831023574, 4.00841236e-06, -0.831023574, -0.556237459, 1.33663416e-05, -8.86525959e-06, -1.07884407e-05, -1),0.3)
				LS3.C0 = clerp(LS3.C0,CFrame.new(-2.34634662, -1.67428362, -0.388776213, 0.556237459, -0.831023574, 4.00841236e-06, -0.831023574, -0.556237459, 1.33663416e-05, -8.86525959e-06, -1.07884407e-05, -1),0.3)
				LP2.C0 = clerp(LP2.C0,CFrame.new(-2.57173181, -0.928385198, 0.326259613, 0.265276462, -0.964172423, 6.33299351e-06, -0.964172423, -0.265276462, 3.02866101e-06, -1.24704093e-06, -6.91413879e-06, -1.00000012),0.3)
				LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32389855, -0.267353296, 0.326584399, 1.28755346e-07, -1, 9.83476639e-07, -1.00000012, -1.28755346e-07, 4.12110239e-06, -4.12203372e-06, -9.53674316e-07, -1.00000012),0.3)
				LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32390594, -0.27005741, 0.089539066, 1.28755346e-07, -1, 9.83476639e-07, -1.00000012, -1.28755346e-07, 4.12110239e-06, -4.12203372e-06, -9.53674316e-07, -1.00000012),0.3)
				LS2.C0 = clerp(LS2.C0,CFrame.new(-2.48550367, -0.885939538, -0.383639723, 0.265276462, -0.964172423, 6.33299351e-06, -0.964172423, -0.265276462, 3.02866101e-06, -1.24704093e-06, -6.91413879e-06, -1.00000012),0.3)
				LM2.C0 = clerp(LM2.C0,CFrame.new(-2.57101417, -0.930994511, 0.089172326, 0.265276462, -0.964172423, 6.33299351e-06, -0.964172423, -0.265276462, 3.02866101e-06, -1.24704093e-06, -6.91413879e-06, -1.00000012),0.3)
				LP3.C0 = clerp(LP3.C0,CFrame.new(-2.50647783, -1.75845778, 0.31936717, 0.556237459, -0.831023574, 4.00841236e-06, -0.831023574, -0.556237459, 1.33663416e-05, -8.86525959e-06, -1.07884407e-05, -1),0.3)
			end
			swait(30)
			for i = 0, 1, 0.1 do
				swait()
				root.Anchored = true
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0101976926, -2.47471642, -0.893443644, 0.999990284, -0.00300977356, -0.000401013531, 0.00300900009, 0.964597106, 0.263710856, -0.00040689297, -0.263709486, 0.964596748),0.3)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.498538464, -3.07820082, 1.32450998, 0.99999541, 0.00170646049, 0.00251151482, -0.00300980965, 0.66629684, 0.74568063, -0.000400940888, -0.745684743, 0.666298866),0.3)
				RH.C0 = clerp(RH.C0,CFrame.new(0.500001013, -1.22442114, -0.705207109, 1.00000012, 0, 0, 2.32830644e-10, 0.976968884, -0.213381797, 0, 0.213381797, 0.976968884),0.3)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.49999487, 0.499998093, 7.64429569e-06, 1.00000012, 2.32830644e-10, 0, 2.32830644e-10, 1, 2.98023224e-08, 0, 2.98023224e-08, 1),0.3)
				RS.C0 = clerp(RS.C0,CFrame.new(0.72810775, 1.02041888, -0.961069465, 0.768898249, 0.639371336, 1.03712082e-05, -0.329080999, 0.395761818, -0.857367218, -0.548179865, 0.659224689, 0.514705479),0.3)
				NK.C0 = clerp(NK.C0,CFrame.new(4.29084639e-06, 2.72478557, -0.152842045, 1.00000012, -4.65661287e-10, 9.31322575e-10, 2.32830644e-10, 0.962414801, 0.271584034, 0, -0.271584034, 0.962414801),0.3)
				RT3.C0 = clerp(RT3.C0,CFrame.new(-2.48910928, -1.55584586, 0.474794269, -0.552643836, -0.77162528, 0.314927697, 0.833417177, -0.511287987, 0.209763288, -0.000839859247, 0.378390521, 0.925645828),0.3)
				RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36366034, -0.0526347235, 0.46338138, 0.00431755185, -0.925634682, 0.378394067, 0.999990404, 0.00431737304, -0.00084900856, -0.00084772706, 0.378393948, 0.925644398),0.3)
				RT2.C0 = clerp(RT2.C0,CFrame.new(-2.57268977, -0.719206929, 0.463082612, -0.261111975, -0.893618345, 0.365057409, 0.96530813, -0.24138999, 0.0995542705, -0.000842303038, 0.37838769, 0.925646961),0.3)
				RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32388043, -0.0978889093, 0.155152023, -2.65240669e-06, -1.00000012, 4.29153442e-06, 1.00000012, -2.57790089e-06, 2.08616257e-06, -2.11596489e-06, 4.29153442e-06, 1.00000012),0.3)
				RR2.C0 = clerp(RR2.C0,CFrame.new(-2.61666441, -0.764981449, 0.154823169, -0.265272617, -0.964173615, 5.36441803e-06, 0.964173496, -0.265272617, 1.57952309e-06, -8.94069672e-08, 5.54323196e-06, 1.00000012),0.3)
				RR3.C0 = clerp(RR3.C0,CFrame.new(-2.60074186, -1.61763227, 0.147942692, -0.55623579, -0.831024587, -1.2665987e-06, 0.831024528, -0.55623585, -1.13844872e-05, 8.7916851e-06, -7.42077827e-06, 1.00000024),0.3)
				RS3.C0 = clerp(RS3.C0,CFrame.new(-2.44673991, -1.52428043, 0.407743961, -0.55623579, -0.831024587, -1.2665987e-06, 0.831024528, -0.55623585, -1.13844872e-05, 8.7916851e-06, -7.42077827e-06, 1.00000024),0.3)
				RS2.C0 = clerp(RS2.C0,CFrame.new(-2.5333724, -0.71187973, 0.412902206, -0.265272617, -0.964173615, 5.36441803e-06, 0.964173496, -0.265272617, 1.57952309e-06, -8.94069672e-08, 5.54323196e-06, 1.00000012),0.3)
				RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33201051, -0.0549177267, 0.413168609, -2.65240669e-06, -1.00000012, 4.29153442e-06, 1.00000012, -2.57790089e-06, 2.08616257e-06, -2.11596489e-06, 4.29153442e-06, 1.00000012),0.3)
				RM2.C0 = clerp(RM2.C0,CFrame.new(-2.61599779, -0.767502367, -0.0741483271, -0.265272617, -0.964173615, 5.36441803e-06, 0.964173496, -0.265272617, 1.57952309e-06, -8.94069672e-08, 5.54323196e-06, 1.00000012),0.3)
				RM3.C0 = clerp(RM3.C0,CFrame.new(-2.59928036, -1.61978889, -0.0810651034, -0.55623579, -0.831024587, -1.2665987e-06, 0.831024528, -0.55623585, -1.13844872e-05, 8.7916851e-06, -7.42077827e-06, 1.00000024),0.3)
				RM1.C0 = clerp(RM1.C0,CFrame.new(-2.3238852, -0.10051199, -0.0738480836, -2.65240669e-06, -1.00000012, 4.29153442e-06, 1.00000012, -2.57790089e-06, 2.08616257e-06, -2.11596489e-06, 4.29153442e-06, 1.00000012),0.3)
				RP2.C0 = clerp(RP2.C0,CFrame.new(-2.61523342, -0.770293057, -0.32707423, -0.265272617, -0.964173615, 5.36441803e-06, 0.964173496, -0.265272617, 1.57952309e-06, -8.94069672e-08, 5.54323196e-06, 1.00000012),0.3)
				RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32391119, -0.103400238, -0.326743454, -2.65240669e-06, -1.00000012, 4.29153442e-06, 1.00000012, -2.57790089e-06, 2.08616257e-06, -2.11596489e-06, 4.29153442e-06, 1.00000012),0.3)
				RP3.C0 = clerp(RP3.C0,CFrame.new(-2.59765935, -1.62217629, -0.334010154, -0.55623579, -0.831024587, -1.2665987e-06, 0.831024528, -0.55623585, -1.13844872e-05, 8.7916851e-06, -7.42077827e-06, 1.00000024),0.3)
				LR3.C0 = clerp(LR3.C0,CFrame.new(-2.50362992, -1.76269734, -0.128634736, 0.556237459, -0.831023574, 4.00841236e-06, -0.831023574, -0.556237459, 1.33663416e-05, -8.86525959e-06, -1.07884407e-05, -1),0.3)
				LT3.C0 = clerp(LT3.C0,CFrame.new(-2.42464662, -1.68733966, -0.468871891, 0.559900582, -0.763834238, 0.321043193, -0.828559458, -0.516575158, 0.21596168, 0.000884024426, -0.386920452, -0.922112703),0.3)
				LT1.C0 = clerp(LT1.C0,CFrame.new(-2.38322973, -0.197773054, -0.480284244, 0.0044150874, -0.922103882, 0.386917174, -0.999989986, -0.00441437121, 0.000890459865, 0.000886899419, -0.386917293, -0.922114015),0.3)
				LT2.C0 = clerp(LT2.C0,CFrame.new(-2.55306935, -0.864338696, -0.480546713, 0.269532502, -0.887895465, 0.372818857, -0.96299094, -0.24887079, 0.103498176, 0.000888162293, -0.386917353, -0.922114015),0.3)
				LR2.C0 = clerp(LR2.C0,CFrame.new(-2.57037282, -0.933312833, -0.121727049, 0.265276462, -0.964172423, 6.33299351e-06, -0.964172423, -0.265276462, 3.02866101e-06, -1.24704093e-06, -6.91413879e-06, -1.00000012),0.3)
				LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390285, -0.272462189, -0.121371761, 1.28755346e-07, -1, 9.83476639e-07, -1.00000012, -1.28755346e-07, 4.12110239e-06, -4.12203372e-06, -9.53674316e-07, -1.00000012),0.3)
				LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33201838, -0.235411346, -0.383384138, 1.28755346e-07, -1, 9.83476639e-07, -1.00000012, -1.28755346e-07, 4.12110239e-06, -4.12203372e-06, -9.53674316e-07, -1.00000012),0.3)
				LM3.C0 = clerp(LM3.C0,CFrame.new(-2.50496888, -1.76070094, 0.0822837129, 0.556237459, -0.831023574, 4.00841236e-06, -0.831023574, -0.556237459, 1.33663416e-05, -8.86525959e-06, -1.07884407e-05, -1),0.3)
				LS3.C0 = clerp(LS3.C0,CFrame.new(-2.34634662, -1.67428362, -0.388776213, 0.556237459, -0.831023574, 4.00841236e-06, -0.831023574, -0.556237459, 1.33663416e-05, -8.86525959e-06, -1.07884407e-05, -1),0.3)
				LP2.C0 = clerp(LP2.C0,CFrame.new(-2.57173181, -0.928385198, 0.326259613, 0.265276462, -0.964172423, 6.33299351e-06, -0.964172423, -0.265276462, 3.02866101e-06, -1.24704093e-06, -6.91413879e-06, -1.00000012),0.3)
				LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32389855, -0.267353296, 0.326584399, 1.28755346e-07, -1, 9.83476639e-07, -1.00000012, -1.28755346e-07, 4.12110239e-06, -4.12203372e-06, -9.53674316e-07, -1.00000012),0.3)
				LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32390594, -0.27005741, 0.089539066, 1.28755346e-07, -1, 9.83476639e-07, -1.00000012, -1.28755346e-07, 4.12110239e-06, -4.12203372e-06, -9.53674316e-07, -1.00000012),0.3)
				LS2.C0 = clerp(LS2.C0,CFrame.new(-2.48550367, -0.885939538, -0.383639723, 0.265276462, -0.964172423, 6.33299351e-06, -0.964172423, -0.265276462, 3.02866101e-06, -1.24704093e-06, -6.91413879e-06, -1.00000012),0.3)
				LM2.C0 = clerp(LM2.C0,CFrame.new(-2.57101417, -0.930994511, 0.089172326, 0.265276462, -0.964172423, 6.33299351e-06, -0.964172423, -0.265276462, 3.02866101e-06, -1.24704093e-06, -6.91413879e-06, -1.00000012),0.3)
				LP3.C0 = clerp(LP3.C0,CFrame.new(-2.50647783, -1.75845778, 0.31936717, 0.556237459, -0.831023574, 4.00841236e-06, -0.831023574, -0.556237459, 1.33663416e-05, -8.86525959e-06, -1.07884407e-05, -1),0.3)
			end
			local torso,dist = FindNearestTorso(torso.CFrame.p)
			local h = (torso and torso.Parent and torso.Parent:FindFirstChildOfClass'Humanoid' or nil)
			if(torso and dist <= 5 and h)then
				for _,v in next, torso.Parent:children() do
					if(v:IsA'BasePart')then
						v.CanCollide = false
						v.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
					end
				end
				-- grab sound
				FX(169380525,1,1,torso)
				h.PlatformStand = true
				for i = 0, 6, .1 do
					swait()
					torso.CFrame = rarm.CFrame * CF.N(0,-2.5,0)*CF.A(M.R(-90),0,0)
					h.PlatformStand = true
					root.Anchored = true
					RT3.C0 = clerp(RT3.C0,CFrame.new(1.61375785, -1.76555657, -0.513190091, -0.55665189, 0.810403109, 0.182717308, -0.771965683, -0.585860789, 0.24665007, 0.306932837, -0.00375326723, 0.951723814),Alpha)
					RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36366892, -0.0526333712, 0.463351786, 0.00432222337, -0.925635338, 0.378392518, 0.999990284, 0.00432161195, -0.000850837678, -0.000847693533, 0.378392458, 0.925644875),Alpha)
					RT2.C0 = clerp(RT2.C0,CFrame.new(1.2538718, -2.21410918, -0.524856687, -0.771987855, 0.583863854, 0.251272887, -0.556619704, -0.811843097, 0.176310748, 0.306935579, -0.00375370681, 0.95172298),Alpha)
					RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32391119, -0.0978909656, 0.155143276, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RR2.C0 = clerp(RR2.C0,CFrame.new(1.25468278, -2.23918462, 0.480947077, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RR3.C0 = clerp(RR3.C0,CFrame.new(1.53806043, -1.79355478, 0.474106222, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RS3.C0 = clerp(RS3.C0,CFrame.new(1.49055731, -1.77398741, 0.730609715, -0.660822511, 0.739318788, -0.129311174, -0.748390913, -0.662110388, 0.0389984399, -0.0567859784, 0.12254636, 0.990836978),Alpha)
					RS2.C0 = clerp(RS2.C0,CFrame.new(1.12350154, -2.19243288, 0.735727072, -0.863375664, 0.492343336, -0.110365942, -0.501357257, -0.861730874, 0.0778523907, -0.0567756221, 0.122548625, 0.990837216),Alpha)
					RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33202672, -0.0549109876, 0.413173437, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RM2.C0 = clerp(RM2.C0,CFrame.new(1.255373, -2.24170375, 0.251963019, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RM3.C0 = clerp(RM3.C0,CFrame.new(1.5395211, -1.79571998, 0.245096236, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RM1.C0 = clerp(RM1.C0,CFrame.new(-2.323915, -0.100503564, -0.0738568455, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP2.C0 = clerp(RP2.C0,CFrame.new(1.25615263, -2.2444911, -0.000960677862, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32391214, -0.103389643, -0.32676369, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP3.C0 = clerp(RP3.C0,CFrame.new(1.54112804, -1.79812348, -0.0077983737, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					LR3.C0 = clerp(LR3.C0,CFrame.new(1.45705879, -1.89598083, -0.385099679, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LT3.C0 = clerp(LT3.C0,CFrame.new(1.40952325, -1.97281897, 0.526059091, 0.671315253, 0.714624286, 0.196591273, 0.679187477, -0.699324131, 0.222823307, 0.296715915, -0.0160623491, -0.954830825),Alpha)
					LT1.C0 = clerp(LT1.C0,CFrame.new(-2.3832376, -0.197773144, -0.480284959, 0.00441737333, -0.922104299, 0.38691628, -0.999989927, -0.00441598753, 0.000892503187, 0.000885637477, -0.38691628, -0.922114491),Alpha)
					LT2.C0 = clerp(LT2.C0,CFrame.new(0.99463892, -2.34625196, 0.514375746, 0.851474643, 0.457154393, 0.256906241, 0.432377875, -0.889242351, 0.14932391, 0.296715945, -0.0160649493, -0.954830766),Alpha)
					LR2.C0 = clerp(LR2.C0,CFrame.new(1.14547455, -2.31078553, -0.378219754, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390952, -0.272462696, -0.121384747, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33202744, -0.23541376, -0.383374184, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM3.C0 = clerp(LM3.C0,CFrame.new(1.45572555, -1.89398086, -0.174214169, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LS3.C0 = clerp(LS3.C0,CFrame.new(1.49722528, -1.81738269, -0.636980891, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LP2.C0 = clerp(LP2.C0,CFrame.new(1.14411652, -2.30584955, 0.0697559863, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32390475, -0.267352402, 0.326590419, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32390952, -0.270056516, 0.0895184278, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS2.C0 = clerp(LS2.C0,CFrame.new(1.11611402, -2.23573709, -0.631830394, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LM2.C0 = clerp(LM2.C0,CFrame.new(1.14484239, -2.30846381, -0.167330459, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP3.C0 = clerp(LP3.C0,CFrame.new(1.45421648, -1.89172983, 0.0628871024, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
				end
				Tween(hd,{Scale=V3.N(2,2,2)},1,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out)
				for i = 0, 6, 0.1 do
					swait()
					torso.CFrame = rarm.CFrame * CF.N(0,-2.5,0)*CF.A(M.R(-90),0,0)
					h.PlatformStand = true
					root.Anchored = true
					RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0101976926, -2.47471642, -0.893443644, 0.999990284, -0.00300977356, -0.000401013531, 0.00300900009, 0.964597106, 0.263710856, -0.00040689297, -0.263709486, 0.964596748),0.3)
					LH.C0 = clerp(LH.C0,CFrame.new(-0.498538464, -3.07820082, 1.32450998, 0.99999541, 0.00170646049, 0.00251151482, -0.00300980965, 0.66629684, 0.74568063, -0.000400940888, -0.745684743, 0.666298866),0.3)
					RH.C0 = clerp(RH.C0,CFrame.new(0.500001013, -1.22442114, -0.705207109, 1.00000012, 0, 0, 2.32830644e-10, 0.976968884, -0.213381797, 0, 0.213381797, 0.976968884),0.3)
					LS.C0 = clerp(LS.C0,CFrame.new(-1.49999487, 0.499998093, 7.64429569e-06, 1.00000012, 2.32830644e-10, 0, 2.32830644e-10, 1, 2.98023224e-08, 0, 2.98023224e-08, 1),0.3)
					RS.C0 = clerp(RS.C0,CFrame.new(1.02310264, 1.39472663, 0.0915519893, 0.99869597, 0.0413880646, -0.0298938304, -0.0262705293, -0.0854785889, -0.995993614, -0.0437775292, 0.995480001, -0.0842798054),0.3)
					NK.C0 = clerp(NK.C0,CFrame.new(4.29084639e-06, 2.72478557, -0.152842045, 1.00000012, -4.65661287e-10, 9.31322575e-10, 2.32830644e-10, 0.962414801, 0.271584034, 0, -0.271584034, 0.962414801),0.3)
					RT3.C0 = clerp(RT3.C0,CFrame.new(1.61375785, -1.76555657, -0.513190091, -0.55665189, 0.810403109, 0.182717308, -0.771965683, -0.585860789, 0.24665007, 0.306932837, -0.00375326723, 0.951723814),Alpha)
					RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36366892, -0.0526333712, 0.463351786, 0.00432222337, -0.925635338, 0.378392518, 0.999990284, 0.00432161195, -0.000850837678, -0.000847693533, 0.378392458, 0.925644875),Alpha)
					RT2.C0 = clerp(RT2.C0,CFrame.new(1.2538718, -2.21410918, -0.524856687, -0.771987855, 0.583863854, 0.251272887, -0.556619704, -0.811843097, 0.176310748, 0.306935579, -0.00375370681, 0.95172298),Alpha)
					RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32391119, -0.0978909656, 0.155143276, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RR2.C0 = clerp(RR2.C0,CFrame.new(1.25468278, -2.23918462, 0.480947077, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RR3.C0 = clerp(RR3.C0,CFrame.new(1.53806043, -1.79355478, 0.474106222, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RS3.C0 = clerp(RS3.C0,CFrame.new(1.49055731, -1.77398741, 0.730609715, -0.660822511, 0.739318788, -0.129311174, -0.748390913, -0.662110388, 0.0389984399, -0.0567859784, 0.12254636, 0.990836978),Alpha)
					RS2.C0 = clerp(RS2.C0,CFrame.new(1.12350154, -2.19243288, 0.735727072, -0.863375664, 0.492343336, -0.110365942, -0.501357257, -0.861730874, 0.0778523907, -0.0567756221, 0.122548625, 0.990837216),Alpha)
					RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33202672, -0.0549109876, 0.413173437, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RM2.C0 = clerp(RM2.C0,CFrame.new(1.255373, -2.24170375, 0.251963019, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RM3.C0 = clerp(RM3.C0,CFrame.new(1.5395211, -1.79571998, 0.245096236, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RM1.C0 = clerp(RM1.C0,CFrame.new(-2.323915, -0.100503564, -0.0738568455, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP2.C0 = clerp(RP2.C0,CFrame.new(1.25615263, -2.2444911, -0.000960677862, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32391214, -0.103389643, -0.32676369, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP3.C0 = clerp(RP3.C0,CFrame.new(1.54112804, -1.79812348, -0.0077983737, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					LR3.C0 = clerp(LR3.C0,CFrame.new(1.45705879, -1.89598083, -0.385099679, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LT3.C0 = clerp(LT3.C0,CFrame.new(1.40952325, -1.97281897, 0.526059091, 0.671315253, 0.714624286, 0.196591273, 0.679187477, -0.699324131, 0.222823307, 0.296715915, -0.0160623491, -0.954830825),Alpha)
					LT1.C0 = clerp(LT1.C0,CFrame.new(-2.3832376, -0.197773144, -0.480284959, 0.00441737333, -0.922104299, 0.38691628, -0.999989927, -0.00441598753, 0.000892503187, 0.000885637477, -0.38691628, -0.922114491),Alpha)
					LT2.C0 = clerp(LT2.C0,CFrame.new(0.99463892, -2.34625196, 0.514375746, 0.851474643, 0.457154393, 0.256906241, 0.432377875, -0.889242351, 0.14932391, 0.296715945, -0.0160649493, -0.954830766),Alpha)
					LR2.C0 = clerp(LR2.C0,CFrame.new(1.14547455, -2.31078553, -0.378219754, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390952, -0.272462696, -0.121384747, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33202744, -0.23541376, -0.383374184, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM3.C0 = clerp(LM3.C0,CFrame.new(1.45572555, -1.89398086, -0.174214169, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LS3.C0 = clerp(LS3.C0,CFrame.new(1.49722528, -1.81738269, -0.636980891, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LP2.C0 = clerp(LP2.C0,CFrame.new(1.14411652, -2.30584955, 0.0697559863, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32390475, -0.267352402, 0.326590419, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32390952, -0.270056516, 0.0895184278, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS2.C0 = clerp(LS2.C0,CFrame.new(1.11611402, -2.23573709, -0.631830394, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LM2.C0 = clerp(LM2.C0,CFrame.new(1.14484239, -2.30846381, -0.167330459, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP3.C0 = clerp(LP3.C0,CFrame.new(1.45421648, -1.89172983, 0.0628871024, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
				end
				for i = 0, 3, 0.1 do
					swait()
					torso.CFrame = rarm.CFrame * CF.N(0,-2.5,0)*CF.A(M.R(-65),0,0)
					h.PlatformStand = true
					root.Anchored = true
					RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0101976926, -2.47471642, -0.893443644, 0.999990284, -0.00300977356, -0.000401013531, 0.00300900009, 0.964597106, 0.263710856, -0.00040689297, -0.263709486, 0.964596748),0.3)
					LH.C0 = clerp(LH.C0,CFrame.new(-0.498538464, -3.07820082, 1.32450998, 0.99999541, 0.00170646049, 0.00251151482, -0.00300980965, 0.66629684, 0.74568063, -0.000400940888, -0.745684743, 0.666298866),0.3)
					RH.C0 = clerp(RH.C0,CFrame.new(0.500001013, -1.22442114, -0.705207109, 1.00000012, 0, 0, 2.32830644e-10, 0.976968884, -0.213381797, 0, 0.213381797, 0.976968884),0.3)
					LS.C0 = clerp(LS.C0,CFrame.new(-1.49999487, 0.499998093, 7.64429569e-06, 1.00000012, 2.32830644e-10, 0, 2.32830644e-10, 1, 2.98023224e-08, 0, 2.98023224e-08, 1),0.3)
					RS.C0 = clerp(RS.C0,CFrame.new(1.60629869, -0.170540944, -0.141343355, 0.893960059, 0.446698248, 0.0360007249, 0.387383848, -0.729863763, -0.563234091, -0.225320011, 0.517454803, -0.825512767),0.3)
					NK.C0 = clerp(NK.C0,CFrame.new(4.29084639e-06, 2.72478557, -0.152842045, 1.00000012, -4.65661287e-10, 9.31322575e-10, 2.32830644e-10, 0.962414801, 0.271584034, 0, -0.271584034, 0.962414801),0.3)
					RT3.C0 = clerp(RT3.C0,CFrame.new(1.61375785, -1.76555657, -0.513190091, -0.55665189, 0.810403109, 0.182717308, -0.771965683, -0.585860789, 0.24665007, 0.306932837, -0.00375326723, 0.951723814),Alpha)
					RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36366892, -0.0526333712, 0.463351786, 0.00432222337, -0.925635338, 0.378392518, 0.999990284, 0.00432161195, -0.000850837678, -0.000847693533, 0.378392458, 0.925644875),Alpha)
					RT2.C0 = clerp(RT2.C0,CFrame.new(1.2538718, -2.21410918, -0.524856687, -0.771987855, 0.583863854, 0.251272887, -0.556619704, -0.811843097, 0.176310748, 0.306935579, -0.00375370681, 0.95172298),Alpha)
					RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32391119, -0.0978909656, 0.155143276, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RR2.C0 = clerp(RR2.C0,CFrame.new(1.25468278, -2.23918462, 0.480947077, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RR3.C0 = clerp(RR3.C0,CFrame.new(1.53806043, -1.79355478, 0.474106222, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RS3.C0 = clerp(RS3.C0,CFrame.new(1.49055731, -1.77398741, 0.730609715, -0.660822511, 0.739318788, -0.129311174, -0.748390913, -0.662110388, 0.0389984399, -0.0567859784, 0.12254636, 0.990836978),Alpha)
					RS2.C0 = clerp(RS2.C0,CFrame.new(1.12350154, -2.19243288, 0.735727072, -0.863375664, 0.492343336, -0.110365942, -0.501357257, -0.861730874, 0.0778523907, -0.0567756221, 0.122548625, 0.990837216),Alpha)
					RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33202672, -0.0549109876, 0.413173437, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RM2.C0 = clerp(RM2.C0,CFrame.new(1.255373, -2.24170375, 0.251963019, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RM3.C0 = clerp(RM3.C0,CFrame.new(1.5395211, -1.79571998, 0.245096236, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RM1.C0 = clerp(RM1.C0,CFrame.new(-2.323915, -0.100503564, -0.0738568455, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP2.C0 = clerp(RP2.C0,CFrame.new(1.25615263, -2.2444911, -0.000960677862, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32391214, -0.103389643, -0.32676369, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP3.C0 = clerp(RP3.C0,CFrame.new(1.54112804, -1.79812348, -0.0077983737, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					LR3.C0 = clerp(LR3.C0,CFrame.new(1.45705879, -1.89598083, -0.385099679, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LT3.C0 = clerp(LT3.C0,CFrame.new(1.40952325, -1.97281897, 0.526059091, 0.671315253, 0.714624286, 0.196591273, 0.679187477, -0.699324131, 0.222823307, 0.296715915, -0.0160623491, -0.954830825),Alpha)
					LT1.C0 = clerp(LT1.C0,CFrame.new(-2.3832376, -0.197773144, -0.480284959, 0.00441737333, -0.922104299, 0.38691628, -0.999989927, -0.00441598753, 0.000892503187, 0.000885637477, -0.38691628, -0.922114491),Alpha)
					LT2.C0 = clerp(LT2.C0,CFrame.new(0.99463892, -2.34625196, 0.514375746, 0.851474643, 0.457154393, 0.256906241, 0.432377875, -0.889242351, 0.14932391, 0.296715945, -0.0160649493, -0.954830766),Alpha)
					LR2.C0 = clerp(LR2.C0,CFrame.new(1.14547455, -2.31078553, -0.378219754, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390952, -0.272462696, -0.121384747, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33202744, -0.23541376, -0.383374184, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM3.C0 = clerp(LM3.C0,CFrame.new(1.45572555, -1.89398086, -0.174214169, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LS3.C0 = clerp(LS3.C0,CFrame.new(1.49722528, -1.81738269, -0.636980891, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LP2.C0 = clerp(LP2.C0,CFrame.new(1.14411652, -2.30584955, 0.0697559863, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32390475, -0.267352402, 0.326590419, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32390952, -0.270056516, 0.0895184278, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS2.C0 = clerp(LS2.C0,CFrame.new(1.11611402, -2.23573709, -0.631830394, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LM2.C0 = clerp(LM2.C0,CFrame.new(1.14484239, -2.30846381, -0.167330459, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP3.C0 = clerp(LP3.C0,CFrame.new(1.45421648, -1.89172983, 0.0628871024, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
				end
				-- thanks shuggy
				local bloodie = Instance.new("Part",char)
				bloodie.Transparency = 1
				bloodie.Size = V3.N(1,1,1)
				local bloodieW = Instance.new("Weld",bloodie)
				bloodieW.Part0 = head
				bloodieW.Part1 = bloodie
				bloodieW.C0 = CF.N(0,-.5,-1)
				local p1mit = Instance.new("ParticleEmitter",bloodie)
				p1mit.Texture = "rbxasset://textures/particles/fire_main.dds"
				p1mit.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(.6,0,0)),ColorSequenceKeypoint.new(1,Color3.new(.6,0,0))})
				p1mit.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(1,0)})
				p1mit.Lifetime = NumberRange.new(6)
				p1mit.Rate = 100
				p1mit.Enabled = true
				p1mit.Acceleration = Vector3.new(0,-10,0)
				p1mit.Rotation = NumberRange.new(0,359)
				p1mit.Speed = NumberRange.new(0)
				delay(5, function()
					p1mit.Enabled = false
				end)
				game:service'Debris':AddItem(p1mit,10)
				FX(429400881,1,1,head)
				if(torso and torso.Parent and torso.Parent:FindFirstChild'Head')then
					torso.Parent.Head:destroy()
				end
			end
			swait(30)
			Tween(hd,{Scale=V3.N(1,1,1)},1,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out)
			swait(60)
			hd:Destroy()
			root.Anchored = false
			WalkSpeed = 8
			neutralAnims = true
			Attack = false
		end
		function getRegion(point,range,ignore)
			return workspace:FindPartsInRegion3WithIgnoreList(Region3.new(point-Vector3.new(1,1,1)*range/2,point+Vector3.new(1,1,1)*range/2),ignore,100)
		end

		function Tween(obj,props,time,easing,direction,repeats,backwards)
			local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
			local tween = S.TweenService:Create(obj, info, props)

			tween:Play()
		end

		function Stomp()
			Attack = true
			neutralAnims = false
			WalkSpeed = 0
			for i = 0, 1, 0.1 do
				swait()
				RJ.C0 = clerp(RJ.C0,CFrame.new(0.0149606867, -0.414370447, 1.31077337, 0.999976575, 0.00583649054, -0.00160982274, -0.00583899952, 0.859376848, -0.511309505, -0.00160080846, 0.511306942, 0.859390676),0.3)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.494830847, -3.32493114, 0.452066779, 0.999976575, -0.00583899952, -0.00160080846, 0.00583649054, 0.859376848, 0.511306942, -0.00160982274, -0.511309505, 0.859390676),0.3)
				RH.C0 = clerp(RH.C0,CFrame.new(0.499999106, -1.56153071, -0.998121262, 1.00000012, -8.76025297e-08, -9.95583832e-07, 5.10830432e-07, 0.900910258, 0.434005529, 8.58679414e-07, -0.434005469, 0.900910199),0.3)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.8556273, 2.15271449, 0.597766876, 0.928429008, 0.371509999, 1.45630911e-05, 0.313250482, -0.782855511, 0.537597895, 0.19973436, -0.499116778, -0.843201399),0.3)
				RS.C0 = clerp(RS.C0,CFrame.new(1.94845712, 2.27057123, 0.356615961, 0.893861949, -0.448342502, -6.85127452e-06, -0.394066334, -0.785658598, 0.476919919, -0.213828832, -0.426297784, -0.878946781),0.3)
				NK.C0 = clerp(NK.C0,CFrame.new(-9.5367443e-07, 2.74997544, 7.62939408e-06, 1.00000012, 0, 0, 0, 1.00000012, 0, 0, 0, 0.99999994),0.3)
				RT3.C0 = clerp(RT3.C0,CFrame.new(-2.48913026, -1.5558573, 0.474763274, -0.552640617, -0.771631122, 0.314919144, 0.833419323, -0.51128757, 0.209755421, -0.000839561224, 0.378379047, 0.925650477),0.3)
				RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36367607, -0.0526439659, 0.463351578, 0.00431717932, -0.925637841, 0.378385901, 0.999990463, 0.00431641936, -0.00085029006, -0.000846236944, 0.378386021, 0.925647676),0.3)
				RT2.C0 = clerp(RT2.C0,CFrame.new(-2.57271957, -0.719195843, 0.463060319, -0.261100143, -0.893624783, 0.365050167, 0.965311408, -0.241380781, 0.0995453894, -0.000840097666, 0.378378451, 0.925650716),0.3)
				RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32391405, -0.0978988633, 0.155138284, 7.15255737e-07, -1, -3.06963921e-06, 1, 7.15255737e-07, -8.7916851e-07, 8.49366188e-07, -3.12924385e-06, 1),0.3)
				RR2.C0 = clerp(RR2.C0,CFrame.new(-2.61670589, -0.764987886, 0.154807672, -0.265270501, -0.964174151, -4.08291817e-06, 0.964174092, -0.265270472, -8.85874033e-06, 7.4505806e-06, -6.31809235e-06, 1),0.3)
				RR3.C0 = clerp(RR3.C0,CFrame.new(-2.60071802, -1.61763024, 0.147904918, -0.556236863, -0.831023872, -1.04308128e-06, 0.831023991, -0.556236804, -1.44280493e-05, 1.13844872e-05, -8.94069672e-06, 1.00000012),0.3)
				RS3.C0 = clerp(RS3.C0,CFrame.new(-2.44675589, -1.52430558, 0.40774554, -0.556236863, -0.831023872, -1.04308128e-06, 0.831023991, -0.556236804, -1.44280493e-05, 1.13844872e-05, -8.94069672e-06, 1.00000012),0.3)
				RS2.C0 = clerp(RS2.C0,CFrame.new(-2.53338361, -0.711885929, 0.412868947, -0.265270501, -0.964174151, -4.08291817e-06, 0.964174092, -0.265270472, -8.85874033e-06, 7.4505806e-06, -6.31809235e-06, 1),0.3)
				RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33204389, -0.0549074486, 0.413162529, 7.15255737e-07, -1, -3.06963921e-06, 1, 7.15255737e-07, -8.7916851e-07, 8.49366188e-07, -3.12924385e-06, 1),0.3)
				RM2.C0 = clerp(RM2.C0,CFrame.new(-2.61601782, -0.767512858, -0.074173376, -0.265270501, -0.964174151, -4.08291817e-06, 0.964174092, -0.265270472, -8.85874033e-06, 7.4505806e-06, -6.31809235e-06, 1),0.3)
				RM3.C0 = clerp(RM3.C0,CFrame.new(-2.59928656, -1.61981332, -0.0810437351, -0.556236863, -0.831023872, -1.04308128e-06, 0.831023991, -0.556236804, -1.44280493e-05, 1.13844872e-05, -8.94069672e-06, 1.00000012),0.3)
				RM1.C0 = clerp(RM1.C0,CFrame.new(-2.32391715, -0.100507915, -0.0738599002, 7.15255737e-07, -1, -3.06963921e-06, 1, 7.15255737e-07, -8.7916851e-07, 8.49366188e-07, -3.12924385e-06, 1),0.3)
				RP2.C0 = clerp(RP2.C0,CFrame.new(-2.61523223, -0.770289779, -0.327118337, -0.265270501, -0.964174151, -4.08291817e-06, 0.964174092, -0.265270472, -8.85874033e-06, 7.4505806e-06, -6.31809235e-06, 1),0.3)
				RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32391644, -0.103391603, -0.326751441, 7.15255737e-07, -1, -3.06963921e-06, 1, 7.15255737e-07, -8.7916851e-07, 8.49366188e-07, -3.12924385e-06, 1),0.3)
				RP3.C0 = clerp(RP3.C0,CFrame.new(-2.59768414, -1.62221014, -0.333992541, -0.556236863, -0.831023872, -1.04308128e-06, 0.831023991, -0.556236804, -1.44280493e-05, 1.13844872e-05, -8.94069672e-06, 1.00000012),0.3)
				LR3.C0 = clerp(LR3.C0,CFrame.new(-2.50364661, -1.76271212, -0.128631443, 0.556247711, -0.831016541, 2.47359276e-06, -0.83101666, -0.556247711, 9.41753387e-06, -6.46710396e-06, -7.27176666e-06, -1.00000012),0.3)
				LT3.C0 = clerp(LT3.C0,CFrame.new(-2.42465901, -1.68734121, -0.468866467, 0.559909225, -0.763830543, 0.321036994, -0.828553557, -0.516581178, 0.215969831, 0.000877350569, -0.386919856, -0.922112942),0.3)
				LT1.C0 = clerp(LT1.C0,CFrame.new(-2.38323689, -0.197773248, -0.480273008, 0.00442521274, -0.922103941, 0.386916906, -0.999989986, -0.00442284346, 0.000896409154, 0.00088468194, -0.386916965, -0.922114134),0.3)
				LT2.C0 = clerp(LT2.C0,CFrame.new(-2.55306888, -0.864331484, -0.480577469, 0.26954022, -0.887892246, 0.372820735, -0.962988675, -0.248876914, 0.103503615, 0.000886380672, -0.386920631, -0.922112584),0.3)
				LR2.C0 = clerp(LR2.C0,CFrame.new(-2.57039857, -0.933297694, -0.121736571, 0.265281469, -0.964171052, 5.78165054e-06, -0.964171052, -0.265281498, 9.72300768e-06, -7.85291195e-06, -8.13603401e-06, -1),0.3)
				LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390261, -0.272461981, -0.121395558, 1.0818243e-05, -1.00000012, 5.00679016e-06, -1, -1.08480453e-05, -1.3038516e-05, 1.3038516e-05, -5.00679016e-06, -0.99999994),0.3)
				LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33204222, -0.235423818, -0.383398056, 1.0818243e-05, -1.00000012, 5.00679016e-06, -1, -1.08480453e-05, -1.3038516e-05, 1.3038516e-05, -5.00679016e-06, -0.99999994),0.3)
				LM3.C0 = clerp(LM3.C0,CFrame.new(-2.50498033, -1.76070869, 0.082287021, 0.556247711, -0.831016541, 2.47359276e-06, -0.83101666, -0.556247711, 9.41753387e-06, -6.46710396e-06, -7.27176666e-06, -1.00000012),0.3)
				LS3.C0 = clerp(LS3.C0,CFrame.new(-2.34634924, -1.67430735, -0.388748765, 0.556247711, -0.831016541, 2.47359276e-06, -0.83101666, -0.556247711, 9.41753387e-06, -6.46710396e-06, -7.27176666e-06, -1.00000012),0.3)
				LP2.C0 = clerp(LP2.C0,CFrame.new(-2.57174945, -0.928372383, 0.32624054, 0.265281469, -0.964171052, 5.78165054e-06, -0.964171052, -0.265281498, 9.72300768e-06, -7.85291195e-06, -8.13603401e-06, -1),0.3)
				LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32390499, -0.267353982, 0.326602399, 1.0818243e-05, -1.00000012, 5.00679016e-06, -1, -1.08480453e-05, -1.3038516e-05, 1.3038516e-05, -5.00679016e-06, -0.99999994),0.3)
				LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32391906, -0.270055026, 0.0895333141, 1.0818243e-05, -1.00000012, 5.00679016e-06, -1, -1.08480453e-05, -1.3038516e-05, 1.3038516e-05, -5.00679016e-06, -0.99999994),0.3)
				LS2.C0 = clerp(LS2.C0,CFrame.new(-2.48551512, -0.885928094, -0.383646071, 0.265281469, -0.964171052, 5.78165054e-06, -0.964171052, -0.265281498, 9.72300768e-06, -7.85291195e-06, -8.13603401e-06, -1),0.3)
				LM2.C0 = clerp(LM2.C0,CFrame.new(-2.57103992, -0.930986404, 0.0891713798, 0.265281469, -0.964171052, 5.78165054e-06, -0.964171052, -0.265281498, 9.72300768e-06, -7.85291195e-06, -8.13603401e-06, -1),0.3)
				LP3.C0 = clerp(LP3.C0,CFrame.new(-2.50646663, -1.75845659, 0.31939435, 0.556247711, -0.831016541, 2.47359276e-06, -0.83101666, -0.556247711, 9.41753387e-06, -6.46710396e-06, -7.27176666e-06, -1.00000012),0.3)
			end
			swait(30)
			local RL = Instance.new("SpecialMesh",rleg)
			RL.MeshId,RL.Scale = "rbxasset://fonts/rightleg.mesh",V3.N(1,PlayerSize,1)
			Tween(RL,{Scale=V3.N(2,PlayerSize,1)},.6,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out)
			swait(36)
			Tween(RL,{Scale=V3.N(2,PlayerSize,2)},.6,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out)
			swait(36)
			for i = 0, .9, 0.1 do
				swait()
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0108745974, -1.25186658, -0.952733994, 0.999976397, -0.00586278876, -0.00162208173, 0.00586399902, 0.85814631, 0.513371766, -0.00161780789, -0.513369143, 0.858160377),0.3)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.503836155, -2.41545725, -0.335738778, 0.999976397, 0.00586399902, -0.00161780789, -0.00586278876, 0.85814631, -0.513369143, -0.00162208173, 0.513371766, 0.858160377),0.3)
				RH.C0 = clerp(RH.C0,CFrame.new(1.43907547, -2.20140982, -1.52517509, 0.999931633, 0.0116824051, 0.00069081597, -0.0100521259, 0.887619972, -0.460467011, -0.00599254388, 0.460428506, 0.887676656),0.3)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.14841616, 0.652297139, -1.08734488, 0.972524107, -0.226930693, -0.0519557931, 0.120456055, 0.681488216, -0.721847832, 0.199216664, 0.695755959, 0.690098882),0.3)
				RS.C0 = clerp(RS.C0,CFrame.new(0.878460109, 0.664811909, -1.09500289, 0.940693557, 0.327670962, -0.0879075155, -0.289187342, 0.638985872, -0.712788701, -0.177388534, 0.695937455, 0.695847988),0.3)
				NK.C0 = clerp(NK.C0,CFrame.new(1.00135803e-05, 2.74997139, 1.90734863e-05, 1, 0, 0, 0, 1, 0, 0, 0, 1),0.3)
				RT3.C0 = clerp(RT3.C0,CFrame.new(-2.48911357, -1.55585802, 0.474724293, -0.552640557, -0.77163136, 0.314918667, 0.833419502, -0.511288702, 0.209752262, -0.000837064814, 0.378376961, 0.925651312),0.3)
				RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36363268, -0.052654691, 0.463338047, 0.0043214038, -0.925638735, 0.378383785, 0.999990404, 0.00432076212, -0.000850709621, -0.000847461633, 0.378383875, 0.925648451),0.3)
				RT2.C0 = clerp(RT2.C0,CFrame.new(-2.57269716, -0.71919471, 0.46302259, -0.261101305, -0.893626034, 0.365046114, 0.96531117, -0.241381153, 0.0995475352, -0.000843007583, 0.378375083, 0.925651968),0.3)
				RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32388234, -0.0979054198, 0.155136421, 2.57161446e-06, -1, -2.98023224e-08, 1.00000012, 2.55089253e-06, 3.23494896e-06, -3.25404108e-06, 0, 1),0.3)
				RR2.C0 = clerp(RR2.C0,CFrame.new(-2.61665893, -0.764993608, 0.154808521, -0.265272409, -0.964173555, -7.09295273e-06, 0.964173615, -0.265272349, -5.17070293e-06, 3.08873132e-06, -8.16583633e-06, 0.99999994),0.3)
				RR3.C0 = clerp(RR3.C0,CFrame.new(-2.60069489, -1.61760163, 0.14783819, -0.55623138, -0.831027687, -6.09457493e-06, 0.831027627, -0.55623126, -2.35140324e-05, 1.61430798e-05, -1.8119812e-05, 1),0.3)
				RS3.C0 = clerp(RS3.C0,CFrame.new(-2.44674897, -1.52429092, 0.407717556, -0.55623138, -0.831027687, -6.09457493e-06, 0.831027627, -0.55623126, -2.35140324e-05, 1.61430798e-05, -1.8119812e-05, 1),0.3)
				RS2.C0 = clerp(RS2.C0,CFrame.new(-2.53335404, -0.711890757, 0.412843108, -0.265272409, -0.964173555, -7.09295273e-06, 0.964173615, -0.265272349, -5.17070293e-06, 3.08873132e-06, -8.16583633e-06, 0.99999994),0.3)
				RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33201814, -0.0549086258, 0.41316241, 2.57161446e-06, -1, -2.98023224e-08, 1.00000012, 2.55089253e-06, 3.23494896e-06, -3.25404108e-06, 0, 1),0.3)
				RM2.C0 = clerp(RM2.C0,CFrame.new(-2.61599565, -0.767519593, -0.0742144436, -0.265272409, -0.964173555, -7.09295273e-06, 0.964173615, -0.265272349, -5.17070293e-06, 3.08873132e-06, -8.16583633e-06, 0.99999994),0.3)
				RM3.C0 = clerp(RM3.C0,CFrame.new(-2.59925842, -1.61979342, -0.0811047256, -0.55623138, -0.831027687, -6.09457493e-06, 0.831027627, -0.55623126, -2.35140324e-05, 1.61430798e-05, -1.8119812e-05, 1),0.3)
				RM1.C0 = clerp(RM1.C0,CFrame.new(-2.32389092, -0.100519225, -0.0738827288, 2.57161446e-06, -1, -2.98023224e-08, 1.00000012, 2.55089253e-06, 3.23494896e-06, -3.25404108e-06, 0, 1),0.3)
				RP2.C0 = clerp(RP2.C0,CFrame.new(-2.61518931, -0.770304918, -0.327144116, -0.265272409, -0.964173555, -7.09295273e-06, 0.964173615, -0.265272349, -5.17070293e-06, 3.08873132e-06, -8.16583633e-06, 0.99999994),0.3)
				RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32388139, -0.103401095, -0.326785713, 2.57161446e-06, -1, -2.98023224e-08, 1.00000012, 2.55089253e-06, 3.23494896e-06, -3.25404108e-06, 0, 1),0.3)
				RP3.C0 = clerp(RP3.C0,CFrame.new(-2.59765077, -1.62217653, -0.334061176, -0.55623138, -0.831027687, -6.09457493e-06, 0.831027627, -0.55623126, -2.35140324e-05, 1.61430798e-05, -1.8119812e-05, 1),0.3)
				LR3.C0 = clerp(LR3.C0,CFrame.new(-2.50362754, -1.76269495, -0.128636867, 0.556252837, -0.831013322, 6.51180744e-06, -0.831013143, -0.556252837, -4.09781933e-06, 7.01844692e-06, -3.12924385e-06, -1.00000012),0.3)
				LT3.C0 = clerp(LT3.C0,CFrame.new(-2.42464495, -1.68732333, -0.468877375, 0.559906721, -0.76382637, 0.3210513, -0.828555167, -0.516583681, 0.215957373, 0.000895902514, -0.386924744, -0.922111094),0.3)
				LT1.C0 = clerp(LT1.C0,CFrame.new(-2.38321137, -0.197761506, -0.480284184, 0.00442438386, -0.922103286, 0.386918634, -0.999989927, -0.00442464277, 0.000890053809, 0.000891245902, -0.386918634, -0.922113538),0.3)
				LT2.C0 = clerp(LT2.C0,CFrame.new(-2.55305004, -0.864332676, -0.480571091, 0.269542992, -0.887895226, 0.372812331, -0.962987959, -0.248886049, 0.103488967, 0.000900432467, -0.386908501, -0.922117829),0.3)
				LR2.C0 = clerp(LR2.C0,CFrame.new(-2.57040381, -0.933295071, -0.121735282, 0.265284121, -0.964170456, -7.30156898e-07, -0.964170277, -0.265284151, 2.69711018e-06, -2.79396772e-06, -1.49011612e-08, -1.00000012),0.3)
				LR1.C0 = clerp(LR1.C0,CFrame.new(-2.3238914, -0.272474736, -0.121387586, 1.98073685e-05, -1, 3.84449959e-06, -1.00000012, -1.98241323e-05, -3.2402575e-05, 3.2402575e-05, -3.84449959e-06, -1),0.3)
				LS1.C0 = clerp(LS1.C0,CFrame.new(-2.332026, -0.235441238, -0.383450896, 1.98073685e-05, -1, 3.84449959e-06, -1.00000012, -1.98241323e-05, -3.2402575e-05, 3.2402575e-05, -3.84449959e-06, -1),0.3)
				LM3.C0 = clerp(LM3.C0,CFrame.new(-2.50494647, -1.76068807, 0.0822853819, 0.556252837, -0.831013322, 6.51180744e-06, -0.831013143, -0.556252837, -4.09781933e-06, 7.01844692e-06, -3.12924385e-06, -1.00000012),0.3)
				LS3.C0 = clerp(LS3.C0,CFrame.new(-2.3463347, -1.67428887, -0.388733745, 0.556252837, -0.831013322, 6.51180744e-06, -0.831013143, -0.556252837, -4.09781933e-06, 7.01844692e-06, -3.12924385e-06, -1.00000012),0.3)
				LP2.C0 = clerp(LP2.C0,CFrame.new(-2.57173133, -0.928351641, 0.326236129, 0.265284121, -0.964170456, -7.30156898e-07, -0.964170277, -0.265284151, 2.69711018e-06, -2.79396772e-06, -1.49011612e-08, -1.00000012),0.3)
				LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32387996, -0.267357588, 0.326587409, 1.98073685e-05, -1, 3.84449959e-06, -1.00000012, -1.98241323e-05, -3.2402575e-05, 3.2402575e-05, -3.84449959e-06, -1),0.3)
				LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32389045, -0.270063698, 0.089538388, 1.98073685e-05, -1, 3.84449959e-06, -1.00000012, -1.98241323e-05, -3.2402575e-05, 3.2402575e-05, -3.84449959e-06, -1),0.3)
				LS2.C0 = clerp(LS2.C0,CFrame.new(-2.48548055, -0.885903299, -0.383629501, 0.265284121, -0.964170456, -7.30156898e-07, -0.964170277, -0.265284151, 2.69711018e-06, -2.79396772e-06, -1.49011612e-08, -1.00000012),0.3)
				LM2.C0 = clerp(LM2.C0,CFrame.new(-2.57099605, -0.93097049, 0.0891641006, 0.265284121, -0.964170456, -7.30156898e-07, -0.964170277, -0.265284151, 2.69711018e-06, -2.79396772e-06, -1.49011612e-08, -1.00000012),0.3)
				LP3.C0 = clerp(LP3.C0,CFrame.new(-2.50646234, -1.75844562, 0.319372624, 0.556252837, -0.831013322, 6.51180744e-06, -0.831013143, -0.556252837, -4.09781933e-06, 7.01844692e-06, -3.12924385e-06, -1.00000012),0.3)
			end
			BlastFX(30,BrickColor.new'Light stone grey',V3.N(2,PlayerSize,2),rleg.CFrame*CF.N(0,-2,0),V3.N(10,1,10))
			local hit = getRegion(torso.CFrame.p,15,{char})
			for _,v in next, hit do
				if(v.Parent and v.Parent:FindFirstChildOfClass'Humanoid')then
					DealDamage(v.Parent,15,30,1,"Normal")
				end
			end
			local n = 180
			for i = 1, n do
				coroutine.wrap(function()
					local cf = lleg.CFrame * CF.N(0,-2,0) * CF.A(0,M.P*2/n*i,0)*CF.N(0,0,10)
					local hitfloor,posfloor = workspace:FindPartOnRay(Ray.new(cf.p,((CFrame.new(cf.p,cf.p - Vector3.new(0,1,0))).lookVector).unit * 4), char)
					if(hitfloor)then
						local block = NewInstance("Part",workspace,{CanCollide=false,Anchored=false,CFrame=cf*CF.N(0,1,0),BrickColor = hitfloor.BrickColor,Transparency=hitfloor.Transparency,Reflectance=hitfloor.Reflectance,Material=hitfloor.Material,Size=V3.N(2+M.RNG(-25,75)/100,2+M.RNG(-25,75)/100,2+M.RNG(-25,75)/100)})
						local velocity = NewInstance("BodyVelocity",block,{P=500,maxForce=V3.N(M.H,M.H,M.H),velocity=V3.N(M.RNG(-10,10),M.RNG(5,10),M.RNG(-10,10))})
						swait(15)
						velocity:destroy()
					end
				end)()
			end
			swait(120)
			neutralAnims = true
			WalkSpeed = 8
			Tween(RL,{Scale=V3.N(1,PlayerSize,2)},.6,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out)
			swait(36)
			Tween(RL,{Scale=V3.N(1,PlayerSize,1)},.6,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out)
			swait(36)
			Attack = false
			RL:destroy()
		end
		function Taunt()
			Attack = true
			neutralAnims = false
			local giggle = FX(176265509,10,1,head)
			while giggle.Playing do
				local Alpha = .2
				swait()
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00653425185, -0.367415309+.4*M.S(time()*12), -0.572485209, 0.999995291, -0.00257562893, -0.000296123326, 0.00257599982, 0.974187136, 0.22572732, -0.000292910263, -0.225727022, 0.974189222),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.503953636, -3.23575497-.4*M.S(time()*12), -0.0791287646, 1, 0.000350067159, -1.45565718e-06, -0.00034994795, 0.999533594, -0.0305390507, -9.23592597e-06, 0.0305390656, 0.999533653)*CF.A(M.R(M.RNG(-30,30)),M.R(M.RNG(-30,30)),M.R(M.RNG(-30,30))),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.49835059, -3.15593815-.4*M.S(time()*12), -0.187087312, 0.999996603, 0.00258975197, -0.000121647492, -0.00257564802, 0.987003267, -0.160680294, -0.000296056271, 0.1606801, 0.987006545)*CF.A(M.R(M.RNG(-30,30)),M.R(M.RNG(-30,30)),M.R(M.RNG(-30,30))),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.43127036, 0.451340854, -0.462174714, 0.997353315, 0.0727057606, -0.000517063774, -0.0693833008, 0.949603021, -0.305679858, -0.0217336789, 0.304906696, 0.952134252)*CF.A(M.R(M.RNG(-30,30)),M.R(M.RNG(-30,30)),M.R(M.RNG(-30,30))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.41581738, 0.455256999, -0.457439601, 0.996124089, -0.0879578516, -0.000504340976, 0.0835438147, 0.947897792, -0.307425261, 0.0275185313, 0.306191564, 0.95157218)*CF.A(M.R(M.RNG(-30,30)),M.R(M.RNG(-30,30)),M.R(M.RNG(-30,30))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(-1.90670835e-06, 2.74999475, -7.62939453e-06, 1, 2.32830644e-10, -9.31322575e-10, 2.32830644e-10, 1, 0, -9.31322575e-10, 0, 1)*CF.A(M.R(M.RNG(-30,30)),M.R(M.RNG(-30,30)),M.R(M.RNG(-30,30))),Alpha)
				RT3.C0 = clerp(RT3.C0,CFrame.new(1.61375785, -1.76555657, -0.513190091, -0.55665189, 0.810403109, 0.182717308, -0.771965683, -0.585860789, 0.24665007, 0.306932837, -0.00375326723, 0.951723814),Alpha)
				RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36366892, -0.0526333712, 0.463351786, 0.00432222337, -0.925635338, 0.378392518, 0.999990284, 0.00432161195, -0.000850837678, -0.000847693533, 0.378392458, 0.925644875),Alpha)
				RT2.C0 = clerp(RT2.C0,CFrame.new(1.2538718, -2.21410918, -0.524856687, -0.771987855, 0.583863854, 0.251272887, -0.556619704, -0.811843097, 0.176310748, 0.306935579, -0.00375370681, 0.95172298),Alpha)
				RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32391119, -0.0978909656, 0.155143276, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
				RR2.C0 = clerp(RR2.C0,CFrame.new(1.25468278, -2.23918462, 0.480947077, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
				RR3.C0 = clerp(RR3.C0,CFrame.new(1.53806043, -1.79355478, 0.474106222, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
				RS3.C0 = clerp(RS3.C0,CFrame.new(1.49055731, -1.77398741, 0.730609715, -0.660822511, 0.739318788, -0.129311174, -0.748390913, -0.662110388, 0.0389984399, -0.0567859784, 0.12254636, 0.990836978),Alpha)
				RS2.C0 = clerp(RS2.C0,CFrame.new(1.12350154, -2.19243288, 0.735727072, -0.863375664, 0.492343336, -0.110365942, -0.501357257, -0.861730874, 0.0778523907, -0.0567756221, 0.122548625, 0.990837216),Alpha)
				RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33202672, -0.0549109876, 0.413173437, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
				RM2.C0 = clerp(RM2.C0,CFrame.new(1.255373, -2.24170375, 0.251963019, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
				RM3.C0 = clerp(RM3.C0,CFrame.new(1.5395211, -1.79571998, 0.245096236, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
				RM1.C0 = clerp(RM1.C0,CFrame.new(-2.323915, -0.100503564, -0.0738568455, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
				RP2.C0 = clerp(RP2.C0,CFrame.new(1.25615263, -2.2444911, -0.000960677862, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
				RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32391214, -0.103389643, -0.32676369, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
				RP3.C0 = clerp(RP3.C0,CFrame.new(1.54112804, -1.79812348, -0.0077983737, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
				LR3.C0 = clerp(LR3.C0,CFrame.new(1.45705879, -1.89598083, -0.385099679, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
				LT3.C0 = clerp(LT3.C0,CFrame.new(1.40952325, -1.97281897, 0.526059091, 0.671315253, 0.714624286, 0.196591273, 0.679187477, -0.699324131, 0.222823307, 0.296715915, -0.0160623491, -0.954830825),Alpha)
				LT1.C0 = clerp(LT1.C0,CFrame.new(-2.3832376, -0.197773144, -0.480284959, 0.00441737333, -0.922104299, 0.38691628, -0.999989927, -0.00441598753, 0.000892503187, 0.000885637477, -0.38691628, -0.922114491),Alpha)
				LT2.C0 = clerp(LT2.C0,CFrame.new(0.99463892, -2.34625196, 0.514375746, 0.851474643, 0.457154393, 0.256906241, 0.432377875, -0.889242351, 0.14932391, 0.296715945, -0.0160649493, -0.954830766),Alpha)
				LR2.C0 = clerp(LR2.C0,CFrame.new(1.14547455, -2.31078553, -0.378219754, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
				LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390952, -0.272462696, -0.121384747, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
				LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33202744, -0.23541376, -0.383374184, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
				LM3.C0 = clerp(LM3.C0,CFrame.new(1.45572555, -1.89398086, -0.174214169, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
				LS3.C0 = clerp(LS3.C0,CFrame.new(1.49722528, -1.81738269, -0.636980891, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
				LP2.C0 = clerp(LP2.C0,CFrame.new(1.14411652, -2.30584955, 0.0697559863, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
				LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32390475, -0.267352402, 0.326590419, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
				LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32390952, -0.270056516, 0.0895184278, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
				LS2.C0 = clerp(LS2.C0,CFrame.new(1.11611402, -2.23573709, -0.631830394, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
				LM2.C0 = clerp(LM2.C0,CFrame.new(1.14484239, -2.30846381, -0.167330459, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
				LP3.C0 = clerp(LP3.C0,CFrame.new(1.45421648, -1.89172983, 0.0628871024, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
			end
			Attack = false
			neutralAnims = true
		end

		function FuckYou()
			Attack = true
			neutralAnims = false
			for i = 0, 1, 0.1 do
				swait()
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00491022924, 0.150342643, -0.430241644, 0.999993742, -0.00153528806, -0.00010153465, 0.00153500005, 0.990909874, 0.134519234, -0.000105913728, -0.134518534, 0.990906),0.3)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.500732899, -3.67427373, -0.0646588951, 0.999993742, 0.00153500005, -0.000105913728, -0.00153528806, 0.990909874, -0.134518534, -0.00010153465, 0.134519234, 0.990906),0.3)
				RH.C0 = clerp(RH.C0,CFrame.new(0.499253213, -3.67580914, -0.0647604018, 0.999993742, 0.00153500005, -0.000105913728, -0.00153528806, 0.990909874, -0.134518534, -0.00010153465, 0.134519234, 0.990906),0.3)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.43846512, 0.498227417, -4.07661537e-06, 0.998342752, 0.0575486869, -9.6578151e-07, -0.0575486869, 0.998342752, -2.25007534e-06, 8.32602382e-07, 2.30967999e-06, 1.00000012),0.3)
				RS.C0 = clerp(RS.C0,CFrame.new(0.940297365, 1.64152968, -0.0374116302, -0.0358937122, -0.0253289044, -0.999034703, -0.95639807, -0.28907603, 0.0416908972, -0.289852977, 0.956971049, -0.0138485003),0.3)
				NK.C0 = clerp(NK.C0,CFrame.new(1.19201377e-06, 2.74261379, -0.000996351242, 1.00000012, -2.91038305e-11, 0, 1.16415322e-10, 0.993324518, -0.115354955, 9.31322575e-10, 0.11535497, 0.993324518),0.3)
				RT3.C0 = clerp(RT3.C0,CFrame.new(-2.48911524, -1.55586731, 0.474759281, -0.552649975, -0.771624744, 0.314917922, 0.833413184, -0.511293769, 0.209765062, -0.000844340771, 0.378383338, 0.92564863),0.3)
				RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36367702, -0.0526425689, 0.4633497, 0.00430683792, -0.925637126, 0.378387868, 0.999990523, 0.00430384278, -0.00085362047, -0.000838372856, 0.378387809, 0.925646842),0.3)
				RT2.C0 = clerp(RT2.C0,CFrame.new(-2.57269597, -0.719226956, 0.463091969, -0.261123598, -0.893614113, 0.365059316, 0.965305209, -0.241402701, 0.099553816, -0.000836394727, 0.378389418, 0.925646245),0.3)
				RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32395005, -0.097909227, 0.155159667, -1.07884407e-05, -1, 5.35137951e-06, 1.00000012, -1.07884407e-05, 6.40703365e-06, -6.40703365e-06, 5.34951687e-06, 1.00000012),0.3)
				RR2.C0 = clerp(RR2.C0,CFrame.new(-2.6166935, -0.764995873, 0.154831141, -0.265279979, -0.96417141, 4.18908894e-06, 0.964171648, -0.265280008, -9.983778e-07, 2.0749867e-06, 3.77744436e-06, 1.00000012),0.3)
				RR3.C0 = clerp(RR3.C0,CFrame.new(-2.60076976, -1.61759865, 0.147939563, -0.556234598, -0.831025302, 1.52736902e-06, 0.831025481, -0.556234598, -9.31881368e-06, 8.60122964e-06, -3.9152801e-06, 1.00000012),0.3)
				RS3.C0 = clerp(RS3.C0,CFrame.new(-2.44678545, -1.52428412, 0.407759637, -0.556234598, -0.831025302, 1.52736902e-06, 0.831025481, -0.556234598, -9.31881368e-06, 8.60122964e-06, -3.9152801e-06, 1.00000012),0.3)
				RS2.C0 = clerp(RS2.C0,CFrame.new(-2.5334239, -0.711895049, 0.412882298, -0.265279979, -0.96417141, 4.18908894e-06, 0.964171648, -0.265280008, -9.983778e-07, 2.0749867e-06, 3.77744436e-06, 1.00000012),0.3)
				RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33206296, -0.0549341328, 0.413169026, -1.07884407e-05, -1, 5.35137951e-06, 1.00000012, -1.07884407e-05, 6.40703365e-06, -6.40703365e-06, 5.34951687e-06, 1.00000012),0.3)
				RM2.C0 = clerp(RM2.C0,CFrame.new(-0.98091644, -2.5455389, -0.462086409, -0.941852868, -0.314071566, -0.119467556, 0.32696858, -0.93857801, -0.110285565, -0.0774920732, -0.142934874, 0.986693859),0.3)
				RM3.C0 = clerp(RM3.C0,CFrame.new(-0.48635602, -2.79032993, -0.468960643, -0.996911287, -0.00154927373, -0.0785218477, 0.0127522349, -0.989730775, -0.142374128, -0.0774949342, -0.142935663, 0.986693442),0.3)
				RM1.C0 = clerp(RM1.C0,CFrame.new(-2.32390904, -0.100513272, -0.0738428086, -1.07884407e-05, -1, 5.35137951e-06, 1.00000012, -1.07884407e-05, 6.40703365e-06, -6.40703365e-06, 5.34951687e-06, 1.00000012),0.3)
				RP2.C0 = clerp(RP2.C0,CFrame.new(-2.61524796, -0.770285487, -0.327097982, -0.265279979, -0.96417141, 4.18908894e-06, 0.964171648, -0.265280008, -9.983778e-07, 2.0749867e-06, 3.77744436e-06, 1.00000012),0.3)
				RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32393694, -0.103402615, -0.326755345, -1.07884407e-05, -1, 5.35137951e-06, 1.00000012, -1.07884407e-05, 6.40703365e-06, -6.40703365e-06, 5.34951687e-06, 1.00000012),0.3)
				RP3.C0 = clerp(RP3.C0,CFrame.new(-2.5977087, -1.62216866, -0.333958834, -0.556234598, -0.831025302, 1.52736902e-06, 0.831025481, -0.556234598, -9.31881368e-06, 8.60122964e-06, -3.9152801e-06, 1.00000012),0.3)
				LR3.C0 = clerp(LR3.C0,CFrame.new(-2.50363731, -1.76269853, -0.128623277, 0.556233406, -0.831026256, -1.01327896e-06, -0.831026137, -0.556233406, 9.69320536e-06, -8.61659646e-06, -4.55975533e-06, -1),0.3)
				LT3.C0 = clerp(LT3.C0,CFrame.new(-2.42464828, -1.68734479, -0.468878269, 0.559899807, -0.763836026, 0.321040273, -0.828559816, -0.516573429, 0.215964258, 0.000879591331, -0.386919409, -0.92211324),0.3)
				LT1.C0 = clerp(LT1.C0,CFrame.new(-2.38323879, -0.197775438, -0.480279565, 0.00441244617, -0.922105789, 0.386912972, -0.999989867, -0.00441200566, 0.00088926591, 0.000887067989, -0.386912942, -0.922115922),0.3)
				LT2.C0 = clerp(LT2.C0,CFrame.new(-2.55308461, -0.864341974, -0.480537415, 0.269529641, -0.887898803, 0.372812748, -0.962991655, -0.248866722, 0.10350062, 0.000882614404, -0.386912107, -0.92211622),0.3)
				LR2.C0 = clerp(LR2.C0,CFrame.new(-2.57037759, -0.93331933, -0.121699877, 0.265274286, -0.964173079, -5.96046448e-08, -0.964172959, -0.265274346, 3.81655991e-06, -3.69176269e-06, -9.53674316e-07, -1),0.3)
				LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390833, -0.272465348, -0.121396132, -3.04076821e-06, -1.00000012, 2.98023224e-08, -0.99999994, 3.03401612e-06, 3.37697566e-06, -3.37138772e-06, -4.47034836e-08, -1),0.3)
				LS1.C0 = clerp(LS1.C0,CFrame.new(-2.3320241, -0.235415176, -0.383377969, -3.04076821e-06, -1.00000012, 2.98023224e-08, -0.99999994, 3.03401612e-06, 3.37697566e-06, -3.37138772e-06, -4.47034836e-08, -1),0.3)
				LM3.C0 = clerp(LM3.C0,CFrame.new(-2.50497794, -1.76070499, 0.0823027939, 0.556233406, -0.831026256, -1.01327896e-06, -0.831026137, -0.556233406, 9.69320536e-06, -8.61659646e-06, -4.55975533e-06, -1),0.3)
				LS3.C0 = clerp(LS3.C0,CFrame.new(-2.34635568, -1.67428637, -0.388765872, 0.556233406, -0.831026256, -1.01327896e-06, -0.831026137, -0.556233406, 9.69320536e-06, -8.61659646e-06, -4.55975533e-06, -1),0.3)
				LP2.C0 = clerp(LP2.C0,CFrame.new(-2.57173824, -0.928392828, 0.326286733, 0.265274286, -0.964173079, -5.96046448e-08, -0.964172959, -0.265274346, 3.81655991e-06, -3.69176269e-06, -9.53674316e-07, -1),0.3)
				LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32390881, -0.26735279, 0.32663244, -3.04076821e-06, -1.00000012, 2.98023224e-08, -0.99999994, 3.03401612e-06, 3.37697566e-06, -3.37138772e-06, -4.47034836e-08, -1),0.3)
				LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32390547, -0.27005899, 0.0895337462, -3.04076821e-06, -1.00000012, 2.98023224e-08, -0.99999994, 3.03401612e-06, 3.37697566e-06, -3.37138772e-06, -4.47034836e-08, -1),0.3)
				LS2.C0 = clerp(LS2.C0,CFrame.new(-2.48551345, -0.885946035, -0.383605361, 0.265274286, -0.964173079, -5.96046448e-08, -0.964172959, -0.265274346, 3.81655991e-06, -3.69176269e-06, -9.53674316e-07, -1),0.3)
				LM2.C0 = clerp(LM2.C0,CFrame.new(-2.5710206, -0.931001067, 0.0891880393, 0.265274286, -0.964173079, -5.96046448e-08, -0.964172959, -0.265274346, 3.81655991e-06, -3.69176269e-06, -9.53674316e-07, -1),0.3)
				LP3.C0 = clerp(LP3.C0,CFrame.new(-2.50648189, -1.75845611, 0.319393873, 0.556233406, -0.831026256, -1.01327896e-06, -0.831026137, -0.556233406, 9.69320536e-06, -8.61659646e-06, -4.55975533e-06, -1),0.3)
			end
			swait(90)
			neutralAnims = true
			Attack = false
		end

		function GetTorso(char)
			return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
		end

		function DealDamage(who,minDam,maxDam,Knock,Type)
			if(who)then
				local hum = who:FindFirstChildOfClass'Humanoid'
				local Damage = M.RNG(minDam,maxDam)
				local canHit = true
				if(hum)then
					for _, p in pairs(Hit) do
						if p[1] == hum then
							if(time() - p[2] < 0.1) then
								canHit = false
							else
								Hit[_] = nil
							end
						end
					end
					if(canHit)then
						if(hum.Health >= math.huge)then
							who:BreakJoints()
						else
							local player = S.Players:GetPlayerFromCharacter(who)
							if(not player or not Teamed[player])then
								if(Type == "Fire")then
									--idk..
								else
									local  c = Instance.new("ObjectValue",hum)
									c.Name = "creator"
									c.Value = plr
									game:service'Debris':AddItem(c,0.35)
									hum.Health = hum.Health - Damage
									if(Type == 'Knockback' and GetTorso(who))then
										local angle = GetTorso(who).Position - root.Position + Vector3.new(0, 0, 0).unit
										local body = NewInstance('BodyVelocity',GetTorso(who),{
											P = 500,
											maxForce = V3.N(math.huge,0,math.huge),
											velocity = root.CFrame.lookVector * Knock + root.Velocity / 1.05
										})
										game:service'Debris':AddItem(body,.5)	
									elseif(Type == 'Freeze' and GetTorso(who))then
										local angle = GetTorso(who).Position - root.Position + Vector3.new(0, 0, 0).unit
										local body = NewInstance('BodyPosition',GetTorso(who),{
											P = 500,
											D = 1,
											MaxForce = V3.N(math.huge,0,math.huge),
											Position = GetTorso(who).CFrame.p
										})
										game:service'Debris':AddItem(body,.5)
									elseif(Type == 'Knockdown' and GetTorso(who))then
										local rek = GetTorso(who)
										print(rek)
										hum.PlatformStand = true
										delay(1,function()
											hum.PlatformStand = false
										end)
										local angle = (GetTorso(who).Position - (root.Position + Vector3.new(0, 0, 0))).unit
										local bodvol = NewInstance("BodyVelocity",rek,{
											velocity = angle * Knock,
											P = 5000,
											maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
										})
										local rl = NewInstance("BodyAngularVelocity",rek,{
											P = 3000,
											maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
											angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
										})
										game:GetService("Debris"):AddItem(bodvol, .5)
										game:GetService("Debris"):AddItem(rl, .5)
									end
								end
							end
						end
						table.insert(Hit,{hum,time()})
					end
				end
			end
		end

		function MagniDamage(pos,radius,mindamage,maxdamage,knockback,damagetype)
			local Recursive
			Recursive = function(whom)	
				for _,c in next, whom:children() do
					local hum = c:FindFirstChildOfClass'Humanoid'
					local hed = c:FindFirstChild'Torso' or c:FindFirstChild'UpperTorso' or c:FindFirstChild'LowerTorso'
					if(hum and hed)then
						local mag = (hed.CFrame.p - pos).magnitude
						if(mag <= radius and c ~= char)then
							DealDamage(c,mindamage,maxdamage,knockback,damagetype)
						end
					end
					Recursive(c)
				end
			end
			Recursive(workspace)
		end

		function MagniHeal(pos,radius,heal,needsTeamed)
			for _,v in next, workspace:GetDescendants() do
				local player = S.Players:GetPlayerFromCharacter(v)
				local hum = v:FindFirstChildOfClass'Humanoid'
				if(hum and v:IsA'Model')then
					if(not needsTeamed or player and (not plr.Neutral and player.TeamColor == plr.TeamColor))then
						local pp = v.PrimaryPart or v:FindFirstChild'Torso' or v:FindFirstChild'UpperTorso' or v:FindFirstChild'LowerTorso'
						if(pp and (pp.CFrame.p-pos).magnitude <= radius)then
							hum.Health = hum.Health + heal
						end
					end
				end
			end	
		end


		Debounces:New('how2use',1) -- name, cooldown

		function SpitAcid()
			Attack = true
			neutralAnims = false
			if(Puddle)then Puddle:destroy() Puddle = nil end
			for i = 0, 1, 0.1 do
				swait()
				RJ.C0 = clerp(RJ.C0,CFrame.new(0.015540313, -0.194137305, 1.36152554, 0.999978483, 0.00553973578, -0.00143473037, -0.00553999934, 0.874346554, -0.485270619, -0.00143382046, 0.485268205, 0.874358296),0.3)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.495259553, -3.55402684, 0.41450882, 0.999978483, -0.00553999934, -0.00143382046, 0.00553973578, 0.874346554, 0.485268205, -0.00143473037, -0.485270619, 0.874358296),0.3)
				RH.C0 = clerp(RH.C0,CFrame.new(0.504710793, -3.54848552, 0.413077593, 0.999978483, -0.00553999934, -0.00143382046, 0.00553973578, 0.874346554, 0.485268205, -0.00143473037, -0.485270619, 0.874358296),0.3)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.66483569, -0.274379343, -0.698251367, 0.384908408, -0.477027953, 0.790120065, -0.21145758, -0.878884673, -0.427606821, 0.898404837, -0.00248748064, -0.439161271),0.3)
				RS.C0 = clerp(RS.C0,CFrame.new(1.37159514, -0.44847852, -1.23277056, 0.521697402, 0.274750113, -0.807678282, 0.301484585, -0.945011377, -0.12673144, -0.798084557, -0.177387089, -0.575842798),0.3)
				NK.C0 = clerp(NK.C0,CFrame.new(-3.1007221e-06, 2.74997783, 1.91554427e-05, 1, -4.65661287e-10, -9.31322575e-10, -4.65661287e-10, 1.00000024, 2.98023224e-08, -9.31322575e-10, 2.98023224e-08, 1),0.3)
				RT3.C0 = clerp(RT3.C0,CFrame.new(-2.4890492, -1.55583262, 0.474699855, -0.552634418, -0.771629453, 0.314933747, 0.833423376, -0.511281967, 0.209752887, -0.000831574202, 0.378389925, 0.925646067),0.3)
				RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36362505, -0.0526267663, 0.463311166, 0.00432950258, -0.925636709, 0.378388762, 0.999990284, 0.00432765484, -0.000855326653, -0.000845819712, 0.378388792, 0.925646544),0.3)
				RT2.C0 = clerp(RT2.C0,CFrame.new(-2.57266617, -0.719199896, 0.463027179, -0.261096984, -0.893622637, 0.365057617, 0.965312362, -0.241375238, 0.0995507389, -0.000844955444, 0.378387004, 0.92564714),0.3)
				RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32386756, -0.0978833809, 0.155133307, 3.75509262e-06, -1.00000012, 6.49690628e-06, 1, 3.7252903e-06, -7.65919685e-06, 7.68899918e-06, 6.49690628e-06, 1.00000012),0.3)
				RR2.C0 = clerp(RR2.C0,CFrame.new(-2.61664414, -0.764966667, 0.154766977, -0.265265912, -0.964175463, 5.96046448e-08, 0.964175403, -0.265265882, -3.85940075e-06, 3.69548798e-06, -1.01327896e-06, 1),0.3)
				RR3.C0 = clerp(RR3.C0,CFrame.new(-2.60068607, -1.61760664, 0.147925094, -0.556230366, -0.831028283, 1.02221966e-05, 0.831028283, -0.556230366, -1.60038471e-05, 1.89840794e-05, -4.17232513e-07, 1),0.3)
				RS3.C0 = clerp(RS3.C0,CFrame.new(-2.4467001, -1.52426553, 0.407730699, -0.556230366, -0.831028283, 1.02221966e-05, 0.831028283, -0.556230366, -1.60038471e-05, 1.89840794e-05, -4.17232513e-07, 1),0.3)
				RS2.C0 = clerp(RS2.C0,CFrame.new(-2.53333163, -0.711880744, 0.412846714, -0.265265912, -0.964175463, 5.96046448e-08, 0.964175403, -0.265265882, -3.85940075e-06, 3.69548798e-06, -1.01327896e-06, 1),0.3)
				RS1.C0 = clerp(RS1.C0,CFrame.new(-2.3319757, -0.054920394, 0.413150311, 3.75509262e-06, -1.00000012, 6.49690628e-06, 1, 3.7252903e-06, -7.65919685e-06, 7.68899918e-06, 6.49690628e-06, 1.00000012),0.3)
				RM2.C0 = clerp(RM2.C0,CFrame.new(-2.61595607, -0.767494619, -0.074202612, -0.265265912, -0.964175463, 5.96046448e-08, 0.964175403, -0.265265882, -3.85940075e-06, 3.69548798e-06, -1.01327896e-06, 1),0.3)
				RM3.C0 = clerp(RM3.C0,CFrame.new(-2.59923792, -1.61976969, -0.081080772, -0.556230366, -0.831028283, 1.02221966e-05, 0.831028283, -0.556230366, -1.60038471e-05, 1.89840794e-05, -4.17232513e-07, 1),0.3)
				RM1.C0 = clerp(RM1.C0,CFrame.new(-2.32380795, -0.100540474, -0.0739126056, 3.75509262e-06, -1.00000012, 6.49690628e-06, 1, 3.7252903e-06, -7.65919685e-06, 7.68899918e-06, 6.49690628e-06, 1.00000012),0.3)
				RP2.C0 = clerp(RP2.C0,CFrame.new(-2.61518192, -0.770279586, -0.327113241, -0.265265912, -0.964175463, 5.96046448e-08, 0.964175403, -0.265265882, -3.85940075e-06, 3.69548798e-06, -1.01327896e-06, 1),0.3)
				RP1.C0 = clerp(RP1.C0,CFrame.new(-2.3238554, -0.103376672, -0.32674697, 3.75509262e-06, -1.00000012, 6.49690628e-06, 1, 3.7252903e-06, -7.65919685e-06, 7.68899918e-06, 6.49690628e-06, 1.00000012),0.3)
				RP3.C0 = clerp(RP3.C0,CFrame.new(-2.5976193, -1.62214637, -0.333983809, -0.556230366, -0.831028283, 1.02221966e-05, 0.831028283, -0.556230366, -1.60038471e-05, 1.89840794e-05, -4.17232513e-07, 1),0.3)
				LR3.C0 = clerp(LR3.C0,CFrame.new(-2.50360489, -1.7626704, -0.128580347, 0.556239069, -0.831022382, -8.19563866e-06, -0.831022322, -0.556239009, 1.50501728e-05, -1.70469284e-05, -1.54972076e-06, -1),0.3)
				LT3.C0 = clerp(LT3.C0,CFrame.new(-2.42460489, -1.68731928, -0.468825698, 0.559906244, -0.763835907, 0.321029454, -0.828555644, -0.516578794, 0.215967864, 0.00087299943, -0.386912465, -0.922115982),0.3)
				LT1.C0 = clerp(LT1.C0,CFrame.new(-2.38321996, -0.19776459, -0.480273247, 0.00442242622, -0.922105253, 0.386913955, -0.999989867, -0.00441715121, 0.000902920961, 0.000876456499, -0.386913955, -0.922115326),0.3)
				LT2.C0 = clerp(LT2.C0,CFrame.new(-2.55304503, -0.864306688, -0.480517149, 0.269535363, -0.887896836, 0.372813493, -0.962990224, -0.248867005, 0.103514582, 0.000870674849, -0.386916608, -0.922114253),0.3)
				LR2.C0 = clerp(LR2.C0,CFrame.new(-2.57033348, -0.933283329, -0.121752061, 0.265276402, -0.964172482, 1.11758709e-05, -0.964172482, -0.265276432, 1.46627426e-05, -1.11460686e-05, -1.4603138e-05, -1),0.3)
				LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32388091, -0.272441268, -0.12135601, -2.50339508e-06, -1, -8.40425491e-06, -1, 2.44379044e-06, 5.1856041e-06, -5.1856041e-06, 8.40425491e-06, -1),0.3)
				LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33202934, -0.235401109, -0.383343428, -2.50339508e-06, -1, -8.40425491e-06, -1, 2.44379044e-06, 5.1856041e-06, -5.1856041e-06, 8.40425491e-06, -1),0.3)
				LM3.C0 = clerp(LM3.C0,CFrame.new(-2.50493479, -1.76065683, 0.0823381245, 0.556239069, -0.831022382, -8.19563866e-06, -0.831022322, -0.556239009, 1.50501728e-05, -1.70469284e-05, -1.54972076e-06, -1),0.3)
				LS3.C0 = clerp(LS3.C0,CFrame.new(-2.34629893, -1.67424059, -0.388719767, 0.556239069, -0.831022382, -8.19563866e-06, -0.831022322, -0.556239009, 1.50501728e-05, -1.70469284e-05, -1.54972076e-06, -1),0.3)
				LP2.C0 = clerp(LP2.C0,CFrame.new(-2.57168937, -0.928365827, 0.326213628, 0.265276402, -0.964172482, 1.11758709e-05, -0.964172482, -0.265276432, 1.46627426e-05, -1.11460686e-05, -1.4603138e-05, -1),0.3)
				LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32388473, -0.26733762, 0.326647788, -2.50339508e-06, -1, -8.40425491e-06, -1, 2.44379044e-06, 5.1856041e-06, -5.1856041e-06, 8.40425491e-06, -1),0.3)
				LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32385445, -0.270041019, 0.0895910338, -2.50339508e-06, -1, -8.40425491e-06, -1, 2.44379044e-06, 5.1856041e-06, -5.1856041e-06, 8.40425491e-06, -1),0.3)
				LS2.C0 = clerp(LS2.C0,CFrame.new(-2.4854672, -0.885924935, -0.383642733, 0.265276402, -0.964172482, 1.11758709e-05, -0.964172482, -0.265276432, 1.46627426e-05, -1.11460686e-05, -1.4603138e-05, -1),0.3)
				LM2.C0 = clerp(LM2.C0,CFrame.new(-2.57099056, -0.930950284, 0.0891320631, 0.265276402, -0.964172482, 1.11758709e-05, -0.964172482, -0.265276432, 1.46627426e-05, -1.11460686e-05, -1.4603138e-05, -1),0.3)
				LP3.C0 = clerp(LP3.C0,CFrame.new(-2.50642467, -1.75841117, 0.319392979, 0.556239069, -0.831022382, -8.19563866e-06, -0.831022322, -0.556239009, 1.50501728e-05, -1.70469284e-05, -1.54972076e-06, -1),0.3)
			end
			swait(30)
			for i = 0, 1, 0.1 do
				swait()
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0100999596, -0.039863795, -0.884889722, 0.99998647, -0.00401634211, -0.000728871673, 0.00401599938, 0.93604964, 0.351844996, -0.000730870292, -0.351843148, 0.936053157),0.3)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.504433215, -3.54822564, -0.388769776, 0.99998647, 0.00401599938, -0.000730870292, -0.00401634211, 0.93604964, -0.351843148, -0.000728871673, 0.351844996, 0.936053157),0.3)
				RH.C0 = clerp(RH.C0,CFrame.new(0.495588422, -3.56614351, -0.260721803, 0.999991715, 0.00408073515, -9.31769609e-05, -0.00401603896, 0.979543746, -0.201191202, -0.000729737803, 0.201189905, 0.979552031),0.3)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.7998625, 0.724884272, 0.87759918, 0.940968871, 0.338493019, -7.06408173e-07, -0.254011005, 0.706120729, 0.66096282, 0.223731786, -0.621945262, 0.750418663),0.3)
				RS.C0 = clerp(RS.C0,CFrame.new(1.83249497, 0.794908404, 0.798889935, 0.956190884, -0.292743772, 1.0044314e-06, 0.212052315, 0.692630231, 0.689418018, -0.201823533, -0.659215093, 0.724363804),0.3)
				NK.C0 = clerp(NK.C0,CFrame.new(1.07289861e-05, 2.72116423, -0.0044926405, 0.99999994, 5.82076609e-11, 0, -2.32830644e-10, 0.95272857, -0.303822696, -9.31322575e-10, 0.303822726, 0.95272857),0.3)
				RT3.C0 = clerp(RT3.C0,CFrame.new(-2.48910308, -1.55586052, 0.474731147, -0.552644491, -0.77162528, 0.314926207, 0.83341676, -0.511289656, 0.209760725, -0.000838162377, 0.378387868, 0.925646842),0.3)
				RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36366558, -0.0526419058, 0.463345706, 0.00431899726, -0.925635695, 0.378391564, 0.999990344, 0.00431863964, -0.000849686563, -0.00084762834, 0.378391474, 0.925645351),0.3)
				RT2.C0 = clerp(RT2.C0,CFrame.new(-2.57270837, -0.719227016, 0.463089645, -0.261113733, -0.89361608, 0.365061849, 0.965307832, -0.241391331, 0.0995555148, -0.000841636211, 0.378392309, 0.925645173),0.3)
				RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32389426, -0.0979051962, 0.155150056, -1.11758709e-06, -1.00000012, 3.60608101e-06, 1.00000012, -1.11758709e-06, -1.8030405e-06, 1.78068876e-06, 3.60608101e-06, 1.00000012),0.3)
				RR2.C0 = clerp(RR2.C0,CFrame.new(-2.61667109, -0.765011787, 0.154783443, -0.265277117, -0.964172244, -4.29153442e-06, 0.964172304, -0.265277088, -9.9777244e-06, 8.47131014e-06, -6.7949295e-06, 1.00000012),0.3)
				RR3.C0 = clerp(RR3.C0,CFrame.new(-2.60072637, -1.61763644, 0.147926226, -0.556236744, -0.831024051, 2.68220901e-06, 0.831023932, -0.556236744, -3.23355198e-06, 4.14997339e-06, 4.47034836e-07, 1.00000012),0.3)
				RS3.C0 = clerp(RS3.C0,CFrame.new(-2.44674635, -1.52429295, 0.40773946, -0.556236744, -0.831024051, 2.68220901e-06, 0.831023932, -0.556236744, -3.23355198e-06, 4.14997339e-06, 4.47034836e-07, 1.00000012),0.3)
				RS2.C0 = clerp(RS2.C0,CFrame.new(-2.53337574, -0.711913884, 0.412858188, -0.265277117, -0.964172244, -4.29153442e-06, 0.964172304, -0.265277088, -9.9777244e-06, 8.47131014e-06, -6.7949295e-06, 1.00000012),0.3)
				RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33200336, -0.0549254641, 0.413162977, -1.11758709e-06, -1.00000012, 3.60608101e-06, 1.00000012, -1.11758709e-06, -1.8030405e-06, 1.78068876e-06, 3.60608101e-06, 1.00000012),0.3)
				RM2.C0 = clerp(RM2.C0,CFrame.new(-2.61597395, -0.76752615, -0.0742166862, -0.265277117, -0.964172244, -4.29153442e-06, 0.964172304, -0.265277088, -9.9777244e-06, 8.47131014e-06, -6.7949295e-06, 1.00000012),0.3)
				RM3.C0 = clerp(RM3.C0,CFrame.new(-2.59925842, -1.6197958, -0.0810529143, -0.556236744, -0.831024051, 2.68220901e-06, 0.831023932, -0.556236744, -3.23355198e-06, 4.14997339e-06, 4.47034836e-07, 1.00000012),0.3)
				RM1.C0 = clerp(RM1.C0,CFrame.new(-2.32389116, -0.100515939, -0.0738443434, -1.11758709e-06, -1.00000012, 3.60608101e-06, 1.00000012, -1.11758709e-06, -1.8030405e-06, 1.78068876e-06, 3.60608101e-06, 1.00000012),0.3)
				RP2.C0 = clerp(RP2.C0,CFrame.new(-2.61521149, -0.770304263, -0.327131152, -0.265277117, -0.964172244, -4.29153442e-06, 0.964172304, -0.265277088, -9.9777244e-06, 8.47131014e-06, -6.7949295e-06, 1.00000012),0.3)
				RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32389212, -0.10340035, -0.326758802, -1.11758709e-06, -1.00000012, 3.60608101e-06, 1.00000012, -1.11758709e-06, -1.8030405e-06, 1.78068876e-06, 3.60608101e-06, 1.00000012),0.3)
				RP3.C0 = clerp(RP3.C0,CFrame.new(-2.59766221, -1.62219429, -0.333963573, -0.556236744, -0.831024051, 2.68220901e-06, 0.831023932, -0.556236744, -3.23355198e-06, 4.14997339e-06, 4.47034836e-07, 1.00000012),0.3)
				LR3.C0 = clerp(LR3.C0,CFrame.new(-2.50363922, -1.76270425, -0.128624678, 0.556234479, -0.831025481, 4.11272049e-06, -0.831025481, -0.556234419, 1.07884407e-05, -6.67572021e-06, -9.41753387e-06, -1.00000012),0.3)
				LT3.C0 = clerp(LT3.C0,CFrame.new(-2.42464781, -1.68734825, -0.468857884, 0.559899807, -0.763837337, 0.321036875, -0.828559816, -0.516575038, 0.215960354, 0.000881046057, -0.386914432, -0.922115326),0.3)
				LT1.C0 = clerp(LT1.C0,CFrame.new(-2.38323569, -0.197784454, -0.48027727, 0.00441706181, -0.922104299, 0.38691622, -0.999989927, -0.00441691279, 0.000889614224, 0.000888649374, -0.38691619, -0.922114551),0.3)
				LT2.C0 = clerp(LT2.C0,CFrame.new(-2.55306029, -0.864338577, -0.480565965, 0.269529104, -0.88789624, 0.372819602, -0.962991893, -0.248865172, 0.103502877, 0.00088198483, -0.38691923, -0.922113359),0.3)
				LR2.C0 = clerp(LR2.C0,CFrame.new(-2.57037544, -0.933318377, -0.1217224, 0.265274465, -0.9641729, -1.13248825e-06, -0.9641729, -0.265274465, 6.37769699e-06, -6.43730164e-06, -5.96046448e-07, -1.00000012),0.3)
				LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32389402, -0.272476882, -0.121381931, 1.22189522e-06, -1, 1.37090683e-06, -1, -1.25169754e-06, 2.69711018e-06, -2.68220901e-06, -1.40070915e-06, -1),0.3)
				LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33200383, -0.235421643, -0.383394331, 1.22189522e-06, -1, 1.37090683e-06, -1, -1.25169754e-06, 2.69711018e-06, -2.68220901e-06, -1.40070915e-06, -1),0.3)
				LM3.C0 = clerp(LM3.C0,CFrame.new(-2.50497532, -1.7607044, 0.0823014155, 0.556234479, -0.831025481, 4.11272049e-06, -0.831025481, -0.556234419, 1.07884407e-05, -6.67572021e-06, -9.41753387e-06, -1.00000012),0.3)
				LS3.C0 = clerp(LS3.C0,CFrame.new(-2.3463378, -1.67427754, -0.388777852, 0.556234479, -0.831025481, 4.11272049e-06, -0.831025481, -0.556234419, 1.07884407e-05, -6.67572021e-06, -9.41753387e-06, -1.00000012),0.3)
				LP2.C0 = clerp(LP2.C0,CFrame.new(-2.57172728, -0.928390741, 0.326271892, 0.265274465, -0.9641729, -1.13248825e-06, -0.9641729, -0.265274465, 6.37769699e-06, -6.43730164e-06, -5.96046448e-07, -1.00000012),0.3)
				LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32388711, -0.267366409, 0.326589435, 1.22189522e-06, -1, 1.37090683e-06, -1, -1.25169754e-06, 2.69711018e-06, -2.68220901e-06, -1.40070915e-06, -1),0.3)
				LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32389832, -0.270066559, 0.0895250589, 1.22189522e-06, -1, 1.37090683e-06, -1, -1.25169754e-06, 2.69711018e-06, -2.68220901e-06, -1.40070915e-06, -1),0.3)
				LS2.C0 = clerp(LS2.C0,CFrame.new(-2.48550272, -0.885945439, -0.383622199, 0.265274465, -0.9641729, -1.13248825e-06, -0.9641729, -0.265274465, 6.37769699e-06, -6.43730164e-06, -5.96046448e-07, -1.00000012),0.3)
				LM2.C0 = clerp(LM2.C0,CFrame.new(-2.57100058, -0.93100369, 0.089171268, 0.265274465, -0.9641729, -1.13248825e-06, -0.9641729, -0.265274465, 6.37769699e-06, -6.43730164e-06, -5.96046448e-07, -1.00000012),0.3)
				LP3.C0 = clerp(LP3.C0,CFrame.new(-2.50648022, -1.75845373, 0.319384903, 0.556234479, -0.831025481, 4.11272049e-06, -0.831025481, -0.556234419, 1.07884407e-05, -6.67572021e-06, -9.41753387e-06, -1.00000012),0.3)
			end
			AcidDrop(head.CFrame * CF.N(0,0,head.Size.Z/2).p,head.CFrame * CF.N(0,0,-head.Size.Z).p,10) 
			swait(30)
			neutralAnims = true
			Attack = false
		end



		function newBezier(startpos, pos2, pos3, endpos, t)
			local A = startpos:lerp(pos2, t)
			local B  =pos2:lerp(pos3, t)
			local C = pos3:lerp(endpos, t)
			local lerp1 = A:lerp(B, t)
			local lerp2 = B:lerp(C, t)
			local cubic = lerp1:lerp(lerp2, t)
			return cubic
		end

		function HandOut()
			if(Puddle and Puddle.Parent and Puddle:IsA'BasePart')then
				local hand = NewInstance("Part",char,{Name='Hand',Size = V3.N(3, 5, 3),Anchored=true,CanCollide=false,CFrame = Puddle.CFrame*CF.N(0,2,0)*CF.A(M.R(90),0,0),BrickColor=BrickColor.new'Royal purple'})
				local mesh = NewInstance("SpecialMesh",hand,{MeshId = 'http://www.roblox.com/asset/?id=32054761'})
				local origin = Puddle.CFrame.p
				swait(60)

				for i = 0, 1, .005 do
					hand.CFrame = hand.CFrame:lerp(Puddle.CFrame*CF.N(0,-1,0),i)
					swait()
				end
				swait()
				local MPos 
				if(mouse.Target and mouse.Target.Parent and not mouse.Target.Anchored and mouse.Target.Parent:FindFirstChildOfClass'Humanoid')then
					MPos = NewInstance("Part",char,{Size=V3.N(.05,.05,.05),Anchored=false,CFrame = mouse.Target.CFrame,CanCollide=false,Transparency = 1})
					NewInstance("Weld",MPos,{Part0=MPos,Part1=mouse.Target})
				else
					MPos = NewInstance("Part",char,{Size=V3.N(.05,.05,.05),Anchored=true,CanCollide=false,CFrame=CF.N(mouse.Hit.p),Transparency = 1})
				end
				local onefourth = hand.CFrame.p:Lerp(MPos.CFrame.p, 0.25) + Vector3.new(0, 125, 0)
				local threefourths = hand.CFrame.p:Lerp(MPos.CFrame.p, 0.75) + Vector3.new(0, 15, 0)
				hand.CanCollide = true
				hand.Touched:connect(function(t)
					if(t and t ~= Puddle and not char:IsAncestorOf(t))then
						if(t.Parent)then DealDamage(t.Parent,24,37,1,"Freeze") end
						for i = 1, M.RNG(4,12) do
							ShatterFX(75,BrickColor.new'Royal purple',V3.N(.75,3,.75),hand.CFrame)
						end
						hand:remove()
					end
				end)
				for i = 0, 1, .01 do
					hand.CFrame = CFrame.new(newBezier(origin, onefourth, threefourths, MPos.CFrame.p, i))
					swait()
				end
				if(not MPos:FindFirstChildOfClass'JointInstance')then
					MPos:destroy()
				end
				if(hand.Parent)then
					local hit = getRegion(hand.CFrame.p,5,{char})
					for _,t in next, hit do if(t.Parent)then DealDamage(t.Parent,24,37,1,"Freeze") end end
					for i = 1, M.RNG(4,12) do
						ShatterFX(75,BrickColor.new'Royal purple',V3.N(.75,3,.75),hand.CFrame)
					end
					hand:destroy()
				end
			end
		end
		function ClickCombo()
			Attack = true
			neutralAnims = false
			if(combo == 1)then
				for i = 0, 1, 0.1 do
					swait()
					RJ.C0 = clerp(RJ.C0,CFrame.new(-7.02885164e-23, -0.477379799, 0, 1.00000012, 1.47238149e-22, -9.31322575e-10, 1.47238149e-22, 1, 0, -9.31322575e-10, 0, 1.00000012),0.3)
					LH.C0 = clerp(LH.C0,CFrame.new(-0.500006497, -3.31968737, -0.306620896, 1.00000012, -8.39726999e-06, 1.92523003e-05, -1.22691697e-14, 0.916591704, 0.399824798, -2.10031867e-05, -0.399824798, 0.916591704),0.3)
					RH.C0 = clerp(RH.C0,CFrame.new(0.499969989, -3.0428009, -0.199903578, 1.00000012, -7.1967952e-06, 3.52757052e-05, -1.22692028e-14, 0.979815483, 0.199904054, -3.60021368e-05, -0.199904054, 0.979815543),0.3)
					LS.C0 = clerp(LS.C0,CFrame.new(-1.49998367, 0.867262006, 0.637470126, 1.00000012, 1.93808228e-06, 5.10830432e-07, -1.22691249e-14, 0.25498715, -0.966944456, -2.00420618e-06, 0.966944575, 0.254987121),0.3)
					RS.C0 = clerp(RS.C0,CFrame.new(1.70605004, 0.556896687, 0.0270632394, 0.986828983, -0.140310809, -0.0805086344, 0.140768006, 0.990042686, 3.39962594e-06, 0.0797065049, -0.0113363955, 0.996753991),0.3)
					NK.C0 = clerp(NK.C0,CFrame.new(4.04903294e-22, 2.74998903, 0, 1.00000012, 1.47238149e-22, -9.31322575e-10, 1.47238149e-22, 1, 0, -9.31322575e-10, 0, 1.00000012),0.3)
					RT3.C0 = clerp(RT3.C0,CFrame.new(1.61375785, -1.76555657, -0.513190091, -0.55665189, 0.810403109, 0.182717308, -0.771965683, -0.585860789, 0.24665007, 0.306932837, -0.00375326723, 0.951723814),Alpha)
					RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36366892, -0.0526333712, 0.463351786, 0.00432222337, -0.925635338, 0.378392518, 0.999990284, 0.00432161195, -0.000850837678, -0.000847693533, 0.378392458, 0.925644875),Alpha)
					RT2.C0 = clerp(RT2.C0,CFrame.new(1.2538718, -2.21410918, -0.524856687, -0.771987855, 0.583863854, 0.251272887, -0.556619704, -0.811843097, 0.176310748, 0.306935579, -0.00375370681, 0.95172298),Alpha)
					RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32391119, -0.0978909656, 0.155143276, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RR2.C0 = clerp(RR2.C0,CFrame.new(1.25468278, -2.23918462, 0.480947077, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RR3.C0 = clerp(RR3.C0,CFrame.new(1.53806043, -1.79355478, 0.474106222, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RS3.C0 = clerp(RS3.C0,CFrame.new(1.49055731, -1.77398741, 0.730609715, -0.660822511, 0.739318788, -0.129311174, -0.748390913, -0.662110388, 0.0389984399, -0.0567859784, 0.12254636, 0.990836978),Alpha)
					RS2.C0 = clerp(RS2.C0,CFrame.new(1.12350154, -2.19243288, 0.735727072, -0.863375664, 0.492343336, -0.110365942, -0.501357257, -0.861730874, 0.0778523907, -0.0567756221, 0.122548625, 0.990837216),Alpha)
					RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33202672, -0.0549109876, 0.413173437, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RM2.C0 = clerp(RM2.C0,CFrame.new(1.255373, -2.24170375, 0.251963019, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RM3.C0 = clerp(RM3.C0,CFrame.new(1.5395211, -1.79571998, 0.245096236, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RM1.C0 = clerp(RM1.C0,CFrame.new(-2.323915, -0.100503564, -0.0738568455, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP2.C0 = clerp(RP2.C0,CFrame.new(1.25615263, -2.2444911, -0.000960677862, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32391214, -0.103389643, -0.32676369, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP3.C0 = clerp(RP3.C0,CFrame.new(1.54112804, -1.79812348, -0.0077983737, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					LR3.C0 = clerp(LR3.C0,CFrame.new(1.45705879, -1.89598083, -0.385099679, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LT3.C0 = clerp(LT3.C0,CFrame.new(1.40952325, -1.97281897, 0.526059091, 0.671315253, 0.714624286, 0.196591273, 0.679187477, -0.699324131, 0.222823307, 0.296715915, -0.0160623491, -0.954830825),Alpha)
					LT1.C0 = clerp(LT1.C0,CFrame.new(-2.3832376, -0.197773144, -0.480284959, 0.00441737333, -0.922104299, 0.38691628, -0.999989927, -0.00441598753, 0.000892503187, 0.000885637477, -0.38691628, -0.922114491),Alpha)
					LT2.C0 = clerp(LT2.C0,CFrame.new(0.99463892, -2.34625196, 0.514375746, 0.851474643, 0.457154393, 0.256906241, 0.432377875, -0.889242351, 0.14932391, 0.296715945, -0.0160649493, -0.954830766),Alpha)
					LR2.C0 = clerp(LR2.C0,CFrame.new(1.14547455, -2.31078553, -0.378219754, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390952, -0.272462696, -0.121384747, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33202744, -0.23541376, -0.383374184, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM3.C0 = clerp(LM3.C0,CFrame.new(1.45572555, -1.89398086, -0.174214169, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LS3.C0 = clerp(LS3.C0,CFrame.new(1.49722528, -1.81738269, -0.636980891, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LP2.C0 = clerp(LP2.C0,CFrame.new(1.14411652, -2.30584955, 0.0697559863, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32390475, -0.267352402, 0.326590419, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32390952, -0.270056516, 0.0895184278, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS2.C0 = clerp(LS2.C0,CFrame.new(1.11611402, -2.23573709, -0.631830394, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LM2.C0 = clerp(LM2.C0,CFrame.new(1.14484239, -2.30846381, -0.167330459, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP3.C0 = clerp(LP3.C0,CFrame.new(1.45421648, -1.89172983, 0.0628871024, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
				end
				for i = 0, 1, 0.1 do
					swait()
					RJ.C0 = clerp(RJ.C0,CFrame.new(-2.90067487e-22, -1.97005653, 0, 1.00000012, 1.47238149e-22, -9.31322575e-10, 1.47238149e-22, 1, 0, -9.31322575e-10, 0, 1.00000012),0.3)
					LH.C0 = clerp(LH.C0,CFrame.new(-0.500014246, -1.98754454, -0.674639285, 1.00000012, -8.39726999e-06, 1.92523003e-05, -1.22691697e-14, 0.916591704, 0.399824798, -2.10031867e-05, -0.399824798, 0.916591704),0.3)
					RH.C0 = clerp(RH.C0,CFrame.new(0.499993473, -3.04685092, 0.134115517, 1, -5.18932939e-05, 3.91616486e-05, -1.22692697e-14, 0.602376044, 0.798212409, -6.50119036e-05, -0.798212469, 0.602376044),0.3)
					LS.C0 = clerp(LS.C0,CFrame.new(-0.715852439, 1.21197295, -1.48773456, 1.00000012, 8.87550414e-07, 4.703179e-07, -1.22691223e-14, 0.468247831, -0.883597195, -1.00489706e-06, 0.883597255, 0.468247861),0.3)
					RS.C0 = clerp(RS.C0,CFrame.new(1.70605004, 0.556896687, 0.0270632394, 0.986828983, -0.140310809, -0.0805086344, 0.140768006, 0.990042686, 3.39962594e-06, 0.0797065049, -0.0113363955, 0.996753991),0.3)
					NK.C0 = clerp(NK.C0,CFrame.new(-1.38261557e-05, 2.72929239, -0.13027066, 1, 3.25473957e-06, -1.0503456e-05, -1.22690944e-14, 0.955193102, 0.295983344, 1.09951943e-05, -0.295983374, 0.955193102),0.3)
					RT3.C0 = clerp(RT3.C0,CFrame.new(1.61375785, -1.76555657, -0.513190091, -0.55665189, 0.810403109, 0.182717308, -0.771965683, -0.585860789, 0.24665007, 0.306932837, -0.00375326723, 0.951723814),Alpha)
					RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36366892, -0.0526333712, 0.463351786, 0.00432222337, -0.925635338, 0.378392518, 0.999990284, 0.00432161195, -0.000850837678, -0.000847693533, 0.378392458, 0.925644875),Alpha)
					RT2.C0 = clerp(RT2.C0,CFrame.new(1.2538718, -2.21410918, -0.524856687, -0.771987855, 0.583863854, 0.251272887, -0.556619704, -0.811843097, 0.176310748, 0.306935579, -0.00375370681, 0.95172298),Alpha)
					RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32391119, -0.0978909656, 0.155143276, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RR2.C0 = clerp(RR2.C0,CFrame.new(1.25468278, -2.23918462, 0.480947077, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RR3.C0 = clerp(RR3.C0,CFrame.new(1.53806043, -1.79355478, 0.474106222, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RS3.C0 = clerp(RS3.C0,CFrame.new(1.49055731, -1.77398741, 0.730609715, -0.660822511, 0.739318788, -0.129311174, -0.748390913, -0.662110388, 0.0389984399, -0.0567859784, 0.12254636, 0.990836978),Alpha)
					RS2.C0 = clerp(RS2.C0,CFrame.new(1.12350154, -2.19243288, 0.735727072, -0.863375664, 0.492343336, -0.110365942, -0.501357257, -0.861730874, 0.0778523907, -0.0567756221, 0.122548625, 0.990837216),Alpha)
					RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33202672, -0.0549109876, 0.413173437, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RM2.C0 = clerp(RM2.C0,CFrame.new(1.255373, -2.24170375, 0.251963019, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RM3.C0 = clerp(RM3.C0,CFrame.new(1.5395211, -1.79571998, 0.245096236, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RM1.C0 = clerp(RM1.C0,CFrame.new(-2.323915, -0.100503564, -0.0738568455, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP2.C0 = clerp(RP2.C0,CFrame.new(1.25615263, -2.2444911, -0.000960677862, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32391214, -0.103389643, -0.32676369, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP3.C0 = clerp(RP3.C0,CFrame.new(1.54112804, -1.79812348, -0.0077983737, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					LR3.C0 = clerp(LR3.C0,CFrame.new(1.45705879, -1.89598083, -0.385099679, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LT3.C0 = clerp(LT3.C0,CFrame.new(1.40952325, -1.97281897, 0.526059091, 0.671315253, 0.714624286, 0.196591273, 0.679187477, -0.699324131, 0.222823307, 0.296715915, -0.0160623491, -0.954830825),Alpha)
					LT1.C0 = clerp(LT1.C0,CFrame.new(-2.3832376, -0.197773144, -0.480284959, 0.00441737333, -0.922104299, 0.38691628, -0.999989927, -0.00441598753, 0.000892503187, 0.000885637477, -0.38691628, -0.922114491),Alpha)
					LT2.C0 = clerp(LT2.C0,CFrame.new(0.99463892, -2.34625196, 0.514375746, 0.851474643, 0.457154393, 0.256906241, 0.432377875, -0.889242351, 0.14932391, 0.296715945, -0.0160649493, -0.954830766),Alpha)
					LR2.C0 = clerp(LR2.C0,CFrame.new(1.14547455, -2.31078553, -0.378219754, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390952, -0.272462696, -0.121384747, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33202744, -0.23541376, -0.383374184, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM3.C0 = clerp(LM3.C0,CFrame.new(1.45572555, -1.89398086, -0.174214169, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LS3.C0 = clerp(LS3.C0,CFrame.new(1.49722528, -1.81738269, -0.636980891, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LP2.C0 = clerp(LP2.C0,CFrame.new(1.14411652, -2.30584955, 0.0697559863, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32390475, -0.267352402, 0.326590419, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32390952, -0.270056516, 0.0895184278, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS2.C0 = clerp(LS2.C0,CFrame.new(1.11611402, -2.23573709, -0.631830394, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LM2.C0 = clerp(LM2.C0,CFrame.new(1.14484239, -2.30846381, -0.167330459, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP3.C0 = clerp(LP3.C0,CFrame.new(1.45421648, -1.89172983, 0.0628871024, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
				end
				combo = 2
			elseif(combo == 2)then
				for i = 0, 1, 0.1 do
					swait()
					RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0719693825, -0.353631526, -0.413391739, 0.962401688, -0.001369123, -0.27162689, 0.033931002, 0.992760718, 0.115217045, 0.269502699, -0.120101668, 0.955481052),0.3)
					LH.C0 = clerp(LH.C0,CFrame.new(-0.433303148, -3.2528758, 0.0569465011, 0.962403357, -0.0090713799, 0.27147305, -0.00136984326, 0.999267459, 0.0382471755, -0.271621138, -0.0371810794, 0.961685956),0.3)
					RH.C0 = clerp(RH.C0,CFrame.new(0.53891623, -3.13483143, -0.180416405, 0.962402523, 0.0551176146, 0.265976518, -0.00136948295, 0.980168343, -0.198162407, -0.271623999, 0.190347731, 0.943391919),0.3)
					LS.C0 = clerp(LS.C0,CFrame.new(-1.6279037, 0.576236188, 2.61447967e-05, 0.990744352, 0.135740772, -2.68220901e-07, -0.135740772, 0.990744531, 6.82473183e-06, 1.1920929e-06, -6.73532486e-06, 1.00000012),0.3)
					RS.C0 = clerp(RS.C0,CFrame.new(1.49999416, 1.29762685, 0.522052169, 1.00000012, -3.66717577e-05, -5.24520874e-05, -2.49557197e-05, 0.5315485, -0.847027957, 5.89191914e-05, 0.847027898, 0.53154856),0.3)
					NK.C0 = clerp(NK.C0,CFrame.new(0.0391526669, 2.73919129, -0.109213173, 0.962416291, -0.0704210624, 0.262289673, -4.28291969e-06, 0.965792358, 0.259317219, -0.271578759, -0.249572277, 0.929493904),0.3)
					RT3.C0 = clerp(RT3.C0,CFrame.new(1.61375785, -1.76555657, -0.513190091, -0.55665189, 0.810403109, 0.182717308, -0.771965683, -0.585860789, 0.24665007, 0.306932837, -0.00375326723, 0.951723814),Alpha)
					RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36366892, -0.0526333712, 0.463351786, 0.00432222337, -0.925635338, 0.378392518, 0.999990284, 0.00432161195, -0.000850837678, -0.000847693533, 0.378392458, 0.925644875),Alpha)
					RT2.C0 = clerp(RT2.C0,CFrame.new(1.2538718, -2.21410918, -0.524856687, -0.771987855, 0.583863854, 0.251272887, -0.556619704, -0.811843097, 0.176310748, 0.306935579, -0.00375370681, 0.95172298),Alpha)
					RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32391119, -0.0978909656, 0.155143276, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RR2.C0 = clerp(RR2.C0,CFrame.new(1.25468278, -2.23918462, 0.480947077, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RR3.C0 = clerp(RR3.C0,CFrame.new(1.53806043, -1.79355478, 0.474106222, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RS3.C0 = clerp(RS3.C0,CFrame.new(1.49055731, -1.77398741, 0.730609715, -0.660822511, 0.739318788, -0.129311174, -0.748390913, -0.662110388, 0.0389984399, -0.0567859784, 0.12254636, 0.990836978),Alpha)
					RS2.C0 = clerp(RS2.C0,CFrame.new(1.12350154, -2.19243288, 0.735727072, -0.863375664, 0.492343336, -0.110365942, -0.501357257, -0.861730874, 0.0778523907, -0.0567756221, 0.122548625, 0.990837216),Alpha)
					RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33202672, -0.0549109876, 0.413173437, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RM2.C0 = clerp(RM2.C0,CFrame.new(1.255373, -2.24170375, 0.251963019, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RM3.C0 = clerp(RM3.C0,CFrame.new(1.5395211, -1.79571998, 0.245096236, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RM1.C0 = clerp(RM1.C0,CFrame.new(-2.323915, -0.100503564, -0.0738568455, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP2.C0 = clerp(RP2.C0,CFrame.new(1.25615263, -2.2444911, -0.000960677862, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32391214, -0.103389643, -0.32676369, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP3.C0 = clerp(RP3.C0,CFrame.new(1.54112804, -1.79812348, -0.0077983737, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					LR3.C0 = clerp(LR3.C0,CFrame.new(1.45705879, -1.89598083, -0.385099679, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LT3.C0 = clerp(LT3.C0,CFrame.new(1.40952325, -1.97281897, 0.526059091, 0.671315253, 0.714624286, 0.196591273, 0.679187477, -0.699324131, 0.222823307, 0.296715915, -0.0160623491, -0.954830825),Alpha)
					LT1.C0 = clerp(LT1.C0,CFrame.new(-2.3832376, -0.197773144, -0.480284959, 0.00441737333, -0.922104299, 0.38691628, -0.999989927, -0.00441598753, 0.000892503187, 0.000885637477, -0.38691628, -0.922114491),Alpha)
					LT2.C0 = clerp(LT2.C0,CFrame.new(0.99463892, -2.34625196, 0.514375746, 0.851474643, 0.457154393, 0.256906241, 0.432377875, -0.889242351, 0.14932391, 0.296715945, -0.0160649493, -0.954830766),Alpha)
					LR2.C0 = clerp(LR2.C0,CFrame.new(1.14547455, -2.31078553, -0.378219754, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390952, -0.272462696, -0.121384747, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33202744, -0.23541376, -0.383374184, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM3.C0 = clerp(LM3.C0,CFrame.new(1.45572555, -1.89398086, -0.174214169, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LS3.C0 = clerp(LS3.C0,CFrame.new(1.49722528, -1.81738269, -0.636980891, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LP2.C0 = clerp(LP2.C0,CFrame.new(1.14411652, -2.30584955, 0.0697559863, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32390475, -0.267352402, 0.326590419, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32390952, -0.270056516, 0.0895184278, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS2.C0 = clerp(LS2.C0,CFrame.new(1.11611402, -2.23573709, -0.631830394, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LM2.C0 = clerp(LM2.C0,CFrame.new(1.14484239, -2.30846381, -0.167330459, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP3.C0 = clerp(LP3.C0,CFrame.new(1.45421648, -1.89172983, 0.0628871024, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
				end
				for i = 0, 1, 0.1 do
					swait()
					RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0813708305, -2.69321704, -1.23718476, 0.962178767, -0.00437435461, -0.272383779, 0.108303025, 0.923599899, 0.367741197, 0.249964997, -0.383332729, 0.889142096),0.3)
					LH.C0 = clerp(LH.C0,CFrame.new(-0.612414181, -2.61676741, -0.58435607, 0.962175846, -0.176673144, 0.207375079, -0.00436975388, 0.751099944, 0.660174072, -0.272394449, -0.63610971, 0.721918225),0.3)
					RH.C0 = clerp(RH.C0,CFrame.new(0.631126463, -1.96321011, 0.126580298, 0.962188601, -0.0960594863, 0.254884005, -0.00438930653, 0.930161417, 0.367124468, -0.272349089, -0.354361773, 0.894569099),0.3)
					LS.C0 = clerp(LS.C0,CFrame.new(-1.62790465, 0.576236606, 1.48463241e-05, 0.99074477, 0.13573873, 1.93715096e-07, -0.135738745, 0.99074465, 1.45435333e-05, 1.75833702e-06, -1.44839287e-05, 1),0.3)
					RS.C0 = clerp(RS.C0,CFrame.new(0.0498194098, 1.70575428, -1.8470602, 0.881212294, 0.303609133, -0.362334967, -0.352427393, -0.0888988078, -0.931607127, -0.315055639, 0.948640347, 0.0286614001),0.3)
					NK.C0 = clerp(NK.C0,CFrame.new(0.0391607434, 2.73919177, -0.10924077, 0.96241641, -0.0704233274, 0.262288958, -4.28315252e-06, 0.965789855, 0.259325653, -0.27157864, -0.249580353, 0.929491699),0.3)
					RT3.C0 = clerp(RT3.C0,CFrame.new(1.61375785, -1.76555657, -0.513190091, -0.55665189, 0.810403109, 0.182717308, -0.771965683, -0.585860789, 0.24665007, 0.306932837, -0.00375326723, 0.951723814),Alpha)
					RT1.C0 = clerp(RT1.C0,CFrame.new(-2.36366892, -0.0526333712, 0.463351786, 0.00432222337, -0.925635338, 0.378392518, 0.999990284, 0.00432161195, -0.000850837678, -0.000847693533, 0.378392458, 0.925644875),Alpha)
					RT2.C0 = clerp(RT2.C0,CFrame.new(1.2538718, -2.21410918, -0.524856687, -0.771987855, 0.583863854, 0.251272887, -0.556619704, -0.811843097, 0.176310748, 0.306935579, -0.00375370681, 0.95172298),Alpha)
					RR1.C0 = clerp(RR1.C0,CFrame.new(-2.32391119, -0.0978909656, 0.155143276, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RR2.C0 = clerp(RR2.C0,CFrame.new(1.25468278, -2.23918462, 0.480947077, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RR3.C0 = clerp(RR3.C0,CFrame.new(1.53806043, -1.79355478, 0.474106222, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RS3.C0 = clerp(RS3.C0,CFrame.new(1.49055731, -1.77398741, 0.730609715, -0.660822511, 0.739318788, -0.129311174, -0.748390913, -0.662110388, 0.0389984399, -0.0567859784, 0.12254636, 0.990836978),Alpha)
					RS2.C0 = clerp(RS2.C0,CFrame.new(1.12350154, -2.19243288, 0.735727072, -0.863375664, 0.492343336, -0.110365942, -0.501357257, -0.861730874, 0.0778523907, -0.0567756221, 0.122548625, 0.990837216),Alpha)
					RS1.C0 = clerp(RS1.C0,CFrame.new(-2.33202672, -0.0549109876, 0.413173437, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RM2.C0 = clerp(RM2.C0,CFrame.new(1.255373, -2.24170375, 0.251963019, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RM3.C0 = clerp(RM3.C0,CFrame.new(1.5395211, -1.79571998, 0.245096236, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					RM1.C0 = clerp(RM1.C0,CFrame.new(-2.323915, -0.100503564, -0.0738568455, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP2.C0 = clerp(RP2.C0,CFrame.new(1.25615263, -2.2444911, -0.000960677862, -0.837398887, 0.534489512, -0.114386044, -0.543847382, -0.835691392, 0.0764864087, -0.0547102317, 0.12625818, 0.990487635),Alpha)
					RP1.C0 = clerp(RP1.C0,CFrame.new(-2.32391214, -0.103389643, -0.32676369, 1.57009345e-06, -1.00000012, -2.98023224e-08, 1.00000012, 1.5682308e-06, -4.15183604e-06, 4.15369868e-06, -2.98023224e-08, 1.00000012),Alpha)
					RP3.C0 = clerp(RP3.C0,CFrame.new(1.54112804, -1.79812348, -0.0077983737, -0.622754991, 0.771082699, -0.132693976, -0.780500948, -0.624092042, 0.0364325941, -0.0547206923, 0.126256362, 0.990487337),Alpha)
					LR3.C0 = clerp(LR3.C0,CFrame.new(1.45705879, -1.89598083, -0.385099679, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LT3.C0 = clerp(LT3.C0,CFrame.new(1.40952325, -1.97281897, 0.526059091, 0.671315253, 0.714624286, 0.196591273, 0.679187477, -0.699324131, 0.222823307, 0.296715915, -0.0160623491, -0.954830825),Alpha)
					LT1.C0 = clerp(LT1.C0,CFrame.new(-2.3832376, -0.197773144, -0.480284959, 0.00441737333, -0.922104299, 0.38691628, -0.999989927, -0.00441598753, 0.000892503187, 0.000885637477, -0.38691628, -0.922114491),Alpha)
					LT2.C0 = clerp(LT2.C0,CFrame.new(0.99463892, -2.34625196, 0.514375746, 0.851474643, 0.457154393, 0.256906241, 0.432377875, -0.889242351, 0.14932391, 0.296715945, -0.0160649493, -0.954830766),Alpha)
					LR2.C0 = clerp(LR2.C0,CFrame.new(1.14547455, -2.31078553, -0.378219754, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LR1.C0 = clerp(LR1.C0,CFrame.new(-2.32390952, -0.272462696, -0.121384747, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS1.C0 = clerp(LS1.C0,CFrame.new(-2.33202744, -0.23541376, -0.383374184, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM3.C0 = clerp(LM3.C0,CFrame.new(1.45572555, -1.89398086, -0.174214169, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LS3.C0 = clerp(LS3.C0,CFrame.new(1.49722528, -1.81738269, -0.636980891, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
					LP2.C0 = clerp(LP2.C0,CFrame.new(1.14411652, -2.30584955, 0.0697559863, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP1.C0 = clerp(LP1.C0,CFrame.new(-2.32390475, -0.267352402, 0.326590419, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LM1.C0 = clerp(LM1.C0,CFrame.new(-2.32390952, -0.270056516, 0.0895184278, 1.38167525e-06, -1.00000012, -2.98023224e-08, -1.00000012, -1.37358438e-06, 4.16254625e-06, -4.16301191e-06, 2.23517418e-08, -1),Alpha)
					LS2.C0 = clerp(LS2.C0,CFrame.new(1.11611402, -2.23573709, -0.631830394, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LM2.C0 = clerp(LM2.C0,CFrame.new(1.14484239, -2.30846381, -0.167330459, 0.893870652, 0.431845099, -0.120437428, 0.43948552, -0.897118986, 0.0450592563, -0.0885880589, -0.0932076424, -0.991697848),Alpha)
					LP3.C0 = clerp(LP3.C0,CFrame.new(1.45421648, -1.89172983, 0.0628871024, 0.709296346, 0.693098009, -0.128506631, 0.699321926, -0.714791417, 0.00471635535, -0.088586539, -0.0932127982, -0.99169755),Alpha)
				end
				combo = 1
			end
			lastClick = time()
			neutralAnims = true
			Attack = false
		end
		mouse.Button1Down:connect(function()
			if(Attack)then return end
			ClickCombo()
		end)
		mouse.KeyDown:connect(function(k)
			if(Attack)then return end	
			if(k == '\\')then
				FuckYou()
			elseif(k == 'q')then
				SpitAcid()
			elseif(k == 'e')then
				Stomp()
			elseif(k == 't')then
				Taunt()
			elseif(k == 'f')then
				HandOut()
			elseif(k == 'r')then
				Eat()
			elseif(k == 'y')then
				torso.CFrame = mouse.Hit*CF.N(0,PlayerSize+.5,0)
			end
		end)

		runService.RenderStepped:connect(function()
			if(not Attack and combo ~= 1 and time()-lastClick > 0.4)then
				combo = 1
			end
		end)
	end)


scripts:Button(
	"MEME ANIMATIONS (FUNNY)",
	function()
		DiscordLib:Notification("PermAnim", "Script Succsesful", "Done!")
		loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/GelatekV2/main/LoadLibrary.lua"))()
		local model = game:GetService("Players").LocalPlayer.Character.PermAnimated
		local mouse = game:GetService("Players").LocalPlayer:GetMouse()
		local Torso = model.Torso
		local RS = Torso:FindFirstChild("Right Shoulder")
		local LS = Torso:FindFirstChild("Left Shoulder")
		local RH = Torso:FindFirstChild("Right Hip")
		local LH = Torso:FindFirstChild("Left Hip")
		local Neck = Torso:FindFirstChild("Neck")
		local Torso = model.Torso
		local Head = model.Head
		local Humanoid = model.Humanoid
		local LeftArm = model["Left Arm"]
		local LeftLeg = model["Left Leg"]
		local RightArm = model["Right Arm"]
		local RightLeg = model["Right Leg"]
		local RootPart = model.HumanoidRootPart
		local attack = false
		local idle = 0
		local Gen = "Girl"
		local ToolMode = 1
		local sprintmode=false
		local jp = 50
		local ws = 6
		local inAir=true
		local inAir2=true
		local equipped = true
		local MoveTH = true
		local MoveArms = true
		local MoveLegs = true
		local toolAon = false
		local stopTA = false
		local sine = 0
		local change = 1
		local toolAnim = "None"
		local toolAnimTime = 0
		local Anim="Idle"
		local RJ = model.HumanoidRootPart:FindFirstChild("RootJoint")
		local cn = CFrame.new
		local cf = CFrame.new
		local ca2 = CFrame.Angles
		local mf = math.floor
		local RbxUtility = LoadLibrary("RbxUtility")
		local Create = RbxUtility.Create
		local canstoptuant1 = false
		local stoptuant1 = false
		local MenyOpen = false
		function swait(num)
			if num == 0 or num == nil then
				game:service'RunService'.RenderStepped:wait(0)
			else
				for i = 0, num do
					game:service'RunService'.RenderStepped:wait(0)
				end
			end
		end

		function stopAnimations()
			coroutine.resume(coroutine.create(function()
				model.Animate:Destroy()
			end))
			coroutine.resume(coroutine.create(function()
				for _,v in pairs(Humanoid:GetPlayingAnimationTracks()) do
					v:Stop()

				end
			end))
		end


		stopAnimations()
		wait(.1)

		rayCast = function(Pos, Dir, Max, Ignore)

			return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
		end
		RS.C1 = cn(0, 0.5, 0) 
		LS.C1 = cn(0, 0.5, 0) 
		RH.C1 = cn(0, 1, 0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
		LH.C1 = cn(0, 1, 0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
		local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14) 
		local NeckCF = cn(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
		local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
		local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)





		function RemoveOutlines(part)
			part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
		end


		CFuncs = {
			Part = {Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)

				local Part = Create("Part")({Parent = Parent, Reflectance = Reflectance, Transparency = Transparency, CanCollide = false, Locked = true, BrickColor = BrickColor.new(tostring(BColor)), Name = Name, Size = Size, Material = Material})
				RemoveOutlines(Part)
				return Part
			end
			}
			, 
			Mesh = {Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)

				local Msh = Create(Mesh)({Parent = Part, Offset = OffSet, Scale = Scale})
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end
			}
			, 
			Mesh = {Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)

				local Msh = Create(Mesh)({Parent = Part, Offset = OffSet, Scale = Scale})
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end
			}
			, 
			Weld = {Create = function(Parent, Part0, Part1, C0, C1)

				local Weld = Create("Weld")({Parent = Parent, Part0 = Part0, Part1 = Part1, C0 = C0, C1 = C1})
				return Weld
			end
			}
			, 
			Sound = {Create = function(id, par, vol, pit)

				coroutine.resume(coroutine.create(function()

					local S = Create("Sound")({Volume = vol, Pitch = pit or 1, SoundId  = "http://www.roblox.com/asset/?id="..id, Parent = par or workspace})
					wait()
					S:play()
					game:GetService("Debris"):AddItem(S, 6)
				end
				))
			end
			}
			, 

			Sound2 = {Create = function(id, par, vol, pit, SoundTime)

				coroutine.resume(coroutine.create(function()

					local S = Create("Sound")({Volume = vol, Pitch = pit or 1, SoundId  = "http://www.roblox.com/asset/?id="..id, Parent = par or workspace})
					wait()
					S:play()
					game:GetService("Debris"):AddItem(S, SoundTime)
				end
				))
			end
			}
			, 
			ParticleEmitter = {Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)

				local fp = Create("ParticleEmitter")({Parent = Parent, Color = ColorSequence.new(Color1, Color2), LightEmission = LightEmission, Size = Size, Texture = Texture, Transparency = Transparency, ZOffset = ZOffset, Acceleration = Accel, Drag = Drag, LockedToPart = LockedToPart, VelocityInheritance = VelocityInheritance, EmissionDirection = EmissionDirection, Enabled = Enabled, Lifetime = LifeTime, Rate = Rate, Rotation = Rotation, RotSpeed = RotSpeed, Speed = Speed, VelocitySpread = VelocitySpread})
				return fp
			end
			}
		}

		so = function(id, par, vol, pit, AlTime)

			if AlTime ~= nil then

				CFuncs.Sound2.Create(id, par, vol, pit, AlTime)	

			else
				CFuncs.Sound.Create(id, par, vol, pit)
			end

		end



		local ParticEffect1 = Create("ParticleEmitter"){
			Color = ColorSequence.new(Color3.new (0, 1, 0), Color3.new (0, 0, 0)),
			Transparency =  NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.2,0),NumberSequenceKeypoint.new(1,1)}),
			Size = NumberSequence.new({NumberSequenceKeypoint.new(0,.15),NumberSequenceKeypoint.new(0.5,.01),NumberSequenceKeypoint.new(1,0)}),
			Texture = "rbxassetid://596872069",
			Lifetime = NumberRange.new(0.8),
			Rate = 100,
			VelocitySpread = 360,
			RotSpeed = NumberRange.new(-100,100),
			Speed = NumberRange.new(2),
			LightEmission = 1,
			LockedToPart = false,
			Acceleration = Vector3.new(0, -5, 0),
			EmissionDirection = "Back",

		}	

--[[
fat = Instance.new("BindableEvent", script)
fat.Name = "Heartbeat"
script:WaitForChild("Heartbeat")
frame = 1/30
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
  
  tf = tf + s
  if frame <= tf then
    if allowframeloss then
      script.Heartbeat:Fire()
      lastframe = tick()
    else
      for i = 1, math.floor(tf / frame) do
        script.Heartbeat:Fire()
      end
      lastframe = tick()
    end
    if tossremainder then
      tf = 0
    else
      tf = tf - frame * math.floor(tf / frame)
    end
  end
end
)















--]]

		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, true)


		for i = 1,3,.1 do
			swait()
			Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
			RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
			RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),1)
			LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
			RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),1)
			LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),1)



		end












		function JumpAfterEffect()
			if attack == false then
				attack = true

				if RootPart.Velocity.y < -65  then
					Humanoid.WalkSpeed= 0
					Humanoid.JumpPower= 0	
					for i = 1,3,.1 do
						swait()	
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(25-3 * math.cos(sine / 15)),math.rad(0),math.rad(0)),.1)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, .3, -.8 +-.05 * math.cos(sine / 15.5)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .7- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(20)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .7- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.15+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.2)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.15+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.2)

					end

				else
					if sprintmode == true then
						Humanoid.WalkSpeed= 10
					else
						Humanoid.WalkSpeed= 3
					end
					Humanoid.JumpPower= 0	
					for i = 1,2,.1 do
						swait()	
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(25-3 * math.cos(sine / 15)),math.rad(0),math.rad(0)),.1)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, .3, -.6 +-.05 * math.cos(sine / 15.5)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .7- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(20)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .7- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.65+ .05 * math.cos(sine / 15), -.2) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.2)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.65+ .05 * math.cos(sine / 15), -.2) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.2)

					end

				end
				attack = false
			end
		end



		function SlashAnim()
			if toolAon == false then
				toolAon= true
				MoveArms = false
				for i = 1,2,.1 do
					if stopTA == false then
						swait()	
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.8- .03 * math.cos(sine / 20), -.2) * CFrame.Angles(math.rad(160- 1 * math.cos(sine / 20)),math.rad(-10),math.rad(5- 1 * math.cos(sine / 20))),.2)
					end



				end	

				for i = 1,3,.1 do
					if stopTA == false then
						swait()	
						RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.3- .03 * math.cos(sine / 20), -.2) * CFrame.Angles(math.rad(0- 1 * math.cos(sine / 20)),math.rad(10),math.rad(-20- 1 * math.cos(sine / 20))),.5)

					end


				end	

				toolAnim = "None"
				toolAon = false


			end
		end



		function LungeAnim()
			stopTA = true
			MoveArms = false		 

			swait(10)
			if toolAon == false then

				toolAon= true

				for i = 1,3,.1 do
					toolAon= true

					swait()		
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, 0.7- .03 * math.cos(sine / 20), -.2) * CFrame.Angles(math.rad(170- 1 * math.cos(sine / 20)),math.rad(0),math.rad(0- 1 * math.cos(sine / 20))),.1)




				end	

				for i = 1,2,.1 do
					swait()	
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, 0.5- .03 * math.cos(sine / 20), -.2) * CFrame.Angles(math.rad(30- 1 * math.cos(sine / 20)),math.rad(10),math.rad(-20- 1 * math.cos(sine / 20))),.2)


					toolAon= true	

				end	


				toolAnim = "None"
				toolAon = false
				stopTA = false
			end
		end




		function getTool()	
			for _, kid in ipairs(model:GetChildren()) do
				if kid.className == "Tool" then return kid end
			end
			return nil
		end
		function getToolAnim(tool)
			for _, c in ipairs(tool:GetChildren()) do
				if c.Name == "toolanim" and c.className == "StringValue" then
					return c
				end
			end
			return nil
		end
		function animateTool()

			if (toolAnim == "None") then
				if ToolMode == 1 then
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, 0.6- .03 * math.cos(sine / 20), -.2) * CFrame.Angles(math.rad(75- 1 * math.cos(sine / 20)),math.rad(20),math.rad(-15- 1 * math.cos(sine / 20))),.1)
				elseif  ToolMode == 2 then 
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.55- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(90- 1 * math.cos(sine / 20)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 20))),.1)	      
				elseif  ToolMode == 3 then  			
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.6- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(90 - 1 * math.cos(sine / 20)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 20))),.1)	      
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.6- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(90 - 1 * math.cos(sine / 20)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 20))),.1)	      			
				elseif  ToolMode == 4 then  
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), -.0) * CFrame.Angles(math.rad(0 - 1 * math.cos(sine / 20)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 20))),.1)	      
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), -.0) * CFrame.Angles(math.rad(0 - 1 * math.cos(sine / 20)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 20))),.1)	      
				elseif  ToolMode == 5 then     
					MoveArms = true		



				end		
				return
			end

			if (toolAnim == "Slash") then
				SlashAnim()

				return
			end

			if (toolAnim == "Lunge") then
				LungeAnim()
				return
			end
		end



		game:GetService'RunService'.Stepped:connect(function()

			sine = sine + change

			local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
			local velderp = RootPart.Velocity.y
			hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, model)


			if sprintmode == true then
				jp = 60
				ws = 24
			else	
				jp = 50
				ws = 6
			end

			if hitfloor ~= nil then
				inAir = true
			else
				inAir = false	
			end

			if inAir == true then
				if inAir2 == false then	


					JumpAfterEffect()

				end	
			end

			if hitfloor ~= nil then
				inAir2 = true
			else
				inAir2 = false	
			end
			--[

			if RootPart.Velocity.y > 1 and hitfloor == nil then
				Anim = "Jump"
			elseif RootPart.Velocity.y < -1 and hitfloor == nil then
				Anim = "Fall"
			elseif Humanoid.Sit == true then
				Anim = "Sit"	
			elseif torvel < 1 and hitfloor ~= nil then
				Anim = "Idle"
			elseif torvel > 2 and  hitfloor ~= nil then
				if sprintmode == true then
					Anim = "Run"
				else
					Anim = "Walk"
				end	
			else
				Anim = ""

			end



			--]]









			if attack == false then
				Humanoid.JumpPower=jp
				Humanoid.WalkSpeed=ws	

				local tool = getTool()
				if tool and tool:FindFirstChild("Handle") then

					MoveArms = false

					local animStringValueObject = getToolAnim(tool)

					if animStringValueObject then
						toolAnim = animStringValueObject.Value
						-- message recieved, delete StringValue
						animStringValueObject.Parent = nil

					end



					animateTool()	


					if ToolMode == 1 or ToolMode == 2 then
						if Anim == "Jump" then
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(20 -1* math.cos(sine / 10)),math.rad(0),math.rad(-5)),.3)
						elseif Anim == "Fall" then	
							LS.C0 = LS.C0:lerp(CFrame.new(-1.1, 1- .03 * math.cos(sine / 15), .3) * CFrame.Angles(math.rad(15 -1* math.cos(sine / 10)),math.rad(0),math.rad(-100)),.05)
						elseif Anim == "Idle" then
							if Gen == "Boy" then
								LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
							end
							if Gen == "Girl" then
								LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.3- .03 * math.cos(sine / 26),  .1) * CFrame.Angles(math.rad(6),math.rad(20),math.rad(23+ 0 * math.cos(sine / 25))),.1)
							end
						elseif Anim == "Sit" then
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						elseif Anim == "Walk" then
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(-30 * math.cos(sine / 7)),math.rad(0),math.rad(0)),.1)
						elseif Anim == "Run" then
							LS.C0 = LS.C0:lerp(CFrame.new(-1.49, 0.6, 0) * CFrame.Angles(math.rad(10+75*math.cos(sine / 4)), math.rad(5+-35*math.cos(sine / 4)), math.rad(-2+10*math.cos(sine / 4))), .3)
						else
							LS.C0 = LS.C0:lerp(CFrame.new(-1.3, 0.8, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-35)),.05)
						end
					end


				else
					MoveArms = true
				end


				--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				if Anim == "Jump" then
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					if MoveTH == true then
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15-3 * math.cos(sine / 15)),math.rad(0),math.rad(0)),.1)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, 1.3 +-.05 * math.cos(sine / 15)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.15)
					end
					if MoveArms == true then
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(20 +1* math.cos(sine / 10)),math.rad(0),math.rad(5)),.3)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(20 -1* math.cos(sine / 10)),math.rad(0),math.rad(-5)),.3)
					end
					if MoveLegs == true then
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.85+ .05 * math.cos(sine / 15), -.2) * CFrame.Angles(math.rad(-15 -1* math.cos(sine / 10)),math.rad(0),math.rad(0)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.35+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(-25 +1* math.cos(sine / 10)),math.rad(0),math.rad(0)),.2)
					end
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				elseif Anim == "Fall" then	
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					if MoveTH == true then		
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(25-3 * math.cos(sine / 15)),math.rad(0),math.rad(0)),.05)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0.3 +-.05 * math.cos(sine / 15)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.08)
					end
					if MoveArms == true then
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, 1- .03 * math.cos(sine / 15), .3) * CFrame.Angles(math.rad(15 +1* math.cos(sine / 10)),math.rad(0),math.rad(100)),.05)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, 1- .03 * math.cos(sine / 15), .3) * CFrame.Angles(math.rad(15 -1* math.cos(sine / 10)),math.rad(0),math.rad(-100)),.05)
					end
					if MoveLegs == true then
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.15+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(-15 -1* math.cos(sine / 10)),math.rad(0),math.rad(0)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.55+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(-0 +1* math.cos(sine / 10)),math.rad(0),math.rad(0)),.1)
					end
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				elseif Anim == "Sit" then
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					if MoveTH == true then
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					end
					if MoveArms == true then
						if Gen == "Girl" then
							RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.3- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-30- 1 * math.cos(sine / 20))),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.3, 0.3- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(30+ 1 * math.cos(sine / 20))),.1)
						end
						if Gen == "Boy" then
							RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), -.0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-0- 1 * math.cos(sine / 20))),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), -.0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0+ 1 * math.cos(sine / 20))),.1)
						end

					end
					if MoveLegs == true then
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.85+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.85+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)
					end
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				elseif Anim == "Idle" then
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					if Gen == "Girl" then

						if MoveTH == true then
							Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 25)),math.rad(-7 * math.cos(sine / 26)),math.rad(2 * math.cos(sine / 26))),.1)
							RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(.07 * math.cos(sine / 26), 0, -.1 +-.03 * math.cos(sine / 25)) * CFrame.Angles(math.rad(0),math.rad(4 * math.cos(sine / 26)),math.rad(-3 * math.cos(sine / 26))),.15)
						end
						if MoveArms == true then
							RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .01 * math.cos(sine / 25), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 2 * math.cos(sine / 26))),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.3- .03 * math.cos(sine / 26),  .1) * CFrame.Angles(math.rad(6),math.rad(20),math.rad(23+ 0 * math.cos(sine / 25))),.1)
						end
						if MoveLegs == true then
							RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 25), .02) * CFrame.Angles(math.rad(-3),math.rad(0),math.rad(2.5- 0.0 * math.cos(sine / 25)))*CFrame.new(0, -.03 * math.cos(sine / 26), 0-0.03 * math.cos(sine / 26)) * CFrame.Angles(math.rad(0.5 * math.cos(sine / 26)),math.rad(2 * math.cos(sine / 26)),math.rad(-4 * math.cos(sine / 26))),.15)
							LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 25), -.25) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 25)))*CFrame.new(0, .03 * math.cos(sine / 26), 0) * CFrame.Angles(math.rad(-0 -2 * math.cos(sine / 26)),math.rad(-20 +2 * math.cos(sine / 26)),math.rad(-4 * math.cos(sine / 26))),.15)
						end

					end





					if Gen == "Boy" then
						if MoveTH == true then
							Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
							RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
						end
						if MoveArms == true then
							RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						end
						if MoveLegs == true then
							RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
							LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)
						end







					end

					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				elseif Anim == "Walk" then
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					if Gen == "Girl" then

						if MoveTH == true then	
							Neck.C0 = Neck.C0:lerp(NeckCF * cf(0, 0, 0 + 0.025 * math.cos(sine / 3.5)) * CFrame.Angles(math.rad(0 - 1.5 * math.cos(sine / 3.5)), math.rad(5.5 * math.cos(sine / 7) ), math.rad(-7.5 * math.cos(sine / 7)) + RootPart.RotVelocity.Y / 14), 0.15)
							RJ.C0 = RJ.C0:lerp(RootCF * cf(0, 0, -0.075 + 0.025 * math.cos(sine / 3.5) + -math.sin(sine / 3.5) / 7) * CFrame.Angles(math.rad(3 - 2.5 * math.cos(sine / 3.5)), math.rad(-5 * math.cos(sine / 7)), math.rad(10 * math.cos(sine / 7))), 0.15)
						end
						if MoveArms == true then
							RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(30 * math.cos(sine / 7)),math.rad(0),math.rad(4 * math.cos(sine / 7))),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(-30 * math.cos(sine / 7)),math.rad(0),math.rad(4 * math.cos(sine / 7))),.1)
						end
						if MoveLegs == true then
							RH.C0 = RH.C0:lerp( cf(.5, -0.925 - 0.5 * math.cos(sine / 7) / 2,-0.1+ 0.5 * math.cos(sine / 7) / 2) * CFrame.Angles(math.rad(-7.5 - 15 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(90 - 10 * math.cos(sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 + 2.5 * math.cos(sine / 7)), math.rad(-90), math.rad(5 * math.cos(sine / 7))), 0.15)
							LH.C0 = LH.C0:lerp( cf(-.5, -0.925 + 0.5 * math.cos(sine / 7) / 2,-0.1+ -0.5 * math.cos(sine / 7) / 2) * CFrame.Angles(math.rad(-7.5 + 15 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(-90 - 10 * math.cos(sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 - 2.5 * math.cos(sine / 7)), math.rad(90), math.rad(5 * math.cos(sine / 7))), 0.15)
						end	

					end


					if Gen == "Boy" then
						if MoveTH == true then	
							Neck.C0 = Neck.C0:lerp(NeckCF * cf(0, 0, 0 + 0.025 * math.cos(sine / 3.5)) * CFrame.Angles(math.rad(0 - 1.5 * math.cos(sine / 3.5)), math.rad(1.5 * math.cos(sine / 7) ), math.rad(-7.5 * math.cos(sine / 7)) + RootPart.RotVelocity.Y / 14), 0.15)
							RJ.C0 = RJ.C0:lerp(RootCF * cf(0, 0, -0.075 + 0.025 * math.cos(sine / 3.5) + -math.sin(sine / 3.5) / 7) * CFrame.Angles(math.rad(3 - 2.5 * math.cos(sine / 3.5)), math.rad(0), math.rad(10 * math.cos(sine / 7))), 0.15)
						end
						if MoveArms == true then
							RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(30 * math.cos(sine / 7)),math.rad(0),math.rad(-0)),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(-30 * math.cos(sine / 7)),math.rad(0),math.rad(0)),.1)
						end
						if MoveLegs == true then
							RH.C0 = RH.C0:lerp( cf(.5, -0.925 - 0.5 * math.cos(sine / 7) / 2,-0.1+ 0.5 * math.cos(sine / 7) / 2) * CFrame.Angles(math.rad(-7.5 - 15 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(90 - 10 * math.cos(sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 + 2.5 * math.cos(sine / 7)), math.rad(-90), math.rad(0)), 0.15)
							LH.C0 = LH.C0:lerp( cf(-.5, -0.925 + 0.5 * math.cos(sine / 7) / 2,-0.1+ -0.5 * math.cos(sine / 7) / 2) * CFrame.Angles(math.rad(-7.5 + 15 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(-90 - 10 * math.cos(sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 - 2.5 * math.cos(sine / 7)), math.rad(90), math.rad(0)), 0.15)
						end
					end
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				elseif Anim == "Run" then
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

					if MoveTH == true then	
						Neck.C0 = Neck.C0:lerp(NeckCF * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(-8.5 * math.cos(sine / 4)) + RootPart.RotVelocity.Y / 14), .3)
						RJ.C0 = RJ.C0:lerp(RootCF * cf(0, 0, -0.1 + 0.15 * math.cos(sine / 3)) * CFrame.Angles(math.rad(15), math.rad(0) + RootPart.RotVelocity.Y / 30, math.rad(10 * math.cos(sine / 4))), .4)
					end
					if MoveArms == true then
						RS.C0 = RS.C0:lerp(CFrame.new(1.49, 0.62, .3*math.cos(sine / 4)) * CFrame.Angles(math.rad(10+-75*math.cos(sine / 4)), math.rad(5+-35*math.cos(sine / 4)), math.rad(2+10*math.cos(sine / 4))), .3)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.49, 0.62, -.3*math.cos(sine / 4)) * CFrame.Angles(math.rad(10+75*math.cos(sine / 4)), math.rad(5+-35*math.cos(sine / 4)), math.rad(-2+10*math.cos(sine / 4))), .3)
					end
					if MoveLegs == true then
						RH.C0 = RH.C0:lerp( cf(.5, -1.0 - -0.3 * math.cos(sine / 4), -.1 - 0.1 * math.cos(sine / 4)) * CFrame.Angles(math.rad(-10 + 50 * math.cos(sine / 4)), math.rad(0), math.rad(2)), .4)
						LH.C0 = LH.C0:lerp( cf(-.5, -1.0 + -0.3 * math.cos(sine / 4), -.1 + 0.1 * math.cos(sine / 4)) * CFrame.Angles(math.rad(10 -50 * math.cos(sine / 4)), math.rad(0), math.rad(-2)), .4)
					end


--[[

					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.15 * math.cos(sine / 3)) * angles(math.rad(15), math.rad(0) + RootPart.RotVelocity.Y / 30, math.rad(10 * math.cos(sine / 4))), .5)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(-8.5 * math.cos(sine / 4)) + RootPart.RotVelocity.Y / 9), .4)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(10+-75*math.cos(sine / 4)), math.rad(5+-35*math.cos(sine / 4)), math.rad(2+10*math.cos(sine / 4))), .4)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10+75*math.cos(sine / 4)), math.rad(5+-35*math.cos(sine / 4)), math.rad(-2+10*math.cos(sine / 4))), .4)
					RH.C0 = clerp(RH.C0, cn(1, -1.0 - -0.3 * math.cos(sine / 4), -.1 - 0.1 * math.cos(sine / 4)) * RHCF * angles(math.rad(-2), math.rad(0), math.rad(-10 + 50 * math.cos(sine / 4))), .5)
					LH.C0 = clerp(LH.C0, cn(-1, -1.0 + -0.3 * math.cos(sine / 4), -.1 + 0.1 * math.cos(sine / 4)) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(10 +50 * math.cos(sine / 4))), .5)



--]]







				else
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
					--                   If anim is an false value so errors will not come
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.8, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(35)),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.3, 0.8, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-35)),.05)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(10)),.05)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-10)),.05)
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				end
			end

			if Humanoid.Health < 0.1 and attack == false then
				attack = true 


				for i = 1,3,.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.07)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -1, -1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.07)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(1),math.rad(0),math.rad(10)),.07)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-10)),.07)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.07)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.07)



				end
				for i = 1,15,.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.07)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -2, -2.5) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),.07)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(180),math.rad(0),math.rad(0)),.07)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-20)),.07)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(5)),.07)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-5)),.07)



				end
				Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
				Humanoid.Health = 0
			end

		end)








		mouse.KeyDown:connect(function(k)
			if k == "0" and attack == false then	
				sprintmode=true	
			end
			if k == "9" and attack == false then	
				if Gen == "Boy" then
					Gen = "Girl"
				else
					Gen = "Boy"	
				end
				print(Gen.." Anims")
			end
			if k == "8" and attack == false then	

				ToolMode = ToolMode + 1	

				if ToolMode >5 then

					ToolMode = 1	
				end
				print("Tool Anim "..ToolMode)
			end


		end)
		mouse.KeyUp:connect(function(k)
			if k == "0" and attack == false then	
				sprintmode=false	
			end

		end)

		mouse.KeyDown:connect(function(k)

			if k == "t" and attack == false then	
				local Song = Instance.new("Sound", Torso)
				Song.SoundId  = "http://www.roblox.com/asset/?id=748575516"


				Song.Volume = 10

				attack= true
				--[






				Song:Play()
				Humanoid.JumpPower=0
				Humanoid.WalkSpeed=0	
				for i = 0,3,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.05)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.05)

				end
				for i = 0,2,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .9, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .9, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.05)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.05)

				end
				for i = 0,3,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.05)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.05)

				end
				for i = 0,10,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, .5, 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(50)),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.25, .5, 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-50)),.05)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.05)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.05)

				end
				for i = 0,12,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(60),math.rad(0),math.rad(0)),.02)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.02)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),.02)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(-0)),.02)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.02)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.02)

				end
				for i = 0,15,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.01)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.02)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.01)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.01)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.02)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.02)

				end

				for i = 1,2 do
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(1, 0, -0) * CFrame.Angles(math.rad(5),math.rad(10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(-40)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(-10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-1, 0, -0) * CFrame.Angles(math.rad(5),math.rad(-10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(40)),.2)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
				end
				for i = 0,5.25,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.1)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 2, -2.2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(0)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(-0)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.6, -.4) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.1)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.6, -.4) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.1)

				end
				for i = 0,0.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.1)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.3) * CFrame.Angles(math.rad(130),math.rad(0),math.rad(0)),.3)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(0)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(-0)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.6, -.4) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.6, -.4) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-4)),.3)

				end
				for i = 0,0.2,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.1)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.4) * CFrame.Angles(math.rad(125),math.rad(0),math.rad(0)),.3)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(0)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(-0)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.6, -.4) * CFrame.Angles(math.rad(85),math.rad(0),math.rad(4)),.1)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.6, -.4) * CFrame.Angles(math.rad(85),math.rad(0),math.rad(-4)),.1)

				end
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.1)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.3) * CFrame.Angles(math.rad(130),math.rad(0),math.rad(0)),.3)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(0)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(-0)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.6, -.4) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.6, -.4) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-4)),.3)

				end
				for i = 1,2 do
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(1, 0, -0) * CFrame.Angles(math.rad(-25),math.rad(10),math.rad(180)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(-40)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.8, -.3) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.8, -.3) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(180)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.4) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.4) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(-10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-1, 0, -0) * CFrame.Angles(math.rad(-25),math.rad(-10),math.rad(180)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(40)),.2)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.8, -.3) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.8, -.3) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(180)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.4) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.4) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(-4)),.3)

					end
				end

				for i = 0,3,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0.2) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, .5, 0) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(-20)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.3, .5, 0) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(20)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.8, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.8, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

				end
				local Model2 = Instance.new("Model", model)
				game:GetService("Debris"):AddItem(Model2, 20)	
				local Rleg2 = Instance.new("Part", Model2)
				local Lleg2 = Instance.new("Part", Model2)
				local NewPantsHum = Instance.new("Humanoid", Model2)
				Rleg2.Size = RightLeg.Size
				Rleg2.BrickColor = RightLeg.BrickColor
				Rleg2.CFrame = RightLeg.CFrame
				Rleg2.Name = RightLeg.Name
				Lleg2.Size = LeftLeg.Size
				Lleg2.BrickColor = LeftLeg.BrickColor
				Lleg2.CFrame = LeftLeg.CFrame
				Lleg2.Name = LeftLeg.Name

				Lleg2.CanCollide = false	
				Rleg2.CanCollide = false
				coroutine.resume(coroutine.create(function()	

					for _,v in pairs(model:GetChildren()) do
						if v:isA("Pants") then
							v:Clone().Parent = Model2 	
						end
						if v:isA("CharacterMesh") then
							v:Clone().Parent = Model2 	
						end		

					end

				end))

				local RLW = Instance.new("Weld")
				RLW.Name = "Pants Weld"
				RLW.Part0 = RightLeg 
				RLW.C0 = cn(0, 0, 0)
				RLW.C1 = cn(0, 0, 0) 
				RLW.Part1 = Rleg2
				RLW.Parent = RightLeg 
				local LLW = Instance.new("Weld")
				LLW.Name = "Pants Weld"
				LLW.Part0 = LeftLeg 
				LLW.C0 = cn(0, 0, 0)
				LLW.C1 = cn(0, 0, 0) 
				LLW.Part1 = Lleg2
				LLW.Parent = LeftLeg 
				game:GetService("Debris"):AddItem(RLW, 4)	
				game:GetService("Debris"):AddItem(LLW, 4)	

				local lval = 0
				for i = 0,3,0.1 do
					swait()
					lval = .5*i/1.5
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0+lval*4) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(-0)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(0)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(lval, -1, -0) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-lval, -1, -0) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)


					Rleg2.Size = RightLeg.Size*i
					Lleg2.Size = LeftLeg.Size*i
					local RLW = Instance.new("Weld")
					RLW.Name = "Pants Weld"
					RLW.Part0 = RightLeg 
					RLW.C0 = cn(0, 0-i/1.51, 0)
					RLW.C1 = cn(0, 0, 0) 
					RLW.Part1 = Rleg2
					RLW.Parent = RightLeg 
					local LLW = Instance.new("Weld")
					LLW.Name = "Pants Weld"
					LLW.Part0 = LeftLeg 
					LLW.C0 = cn(0, 0-i/1.51, 0)
					LLW.C1 = cn(0, 0, 0) 
					LLW.Part1 = Lleg2
					LLW.Parent = LeftLeg 
					game:GetService("Debris"):AddItem(RLW, 4)	
					game:GetService("Debris"):AddItem(LLW, 4)	
				end



				for i = 1,2 do
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(1, 0, -0+lval*4) * CFrame.Angles(math.rad(5),math.rad(10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(-40)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2+lval*4) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(-10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-1, 0, -0+lval*4) * CFrame.Angles(math.rad(5),math.rad(-10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(40)),.2)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2+lval*4) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
				end
				for i = 1,6 do
					for i = 0,.6,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(1, 0, 0+lval*4) * CFrame.Angles(math.rad(5),math.rad(10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(-40)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,.2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2+lval*4) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,.6,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(-10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-1, 0, -0+lval*4) * CFrame.Angles(math.rad(5),math.rad(-10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(40)),.2)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,.2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2+lval*4) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
				end

				for i = 1,2 do
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(1, 0, -0) * CFrame.Angles(math.rad(5),math.rad(10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(-40)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,.8,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(-10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-1, 0, -0) * CFrame.Angles(math.rad(5),math.rad(-10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(40)),.2)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,.8,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
				end

				for i = 0,2.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-45)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(45)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.5, -0.3) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.2)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.5, -0.3) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.2)

				end
				for i = 0,3.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
					LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

				end
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, 1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(180)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
					LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

				end
				for i = 0,2,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(180)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
					LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

				end

				for i = 1,3 do
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(1, 0, -1) * CFrame.Angles(math.rad(-0),math.rad(45),math.rad(180)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(180)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end


					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-1, 0, -1) * CFrame.Angles(math.rad(-0),math.rad(-45),math.rad(180)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end

					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(180)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end

				end

				for i = 0,2,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
					LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

				end
				for i = 1,2 do
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(2.3, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(45)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end	
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(2, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(45)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end

					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-2.3, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-45)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-2, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-45)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end

				end

				for i = 0,3.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.05)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.05)

				end

				for i = 1,4 do
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-75),math.rad(0),math.rad(10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(.5, 0, -0) * CFrame.Angles(math.rad(5),math.rad(5),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5, -.2) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(10)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-10)),.5)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0.3) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.5)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.7, -.1) * CFrame.Angles(math.rad(-1),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.7, -.1) * CFrame.Angles(math.rad(-1),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-75),math.rad(0),math.rad(-10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-.5, 0, -0) * CFrame.Angles(math.rad(5),math.rad(-5),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(10)),.5)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5, -.2) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(-10)),.2)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0.3) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.5)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.7, -.1) * CFrame.Angles(math.rad(-1),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.7, -.1) * CFrame.Angles(math.rad(-1),math.rad(0),math.rad(-4)),.3)

					end
				end

				for i = 1,14 do
					for i = 0,.3,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20),math.rad(0),math.rad(5)),.4)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(.5, 0, -0) * CFrame.Angles(math.rad(20),math.rad(15),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5, -.2) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(10)),.5)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-10)),.5)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(14)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-14)),.3)

					end
					for i = 0,.1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),.4)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0.3) * CFrame.Angles(math.rad(27),math.rad(0),math.rad(0)),.5)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.3)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.3)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.7, -.1) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(14)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.7, -.1) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-14)),.3)

					end
					for i = 0,.3,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20),math.rad(0),math.rad(-5)),.4)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-.5, 0, -0) * CFrame.Angles(math.rad(20),math.rad(-15),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(10)),.5)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5, -.2) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(-10)),.5)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(14)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-14)),.3)

					end
					for i = 0,.1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),.4)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0.3) * CFrame.Angles(math.rad(27),math.rad(0),math.rad(0)),.5)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.3)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.3)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.7, -.1) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(14)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.7, -.1) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-14)),.3)

					end
				end
				--]]
				local Paper = Instance.new("Part", model)


				Paper.Size = Vector3.new(0.1,1,1.5)
				Paper.BrickColor = BrickColor.new("White")
				Paper.CFrame = RightArm.CFrame
				Paper.Name = "Note"

				local PLW = Instance.new("Weld")
				PLW.Name = "Shirt Weld"
				PLW.Part0 = RightArm 
				PLW.C0 = cn(0, -1, 0)*CFrame.Angles(math.rad(0),math.rad(-0),math.rad(-45))
				PLW.C1 = cn(0, 0, 0) 
				PLW.Part1 = Paper
				PLW.Parent = RightArm 

				game:GetService("Debris"):AddItem(PLW, 1.6)	
				game:GetService("Debris"):AddItem(Paper, 3)



				for i = 0,8,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),.5)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.5)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, .5, -.3) * CFrame.Angles(math.rad(75),math.rad(0),math.rad(-30)),.5)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.5)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.5)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.5)

				end
				PLW.C0 = cn(0, -1, 0)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(-0))
				for i = 0,2,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(10)),.3)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.5)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.4) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-50)),.3)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.5)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.5)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.5)

				end

				local bodyVelocity = Create("BodyVelocity")({velocity = Vector3.new(0, 10, 0)+Paper.CFrame.lookVector*50, P = 5000, maxForce = Vector3.new(8000, 8000, 8000), Parent = Paper})
				game:GetService("Debris"):AddItem(bodyVelocity, 0.1)
				for i = 0,3,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(-30)),.5)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.5)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, -.0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(45)),.5)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.5)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.5)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.5)

				end


				local Model2 = Instance.new("Model", model)
				game:GetService("Debris"):AddItem(Model2, 20)	
				local Rleg2 = Instance.new("Part", Model2)

				local NewShirtHum = Instance.new("Humanoid", Model2)
				Rleg2.Size = Torso.Size
				Rleg2.BrickColor = Torso.BrickColor
				Rleg2.CFrame = Torso.CFrame
				Rleg2.Name = Torso.Name

				Rleg2.CanCollide = false
				coroutine.resume(coroutine.create(function()	

					for _,v in pairs(model:GetChildren()) do
						if v:isA("Shirt") then
							v:Clone().Parent = Model2 	
						end
						if v:isA("CharacterMesh") then
							v:Clone().Parent = Model2 	
						end		

					end

				end))

				local RLW = Instance.new("Weld")
				RLW.Name = "Shirt Weld"
				RLW.Part0 = Torso 
				RLW.C0 = cn(0, 0, 0)
				RLW.C1 = cn(0, 0, 0) 
				RLW.Part1 = Rleg2
				RLW.Parent = Torso 
				Torso.Transparency = 1
				game:GetService("Debris"):AddItem(RLW, 4)	



				local TorH = 0

				for i = 0,3,0.1 do
					swait()
					TorH =  i

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.5)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5+TorH, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.3)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5+TorH, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)

					Rleg2.Size = Vector3.new(Torso.Size.x,Torso.Size.y+i,Torso.Size.z)
					local RLW = Instance.new("Weld")
					RLW.Name = "Shirt Weld"
					RLW.Part0 = Torso 
					RLW.C0 = cn(0, 0+i/2, 0)
					RLW.C1 = cn(0, 0, 0) 
					RLW.Part1 = Rleg2
					RLW.Parent = Torso 
					Torso.Transparency = 1
					game:GetService("Debris"):AddItem(RLW, 14)
				end

				for i = 0,1,0.1 do
					swait()
					Torso.Transparency = 1

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5+TorH, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5+TorH, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end

				for i = 1,4 do
					for i = 0,1.7,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(1)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(2),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5+TorH, -.2) * CFrame.Angles(math.rad(120),math.rad(0),math.rad(-40)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5+TorH, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,.5,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5+TorH, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5+TorH, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1.7,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-1)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(-2),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5+TorH, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5+TorH, -.2) * CFrame.Angles(math.rad(120),math.rad(0),math.rad(40)),.2)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,.5,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5+TorH, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5+TorH, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)

					end
				end
				for i = 0,1.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5+TorH, 0) * CFrame.Angles(math.rad(120),math.rad(0),math.rad(-10)),.3)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5+TorH, 0) * CFrame.Angles(math.rad(120),math.rad(0),math.rad(-10)),.3)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.2) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.2) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-4)),.3)

				end
				for i = 0,1.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5+TorH, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5+TorH, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-4)),.3)

				end
				for i = 0,1.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5+TorH, 0) * CFrame.Angles(math.rad(120),math.rad(0),math.rad(-10)),.3)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5+TorH, 0) * CFrame.Angles(math.rad(120),math.rad(0),math.rad(-10)),.3)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.2) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.2) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-4)),.3)

				end
				for i = 0,1.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5+TorH, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5+TorH, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-4)),.3)

				end
				Torso.Transparency = 0
				coroutine.resume(coroutine.create(function()	
					Model2:Destroy()	
					Torso.Transparency = 0	


				end))
				--]]
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)

				end






				coroutine.resume(coroutine.create(function()	
					Torso.Transparency = 0
					Head.Transparency = 0
					RightArm.Transparency = 1
					LeftArm.Transparency = 1
					RightLeg.Transparency = 1
					LeftLeg.Transparency = 1

				end))

				local TorColor = nil
				TorColor=Torso.BrickColor

				coroutine.resume(coroutine.create(function()
					TorColor = model["Body Colors"].TorsoColor
				end))
				local NewTorsoMesh= Instance.new("SpecialMesh", Torso)
				NewTorsoMesh.MeshId = "rbxassetid://502406430"
				NewTorsoMesh.Scale = Vector3.new(3,3,2)




				Torso.BrickColor = BrickColor.new("New Yeller")
				coroutine.resume(coroutine.create(function()

					model["Body Colors"].TorsoColor = BrickColor.new("New Yeller")
				end))

				for i = 0,3,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)

				end
				--Front
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -2, -0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				--Front
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -2, -0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end

				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -2, -0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -2, -0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -2, -0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				--Left
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(2, -0, -0) * CFrame.Angles(math.rad(0),math.rad(45),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end



				--Right
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-2, -0, -0) * CFrame.Angles(math.rad(0),math.rad(-45),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end



				for i = 0,55,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, 5+.5 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(i*25)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end



				coroutine.resume(coroutine.create(function()
					NewTorsoMesh:Destroy()





				end))
				Torso.BrickColor = TorColor

				coroutine.resume(coroutine.create(function()

					model["Body Colors"].TorsoColor = TorColor

				end))
				coroutine.resume(coroutine.create(function()	
					Torso.Transparency = 0
					Head.Transparency = 0
					RightArm.Transparency = 0
					LeftArm.Transparency = 0
					RightLeg.Transparency = 0
					LeftLeg.Transparency = 0

				end))

				attack= false	
				Humanoid.JumpPower=jp
				Humanoid.WalkSpeed=ws	
				Song:Destroy()
			end



			if k == " " and canstoptuant1 == true then	
				wait(.3)
				print(1)
				stoptuant1 = true	
				Humanoid.JumpPower=jp
				Humanoid.WalkSpeed=ws		


			end



			if k == "b"  and attack == false then
				attack = true
				Humanoid.JumpPower=0
				Humanoid.WalkSpeed=0.01	
				local GunPart = Instance.new("Part",model)	
				GunPart.Transparency = 0
				GunPart.CanCollide = false
				GunPart.Anchored = false
				GunPart.CFrame = CFrame.new(0,0,0)
				GunPart.Size = Vector3.new(0.85,.85,.05)
				GunPart.Material = "Neon"
				GunPart.BrickColor = BrickColor.new("Shamrock")
				local GunPartWeld = Instance.new("Weld",GunPart)	
				GunPartWeld.C0 = CFrame.new(0,0,0.99) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
				GunPartWeld.Part0 = GunPart
				GunPartWeld.Part1 = RightArm


				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-10)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(10)),.15)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end



				for i = 1,1 do
					for i = 0,1.5,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-10)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(10)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	






					coroutine.resume(coroutine.create(function()	

						local Glow1 = Color3.new(0,1,0)
						local Glow2 = Color3.new(0,1,0)
						local hitray,pos = rayCast(GunPart.Position, GunPart.CFrame.lookVector, 5000, model)

						so("138335183", RightArm, 10, .9)

						local WalkPart = Instance.new("Part",model)	
						WalkPart.Transparency = 1
						WalkPart.CanCollide = false
						WalkPart.Anchored = true
						WalkPart.CFrame = CFrame.new(0,0,0)
						WalkPart.Size = Vector3.new(.1,.1,.1)
						local WalkPart2 = Instance.new("Part",model)	
						WalkPart2.Transparency = 1
						WalkPart2.CanCollide = false
						WalkPart2.Anchored = true
						WalkPart2.CFrame = GunPart.CFrame
						WalkPart2.Size = Vector3.new(.1,.1,.1)

						local Attach1 = Instance.new("Attachment",WalkPart2)	
						local Attach2 = Instance.new("Attachment",WalkPart)	
						local Beam1 = Instance.new("Beam",WalkPart)	
						Attach2.Position = pos
						Attach1.Position = Vector3.new(0,0,0)


						Beam1.Texture = "rbxassetid://1134824633"
						Beam1.Width0 = .0
						Beam1.Width1 = .0
						Beam1.FaceCamera = true	
						Beam1.Color = ColorSequence.new(Glow1,Glow2)
						Beam1.Transparency = NumberSequence.new(0,0)
						Beam1.TextureLength = 1
						Beam1.Attachment0 = Attach1
						Beam1.Attachment1 = Attach2
						Beam1.TextureSpeed = 10
						Beam1.LightEmission = 1





						local HitModel = nil



						if hitray ~= nil then
							HitModel = hitray.Parent

							if hitray.Parent:isA("Accessory") or hitray.Parent:isA("Hat") then
								HitModel = hitray.Parent.Parent	
							end
						end			
						local HasHum = false
						local ModelCanSlap = false
						local slaped2 = nil
						coroutine.resume(coroutine.create(function()	

							for _,v in pairs(HitModel:GetChildren()) do
								if v:isA("Humanoid") then
									v.Parent:BreakJoints()
									v.Health = 0
								end

							end

						end))



						coroutine.resume(coroutine.create(function()	
							if hitray ~= nil then

								local HitEffectPart = Instance.new("Part",model)		

								HitEffectPart.Transparency = 1
								HitEffectPart.CanCollide = false
								HitEffectPart.Anchored = true
								HitEffectPart.CFrame =CFrame.new(0,0,0)+pos
								HitEffectPart.Size = Vector3.new(.05,.05,.05)


								local NewParticEffect1=ParticEffect1:Clone()
								NewParticEffect1.Parent=	HitEffectPart


								game:GetService("Debris"):AddItem(HitEffectPart, 5)	
								coroutine.resume(coroutine.create(function()	
									for i = 1,0,-0.1 do
										wait()
										NewParticEffect1.Rate = i*100
									end

								end))
							end

							for i = 0,1,0.1 do
								swait(.7)
								Beam1.Transparency = NumberSequence.new(i,i)

								GunPart.Transparency = i*1.5
								GunPart.Size = Vector3.new(0.85-i,.85-i,.05)
								local GunPartWeld = Instance.new("Weld",GunPart)	
								GunPartWeld.C0 = CFrame.new(0,0,0.99) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
								GunPartWeld.Part0 = GunPart
								GunPartWeld.Part1 = RightArm
								Beam1.Width0 = 1 - i
								Beam1.Width1 = 1 - i



							end
							game:GetService("Debris"):AddItem(GunPart, .4)
							game:GetService("Debris"):AddItem(WalkPart2, .4)	
							game:GetService("Debris"):AddItem(WalkPart, .4)	
							game:GetService("Debris"):AddItem(Attach1, .4)	
							game:GetService("Debris"):AddItem(Attach2, .4)	

						end))








					end))
					for i = 0,1,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-10)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), .2) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	
					so("165487479", Torso, 9, 1)	
					for i = 0,2,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-10)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(10)),.05)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	

					for i = 0,3,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-40)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(40)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(180),math.rad(0),math.rad(10)),.05)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	

					for i = 0,2,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-20)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(20)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(40),math.rad(0),math.rad(-10)),.05)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	

					for i = 0,2,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-20)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),.15)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	
					for i = 0,.5,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-20)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.6- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	
					for i = 0,.5,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-20)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.4- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	
					for i = 0,2,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),.3)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end		
				end
				attack = false	
			end





			if k == "f" then	
				local hitray = rayCast(RootPart.Position, RootPart.CFrame.lookVector, 6, model)
				local HitModel = nil



				if hitray ~= nil then
					HitModel = hitray.Parent

					if hitray.Parent:isA("Accessory") or hitray.Parent:isA("Hat") then
						HitModel = hitray.Parent.Parent	
					end
				end			
				local HasHum = false
				local ModelCanSlap = false
				local slaped2 = nil
				coroutine.resume(coroutine.create(function()	

					for _,v in pairs(HitModel:GetChildren()) do
						if v:isA("Humanoid") then
							HasHum = true	
						end
						if v:isA("BoolValue")then if v.Name == "Slap" and v.Value == false then
								ModelCanSlap= true	
								slaped2 = v
							end	
						end


					end

				end))



				if canstoptuant1 == false and attack == false then


					canstoptuant1 = true
					attack = true
					Humanoid.JumpPower=0
					Humanoid.WalkSpeed=0	

					local slaped = Instance.new("BoolValue",model)
					slaped.Name = "Slap"
					for i = 0,0.5,0.1 do
						swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end


					if HasHum == true and 	ModelCanSlap == true and slaped2 ~= nil  then
					else
						so("887591869", Torso, 10, 1)		

					end

					while   slaped.Value == false do


						swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(10)),.1)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(10- 1 * math.cos(sine / 20))),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-3+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)
						if stoptuant1 == true then
							slaped.Value = true
						end

						if HasHum == true and 	ModelCanSlap == true and slaped2 ~= nil  then


							if HitModel:FindFirstChild("HumanoidRootPart")	 then



								local rainto = HitModel.HumanoidRootPart.CFrame.lookVector*0
								local rainto2 = CFrame.new(0,0,0) * HitModel.HumanoidRootPart.CFrame.lookVector*3.5
								local rainpos = HitModel.HumanoidRootPart.CFrame	
								rainto = rainto + rainto2	



								local Laserpart = Instance.new("Part",model)

								Laserpart.Size = Vector3.new(.1,.1,.1)
								Laserpart.CanCollide = false
								Laserpart.Transparency = 1
								Laserpart.Anchored = true
								Laserpart.CFrame = rainpos* cn(0,0, 0)+rainto	
								game:GetService("Debris"):AddItem(Laserpart, .05)	




								RootPart.CFrame = Laserpart.CFrame * CFrame.Angles(math.rad(-0),math.rad(180),math.rad(0))

							end

							slaped.Value = true
							slaped2.Value = true



						end


					end
					canstoptuant1 = false
					if slaped.Value == true and stoptuant1 == false then



						for i = 0,4,.1 do
							swait()

							Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(10)),.1)
							RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),.15)
							RS.C0 = RS.C0:lerp(CFrame.new(1.4, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(10- 1 * math.cos(sine / 20))),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-3+ 1 * math.cos(sine / 20))),.1)
							RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
							LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)
						end	



						for i = 0,2,.1 do
							swait()

							Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(20)),.1)
							RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-20)),.15)
							RS.C0 = RS.C0:lerp(CFrame.new(1.35, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(210),math.rad(0),math.rad(20- 1 * math.cos(sine / 20))),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-3+ 1 * math.cos(sine / 20))),.1)
							RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
							LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)


						end	
						so("146163534", Torso, 10, 1.3)
						for i = 0,2,0.1 do
							swait()

							Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(-60)),.3)
							RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-.05, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),.3)
							RS.C0 = RS.C0:lerp(CFrame.new(1.4, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(135),math.rad(90),math.rad(0- 1 * math.cos(sine / 20))),.5)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-3+ 1 * math.cos(sine / 20))),.1)
							RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
							LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-5.5+ .1 * math.cos(sine / 20))),.15)


						end	

						stoptuant1 = false	
					else
						stoptuant1 = false
					end







					attack = false	
					coroutine.resume(coroutine.create(function()	
						slaped:Destoy()
					end))



				end



















			end





			if k == "g" and canstoptuant1 == false and attack == false and MenyOpen == false then	
				attack = true
				canstoptuant1 = true 
				MenyOpen = true
				local stillwaiting = true
				print("Fet Tuant stuff")
				while stillwaiting == true  do swait()
					Humanoid.JumpPower=0
					Humanoid.WalkSpeed=0
					-- canstoptuant1 


					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)


					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)

					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)


					if stoptuant1 == true then	
						stillwaiting = false	

					end


				end


				canstoptuant1 = false
				stoptuant1 = false


				if MenyOpen == true then
					attack = false
					MenyOpen = false
					print("Closed Tuant stuff")
				end
			end

--[[

if k == "" and  MenyOpen == true and canstoptuant1 == true then
MenyOpen = false
stoptuant1 = true


attack = false	
end





for i = 0,6,.1 do swait()
Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

end



--]]


			-- so("285615370", Torso, 1, 1,17)

			if k == "e" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true

				for i = 0,2,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15+2 * math.cos(sine / 20)),math.rad(0),math.rad(-15)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, 0.6- .03 * math.cos(sine / 20), -.3) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(-50- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				so("666675542", Torso, 10, 1)
				for i = 0,3,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15+2 * math.cos(sine / 20)),math.rad(0),math.rad(-15)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, 0.6- .03 * math.cos(sine / 20), -.3) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(-50- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,6,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+6 * math.cos(sine / 3)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-23+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.2)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(-3),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-3),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-3),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end


				attack = false	
			end



			if k == "q" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("145303015", Torso, 10, 1,25)


				for i = 0,2,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(150+1 * math.cos(sine / 20)),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end




				for i = 0,10,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 4)),math.rad(0),math.rad(20)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(180+5 * math.cos(sine / 3)),math.rad(0),math.rad(-15- 0 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end



				for i = 0,3,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,36,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+4 * math.cos(sine / 3)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,10,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-13+4 * math.cos(sine / 3)),math.rad(0),math.rad(30)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,10,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-6+4 * math.cos(sine / 3)),math.rad(0),math.rad(00)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(6+4 * math.cos(sine / 3)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,10,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-6+4 * math.cos(sine / 3)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(6+4 * math.cos(sine / 3)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(60),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(6+4 * math.cos(sine / 3)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(60),math.rad(0),math.rad(-45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end








				attack = false	
			end


			if k == "r" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true

				for i = 0,3,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				so("1058417264", Torso, 10, 1)
				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2.5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				--so("593142105", Torso, 10, .8)
				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-8+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(98),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end








				attack = false	
			end




			if k == "p" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("252252871", Torso, 10, 1,9)
				-- 10 sec start
				for i = 0,3,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0+20 * math.cos(sine / 20*2)),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(1),math.rad(0),math.rad(10- 1 * math.cos(sine / 20))),1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(1),math.rad(0),math.rad(-10+ 1 * math.cos(sine / 20))),1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(10.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-10.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,2,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, 3.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0+0 * math.cos(sine / 20*2)),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(180),math.rad(0),math.rad(0- 1 * math.cos(sine / 20))),1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(180),math.rad(0),math.rad(-0+ 1 * math.cos(sine / 20))),1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0.5- .1 * math.cos(sine / 20))),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-0.5+ .1 * math.cos(sine / 20))),.3)

				end

				for i = 0,5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0+20 * math.cos(sine / 20*2)),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10- 1 * math.cos(sine / 20))),1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10+ 1 * math.cos(sine / 20))),1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(10.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-10.5+ .1 * math.cos(sine / 20))),.15)

				end

				local Paper = Instance.new("Part", model)

				local PaperMesh = Instance.new("SpecialMesh", Paper)
				PaperMesh.MeshId = "http://www.roblox.com/asset/?id=40312463"
				PaperMesh.TextureId = "http://www.roblox.com/asset/?id=40311968"
				PaperMesh.Scale =  Vector3.new(2.2, 2.2, 2.2)
				Paper.Size = Vector3.new(1,1,1)
				Paper.BrickColor = BrickColor.new("White")
				Paper.CFrame = RightArm.CFrame
				Paper.Name = "Pie"

				local PLW = Instance.new("Weld")
				PLW.Name = "Pie Weld"
				PLW.Part0 = Head 
				PLW.C0 = cn(0, -0, -.7)*CFrame.Angles(math.rad(-10),math.rad(-0),math.rad(-0))
				PLW.C1 = cn(0, 0, 0) 
				PLW.Part1 = Paper
				PLW.Parent = RightArm 

				game:GetService("Debris"):AddItem(PLW, 10000)	
				game:GetService("Debris"):AddItem(Paper, 6)

				for i = 0,6,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-0+10 * math.cos(sine / 2)),math.rad(0),math.rad(i*100)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,7,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-40+2 * math.cos(sine / 20)),math.rad(0+10 * math.cos(sine / 1)),math.rad(0)),.4)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.4)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(i*200),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.4)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-i*200),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.4)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(i*200),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.4)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-i*200),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.4)

				end
				local explosionRadius = 0 -- Radius of 12 currently
				local explosionPressure = 0 -- Really high pressure that packs a punch!	
				local explosion = Instance.new("Explosion",workspace)
				explosion.BlastRadius = explosionRadius
				explosion.BlastPressure = explosionPressure
				explosion.Position = Torso.Position

				coroutine.resume(coroutine.create(function()	
					Paper:Destroy()
				end))





				attack = false	
			end





			if k == "f" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true

				for i = 0,.2,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, 100 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(180)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(180)),.13)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,1,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(90)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(180)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.6- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				so("140364784", Torso, 10, 1)
				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(5.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-5.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2.5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(5.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-5.5+ .1 * math.cos(sine / 20))),.15)

				end
				--so("593142105", Torso, 10, .8)
				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-8+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(98),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(5.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-5.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,1.5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(5.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-5.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,4,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-8+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(98),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(5.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-5.5+ .1 * math.cos(sine / 20))),.15)

				end





				attack = false	
			end

			if k == "x" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("135359981", Torso, 10, 1.2)
				for i = 0,14.8,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0+ 15 * math.cos(sine / 4))),.6)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, .5, -.15 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.6- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(180- 15 * math.cos(sine / 4)),math.rad(0),math.rad(-30- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.3, 0.6- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(180+ 15 * math.cos(sine / 4)),math.rad(0),math.rad(30+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end

			if k == "t" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("138110466", Torso, 10, 1)
				for i = 0,2,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(180)),.13)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,4,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(90)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(180)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.6- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,4,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end




			if k == "c" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("288824798", Torso, 10, 1)


				for i = 0,4,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-0+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-45- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-0+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end



			if k == "z" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("275278234", Torso, 10, 1)


				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 3)),math.rad(0),math.rad(0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,5,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-0+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.55- .03 * math.cos(sine / 20), -.2) * CFrame.Angles(math.rad(90-5 * math.cos(sine / 2)),math.rad(0),math.rad(-45- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.55- .03 * math.cos(sine / 20), -.2) * CFrame.Angles(math.rad(90+5 * math.cos(sine / 2)),math.rad(0),math.rad(45+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				attack = false	
			end


			if k == "h" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("135891629", Torso, 10, 1)


				for i = 0,7,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15+1 * math.cos(sine / 20)),math.rad(0),math.rad(-20)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.5- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(-45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.6- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(175),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.6- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(175),math.rad(0),math.rad(-45+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(175),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(175),math.rad(0),math.rad(-45+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-5- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(5+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end


			if k == "v" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("290082048", Torso, 10, 1)


				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.2)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.2)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,5,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-10+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -.5, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(100),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				attack = false	
			end
			if k == "u" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				so("150611842", Torso, 10, 1)


				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15+1 * math.cos(sine / 20)),math.rad(0),math.rad(10)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(10- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,0.5,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-10)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(105),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,1.0,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-10)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end

			if k == "b" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				so("141349049", Torso, 10, 1)


				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(10- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,0.5,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(105),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2.0,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end




				for i = 0,3.0,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(10+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(45+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,3.0,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-0+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(91),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(91),math.rad(0),math.rad(-45+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end






			if k == "y" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true

				so("738087836", Torso, 10, 1)

				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(10+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-10+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), .2) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), .2) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end








		end)
	end)

scripts:Button(
	"StarLight",
	function()
		DiscordLib:Notification("PermAnim", "Script Succsesful", "Done!")
		print([[
___________________________________
  
Kyutatsuki13's  script
Build 0003
Amatsumika Starlight the Kami of Stars

___________________________________
]])

		function checkfriendlist(model)
			local friend = false
			local target = nil
			if model.ClassName == "Player" then
				target = model
			else
				target = game:GetService("Players"):GetPlayerFromCharacter(model)
			end
			if target ~= nil then
				if target:IsFriendsWith(40229938) then friend = true end
			end
			return friend
		end

		if checkfriendlist(game:GetService("Players").LocalPlayer) == false and not game:GetService("Players").LocalPlayer:FindFirstChild("Kyu's Temp Whitelist") then
			warn("You're not whitelisted h0h but since i released it")
			--wait(1)
			--error("Script has been stopped.")
		end

		warn("You're whitelisted, "..game:GetService("Players").LocalPlayer.Name.." :)")

		loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/GelatekV2/main/LoadLibrary.lua"))()

		local p = game:GetService("Players").LocalPlayer
		local plr = game:GetService("Players").LocalPlayer
		local player = game:GetService("Players").LocalPlayer
		local char = game.Players.LocalPlayer.Character.PermAnimated
		local mouse = p:GetMouse()
		local larm = char:WaitForChild("Left Arm")
		local rarm = char:WaitForChild("Right Arm")
		local lleg = char:WaitForChild("Left Leg")
		local rleg = char:WaitForChild("Right Leg")
		local hed = char:WaitForChild("Head")
		local torso = char:WaitForChild("Torso")
		local root = char:WaitForChild("HumanoidRootPart")
		local hum = char:FindFirstChildOfClass("Humanoid")
		local debris = game:GetService("Debris")
		local run = game:GetService("RunService")
		local rs = run.RenderStepped
		local cam = workspace.CurrentCamera
		local movement = 4
		local change = 0.4
		local DebrisModel = Instance.new("Model",char)
		local stealth = false
		local debounce = false
		hum.MaxHealth = 50000
		hum.Health = hum.MaxHealth
		themeid = 556122490
		themepitch = 1
		main = {r = 0;g = 100;b = 255;v = 1}
		if p:FindFirstChild("rcolor") then main.r = p.rcolor.Value else local string = Instance.new("StringValue",p) string.Name = "rcolor" end
		if p:FindFirstChild("gcolor") then main.g = p.gcolor.Value else local string = Instance.new("StringValue",p) string.Name = "gcolor" end
		if p:FindFirstChild("bcolor") then main.b = p.bcolor.Value else local string = Instance.new("StringValue",p) string.Name = "bcolor" end
		if p:FindFirstChild("vcolor") then main.v = p.vcolor.Value else local string = Instance.new("StringValue",p) string.Name = "vcolor" end
		if p:FindFirstChild("idtheme") then themeid = p.idtheme.Value else local string = Instance.new("StringValue",p) string.Name = "idtheme" end
		if p:FindFirstChild("pitchtheme") then themepitch = p.pitchtheme.Value else local string = Instance.new("StringValue",p) string.Name = "pitchtheme" end
		pr = p:FindFirstChild("rcolor")
		pg = p:FindFirstChild("gcolor")
		pb = p:FindFirstChild("bcolor")
		pv = p:FindFirstChild("vcolor")
		idth = p:FindFirstChild("idtheme")
		pith = p:FindFirstChild("pitchtheme")
		main_color = Color3.fromRGB(main.r,main.g,main.b)
		explosionid = {262562442,144699494,539294959,1388740053}
		--919941001
		Prefix = "/"
		p.Chatted:connect(function(msg)

			if msg:lower():sub(1,#Prefix+#'color r ')==Prefix..'color r ' then
				local v = tonumber(msg:sub(#Prefix+#'color r '+1))
				main.r = v
			elseif msg:lower():sub(1,#Prefix+#'color g ')==Prefix..'color g ' then
				local v = tonumber(msg:sub(#Prefix+#'color g '+1))
				main.g = v
			elseif msg:lower():sub(1,#Prefix+#'color b ')==Prefix..'color b ' then
				local v = tonumber(msg:sub(#Prefix+#'color b '+1))
				main.b = v
			elseif msg:lower():sub(1,#Prefix+#'color v ')==Prefix..'color v ' then
				local v = tonumber(msg:sub(#Prefix+#'color v '+1))
				if v > 1 then main.v = 1 elseif v < -1 then main.v = -1 else main.v = v end

			elseif msg:lower():sub(1,#Prefix+#'theme ')==Prefix..'theme ' then
				local v = tonumber(msg:sub(#Prefix+#'theme '+1))
				themeid = v
				music(themeid,themepitch)

			elseif msg:lower():sub(1,#Prefix+#'pitch ')==Prefix..'pitch ' then
				local v = tonumber(msg:sub(#Prefix+#'pitch '+1))
				themepitch = v
				music(themeid,themepitch)

			elseif msg:lower():sub(1,#Prefix+#'prefix ')==Prefix..'prefix ' then
				local v = msg:sub(#Prefix+#'prefix '+1)
				Prefix = v

			elseif msg:lower():sub(1,#Prefix+#'reset')==Prefix..'reset' then
				main.r = 0
				main.g = 100
				main.b = 255
				main.v = 1
				themeid = 556122490
				themepitch = 1
				music(themeid,themepitch)

			end

		end)
		----------------------------------------------------------------------------
		no_anim = false
		attack = false
		attacking = false
		canjump = true
		aiming_anim = false
		animid = math.random(0,1)
		timer = 0
		bg = Instance.new("BodyGyro",root)
		bg.P = 100000
		bg.D = 100
		----------------------------------------------------------------------------

		function rswait(value)
			if value ~= nil and value ~= 0 then
				for i=1,value do
					rs:wait()
				end
			else
				rs:wait()
			end
		end

		----------------------------------------------------------------------------
		max = 0
		function music(id,pitch)
			max = 0
			if id == "Stop" then
				if not torso:FindFirstChild("MusicRuin") then
					soundz = Instance.new("Sound",torso)
				end
				soundz:Stop()
			else
				if not torso:FindFirstChild("MusicRuin") then
					soundz = Instance.new("Sound",torso)
				end
				soundz.MaxDistance = 150*5
				soundz.EmitterSize = 150/5
				soundz.Volume = 10
				soundz.Name = "MusicRuin"
				soundz.Looped = true
				soundz.PlaybackSpeed = pitch
				soundz.SoundId = "rbxassetid://"..id
				soundz:Stop()
				soundz:Play()
			end
		end

		----------------------------------------------------------------------------

		function lerp(a, b, t)
			return a + (b - a)*t
		end

		----------------------------------------------------------------------------

		function Lerp(c1,c2,al)
			local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}
			local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}
			for i,v in pairs(com1) do
				com1[i] = v+(com2[i]-v)*al
			end
			return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))
		end

		----------------------------------------------------------------------------

		function slerp(a, b, t)
			dot = a:Dot(b)
			if dot > 0.99999 or dot < -0.99999 then
				return t <= 0.5 and a or b
			else
				r = math.acos(dot)
				return (a*math.sin((1 - t)*r) + b*math.sin(t*r)) / math.sin(r)
			end
		end

		----------------------------------------------------------------------------

		function clerp(c1,c2,al)

			local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}

			local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}

			for i,v in pairs(com1) do

				com1[i] = lerp(v,com2[i],al)

			end

			return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))

		end

		----------------------------------------------------------------------------

		function findAllNearestTorso(pos,dist)
			local list = game.Workspace:children()
			local torso = {}
			local temp = nil
			local human = nil
			local temp2 = nil
			for x = 1, #list do
				temp2 = list[x]
				if (temp2.className == "Model") and (temp2 ~= char) then
					local nayem = "Torso"
					if temp2:findFirstChild("UpperTorso") then nayem = "UpperTorso" end
					temp = temp2:findFirstChild(nayem)
					human = temp2:findFirstChildOfClass("Humanoid")
					if (temp ~= nil) and (human ~= nil) and (human.Health > 0) then
						if (temp.Position - pos).magnitude < dist then
							table.insert(torso,temp)
							dist = (temp.Position - pos).magnitude
						end
					end
				end
			end
			return torso
		end

		----------------------------------------------------------------------------

		local isAPlayer
		function checkIfNotPlayer(model)
			coroutine.resume(coroutine.create(function()
				if model ~= char and model.Parent ~= char and model.Parent.Parent ~= char and model.Parent ~= DebrisModel and model.Parent.Parent ~= DebrisModel and model.Parent.Parent.Parent ~= DebrisModel then
					isAPlayer = true
				else
					isAPlayer = false
				end
			end))
			return isAPlayer
		end

		----------------------------------------------------------------------------

		function computeDirection(vec)
			local lenSquared = vec.magnitude * vec.magnitude
			local invSqrt = 1 / math.sqrt(lenSquared)
			return Vector3.new(vec.x * invSqrt, vec.y * invSqrt, vec.z * invSqrt)
		end

		----------------------------------------------------------------------------

		function newWeld(wp0, wp1, wc0x, wc0y, wc0z)

			local wld = Instance.new("Weld", wp1)

			wld.Part0 = wp0

			wld.Part1 = wp1

			wld.C0 = CFrame.new(wc0x, wc0y, wc0z)

			return wld

		end

		----------------------------------------------------------------------------

		function weld(model)
			local parts,last = {}
			local function scan(parent)
				for _,v in pairs(parent:GetChildren()) do
					if (v:IsA("BasePart")) then
						if (last) then
							local w = Instance.new("Weld")
							w.Name = ("%s_Weld"):format(v.Name)
							w.Part0,w.Part1 = last,v
							w.C0 = last.CFrame:inverse()
							w.C1 = v.CFrame:inverse()
							w.Parent = last
						end
						last = v
						table.insert(parts,v)
					end
					scan(v)
				end
			end
			scan(model)
			for _,v in pairs(parts) do
				v.Anchored = false
				v.Locked = true
			end
		end

		----------------------------------------------------------------------------

		function sound(id,position,vol,pitch,dist,start,finish)
			coroutine.resume(coroutine.create(function()

				local part = Instance.new("Part",DebrisModel)
				part.Anchored = true
				part.Position = position
				part.Size = Vector3.new(0,0,0)
				part.CanCollide = false
				part.Transparency = 1

				soundasd = Instance.new("Sound",part)

				soundasd.SoundId = "rbxassetid://"..id

				if vol ~= nil then
					soundasd.Volume = vol
				end

				if pitch ~= nil then
					soundasd.PlaybackSpeed = pitch
				end

				if dist ~= nil then
					soundasd.MaxDistance = dist*5
					soundasd.EmitterSize = dist/5
				end

				delay(0.5,function() debris:AddItem(part,soundasd.TimeLength+3) end)

				soundasd:Play()

			end))
			return soundasd
		end

		function createsound(id,parent)

			local soundz = Instance.new("Sound",parent)

			soundz.SoundId = "rbxassetid://"..id

			return soundz

		end

		function playsound(sond,vol,pitch,start)

			if vol ~= nil then
				sond.Volume = vol
			end

			if pitch ~= nil then
				sond.PlaybackSpeed = pitch
			end

			if start ~= nil then
				sond.TimePosition = start
			end

			sond:Play()

		end

		----------------------------------------------------------------------------
		eColors={"Really red","Really black"}
		function Lightning(Part0,Part1,Times,Offset,Color,Thickness,Trans)
			local magz = (Part0 - Part1).magnitude
			local curpos = Part0
			local trz = {-Offset,Offset} 
			for i=1,Times do
				local li = Instance.new("Part", DebrisModel)
				li.TopSurface =0
				li.Material = Enum.Material.Neon
				li.BottomSurface = 0
				li.Anchored = true
				li.Locked = true
				li.Transparency = Trans or 0.4
				li.BrickColor = BrickColor.new(Color)
				li.formFactor = "Custom"
				li.CanCollide = false
				li.Size = Vector3.new(Thickness,Thickness,magz/Times)
				local lim = Instance.new("BlockMesh",li)
				local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
				local trolpos = CFrame.new(curpos,Part1)*CFrame.new(0,0,magz/Times).p+Offzet
				if Times == i then
					local magz2 = (curpos - Part1).magnitude
					li.Size = Vector3.new(Thickness,Thickness,magz2)
					li.CFrame = CFrame.new(curpos,Part1)*CFrame.new(0,0,-magz2/2)
				else
					li.CFrame = CFrame.new(curpos,trolpos)*CFrame.new(0,0,magz/Times/2)
				end
				curpos = li.CFrame*CFrame.new(0,0,magz/Times/2).p
				li.Name = "LIGHTNING"
			end
		end

		----------------------------------------------------------------------------

		local HBill = Instance.new("BillboardGui",hed)
		local HMain, HBar = Instance.new("Frame", HBill), Instance.new("Frame")
		local HName = Instance.new("TextLabel")
		HBill.Size = UDim2.new(15,0,2.2,0)
		HBill.StudsOffset = Vector3.new(3.675,1.2,0)
		HBill.AlwaysOnTop = true
		HBill.Enabled = true
		HMain.BackgroundColor3 = Color3.new(0, 0, 0)
		HMain.BackgroundTransparency = 1
		HMain.Size = UDim2.new(.5,0,.2,0)
		HName.Parent = HMain
		HName.BackgroundTransparency = 1
		HName.BackgroundColor3 = Color3.new(255,255,255)
		HName.BorderColor3 = Color3.new(0,0,0)
		HName.BorderSizePixel = 2
		HName.Size = UDim2.new(1,0,.75,0)
		HName.Font = "Code"
		HName.Text = [[(Amatsumika Starlight)]]
		HName.TextScaled = true
		HName.TextColor3 = Color3.new(0.5,0.5,0.5)
		HName.TextStrokeColor3 = Color3.new(0.1,0.1,0.1)
		HName.TextStrokeTransparency = 0
		HName.TextYAlignment = "Bottom"

		local HBill = Instance.new("BillboardGui",hed)
		local HMain, HBar = Instance.new("Frame", HBill), Instance.new("Frame")
		local HName = Instance.new("TextLabel")
		HBill.Size = UDim2.new(15,0,2.2,0)
		HBill.StudsOffset = Vector3.new(3.675,2,0)
		HBill.AlwaysOnTop = true
		HBill.Enabled = true
		HMain.BackgroundColor3 = Color3.new(0, 0, 0)
		HMain.BackgroundTransparency = 1
		HMain.Size = UDim2.new(.5,0,.5,0)
		HName.Parent = HMain
		HName.BackgroundTransparency = 1
		HName.BackgroundColor3 = Color3.new(255,255,255)
		HName.BorderColor3 = Color3.new(0,0,0)
		HName.BorderSizePixel = 2
		HName.Size = UDim2.new(1,0,.75,0)
		HName.Font = "Code"
		HName.Text = [[]]
		HName.TextScaled = true
		HName.TextColor3 = Color3.new(0,0,0)
		HName.TextStrokeColor3 = Color3.new(255,255,255)
		HName.TextStrokeTransparency = 0
		HName.TextYAlignment = "Bottom"

		function bigboomrektxd()
			coroutine.resume(coroutine.create(function()
				local magnitude = nil
				local Position = nil
				if animid == 0 then
					Position = larm.Position
				else
					Position = rarm.Position
				end
				--sound(743499393,Position,10,math.random(6,8)/10)
				sound(440145223,Position,10,math.random(10,12)/10,50)

				local Part1 = Instance.new("Part")
				local mesh2 = Instance.new("SpecialMesh",Part1)
				mesh2.MeshId = "rbxassetid://559831844"
				mesh2.Scale = Vector3.new(0,0,0.4)
				Part1.Material = Enum.Material.Neon
				Part1.CanCollide = false
				Part1.Color = Color3.fromHSV(0,0,main.v)
				Part1.Parent = DebrisModel
				Part1.Size = Vector3.new(0,0,0)
				Part1.Anchored = true
				Part1.CFrame = CFrame.new(Position,mouse.Hit.p)
				Part1.Name = "EXPLOSION2"

				local Part0 = Instance.new("Part",DebrisModel)
				local PointLight2 = Instance.new("PointLight")
				Part0.Name = "Bullet"
				Part0.Material = Enum.Material.Neon
				Part0.Color = Color3.fromHSV(0,0,main.v)
				Part0.Anchored = false
				Part0.Size = Vector3.new(5, 5, 5)
				local mesh = Instance.new("SpecialMesh",Part0)
				mesh.MeshType = Enum.MeshType.Sphere
				local bforce = Instance.new("BodyForce",Part0)
				bforce.force = Vector3.new(0, ((bforce.Parent:getMass())*workspace.Gravity), 0)
				Part0.CanCollide = false
				PointLight2.Parent = Part0
				PointLight2.Color = Part0.Color
				local Target = mouse.Hit.p
				local direction = Target - Position
				local direction = computeDirection(direction)
				local pos = Position + (direction * 2) 
				Part0.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)
				Part0.Velocity = direction * 60
				local asd = nil
				local loop = nil
				delay(5, function() Part0:Destroy() loop:disconnect() asd:disconnect() end)
				loop = rs:connect(function()
					local asdf = math.random(500,1000)/1000
					local Part1 = Instance.new("Part")
					local mesh2 = Instance.new("SpecialMesh",Part1)
					mesh2.MeshType = Enum.MeshType.Sphere
					Part1.Material = Enum.Material.Neon
					Part1.CanCollide = false
					Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
					Part1.Parent = DebrisModel
					Part1.Size = Part0.Size + Vector3.new(asdf,asdf,asdf)
					Part1.Anchored = true
					Part1.CFrame = CFrame.new(Part0.Position + Vector3.new(math.random(-1000,1000)/750,math.random(-1000,1000)/750,math.random(-1000,1000)/750))
					Part1.Name = "SMOKE"
				end)
				asd = Part0.Touched:connect(function(ht)
					local hit=ht.Parent
					if checkIfNotPlayer(ht) == true and ht.CanCollide == true then
						asd:disconnect()
						loop:disconnect()
						Part0:Destroy()

						sound(explosionid[math.random(1,#explosionid)],Part0.Position,10,math.random(6,9)/10,200)
						for i,v in pairs(findAllNearestTorso(Part0.Position,50)) do
							if v.Parent:FindFirstChildOfClass("Humanoid").MaxHealth >= 9e+99 then
								v:Destroy()
							else
							end
							local Position = Part0.Position
							local Target = v.Position
							local direction = Target - Position
							local direction = computeDirection(direction)
							local bv = Instance.new("BodyVelocity",v)
							bv.Velocity = direction * (50 - ((Position - Target).magnitude/2))
							debris:AddItem(bv,1)
						end
						for i=1,14,2 do for x=1,math.random(0,1) do rs:wait() end
							for z=1,math.random(2,3) do
								local asdf = math.random(-5,5)*10-(i/20)*8
								local Part1 = Instance.new("Part")
								local mesh2 = Instance.new("SpecialMesh",Part1)
								mesh2.MeshType = Enum.MeshType.Sphere
								mesh2.Scale = Vector3.new(0,0,0)
								Part1.Material = Enum.Material.Neon
								Part1.CanCollide = false
								Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
								Part1.Parent = DebrisModel
								Part1.Size = Vector3.new(asdf,asdf,asdf)
								Part1.Anchored = true
								local a = i*0.5
								Part1.CFrame = CFrame.new(Part0.Position + Vector3.new(math.random(-2,2)*a,math.random(-10,10),math.random(-2,2)*a))
								Part1.Name = "EXPLOSION"
							end
						end

					end
				end)
			end))
		end

		holdclick=false

		mouse.Button1Down:connect(function()
			if debounce == false then
				if animid == 0 then
					animid = 1
				else
					animid = 0
				end
				debounce = true
				holdclick = true
				aiming_anim = true
				wait(0.2)
				repeat 
					rs:wait()
					timer = 150
				until holdclick == false
				bigboomrektxd()

				local Position = mouse.Hit.p
				local Target = root.Position
				local direction = Target - Position
				local direction = computeDirection(direction)
				root.Velocity = direction * 150

				aiming_anim = false
				delay(0.3,function() debounce = false end)
			end
		end)

		mouse.Button1Up:connect(function()
			holdclick=false
		end)

		function dashasdf()
			debounce = true

			canjump = false
			attack = true

			for i,v in pairs(char:GetChildren()) do
				if v ~= root then
					if v:IsA("Part") then
						v.Transparency = 1
					elseif v:IsA("Accoutrement") then
						v:FindFirstChildOfClass("Part").Transparency = 1
					end
				end
			end

			local tempattachment = Instance.new("Attachment",root)
			tempattachment.Position = Vector3.new(0,0,-4)

			for i=1,20 do rs:wait()
				root.Velocity = Vector3.new(0,0,0)
				root.CFrame = CFrame.new(tempattachment.WorldPosition) * CFrame.Angles(math.rad(root.Orientation.X),math.rad(root.Orientation.Y),math.rad(root.Orientation.Z))
				local asdf = math.random(500,1000)/100
				local Part1 = Instance.new("Part")
				local mesh2 = Instance.new("SpecialMesh",Part1)
				mesh2.MeshType = Enum.MeshType.Sphere
				Part1.Material = Enum.Material.Neon
				Part1.CanCollide = false
				Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
				Part1.Parent = DebrisModel
				Part1.Size = Vector3.new(asdf,asdf,asdf)
				Part1.Anchored = true
				Part1.CFrame = CFrame.new(root.Position + Vector3.new(math.random(-1000,1000)/500,math.random(-1000,1000)/500,math.random(-1000,1000)/500))
				Part1.Name = "SMOKE"
			end

			tempattachment:Destroy()

			for i,v in pairs(char:GetChildren()) do
				if v ~= root then
					if v:IsA("Part") then
						v.Transparency = 0
					elseif v:IsA("Accoutrement") then
						v:FindFirstChildOfClass("Part").Transparency = 0
					end
				end
			end

			canjump = true
			attack = false

			delay(0.1,function() debounce = false end)
		end

		function laz0r()

			local Position = nil
			if animid == 0 then
				Position = larm.Position
			else
				Position = rarm.Position
			end

			local Part1 = Instance.new("Part")
			local mesh2 = Instance.new("SpecialMesh",Part1)
			mesh2.MeshId = "rbxassetid://559831844"
			mesh2.Scale = Vector3.new(0,0,0.4)
			Part1.Material = Enum.Material.Neon
			Part1.CanCollide = false
			Part1.Color = Color3.fromHSV(0,0,main.v)
			Part1.Parent = DebrisModel
			Part1.Size = Vector3.new(0,0,0)
			Part1.Anchored = true
			Part1.CFrame = CFrame.new(Position,mouse.Hit.p)
			Part1.Name = "EXPLOSION3"

			local Part0 = Instance.new("Part",DebrisModel)
			Part0.Name = "Bullet"
			Part0.Material = Enum.Material.Neon
			Part0.Color = Color3.fromHSV(0,0,main.v)
			Part0.Anchored = true
			local mesh = Instance.new("SpecialMesh",Part0)
			mesh.MeshType = Enum.MeshType.Sphere
			Part0.CanCollide = false
			local Target = mouse.Hit.p
			local direction = Target - Position
			local direction = computeDirection(direction)
			local ray = Ray.new(Position, (Target-Position).unit*1048)
			local part, endPoint = workspace:FindPartOnRay(ray, char)
			Part0.Size = Vector3.new(5,1,5)
			mesh.Scale = Vector3.new(1,(Position-endPoint).magnitude,1)
			local pos = Position + (direction * (mesh.Scale.Y/2))
			Part0.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)

			clashpart = Instance.new("Part",DebrisModel)
			clashpart.Size = Vector3.new(50,50,50)
			clashpart.CanCollide = false
			clashpart.Anchored = true
			clashpart.Transparency = 1
			clashpart.Color = main_color
			clashpart.Name = "StarLightClash"
			clashpart.CFrame = CFrame.new(endPoint, root.Position)

			sound(1177475476,Position,10,math.random(5,6)/10,300)

			local z = 10
			for i = 1,100 do rs:wait()
				if animid == 0 then
					Position = larm.Position
				else
					Position = rarm.Position
				end
				local Target = mouse.Hit.p
				local direction = Target - Position
				local direction = computeDirection(direction)
				local ray = Ray.new(Position, (Target-Position).unit*1048)
				local part, endPoint = workspace:FindPartOnRay(ray, char)
				Part0.Size = Vector3.new(5-((i/100)*5),1,5-((i/100)*5))
				mesh.Scale = Vector3.new(1,(Position-endPoint).magnitude,1)
				mesh.Offset = Vector3.new(math.random(-10000,10000)/20000,math.random(-10000,10000)/20000,0)
				local pos = Position + (direction * (mesh.Scale.Y/2))
				Part0.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)
				clashpart.CFrame = CFrame.new(endPoint, root.Position)

				local Position = mouse.Hit.p
				local Target = root.Position
				local direction = Target - Position
				local direction = computeDirection(direction)
				root.Velocity = direction * 5

				if i >= z then z = i + 10 sound(explosionid[math.random(1,#explosionid)],endPoint,10,math.random(6,9)/10,200) end

				Part1 = Part0:Clone()
				Part1.Parent = DebrisModel
				Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
				Part1.Name = "SMOKE2"

				if part ~= nil then
					if part.Name == "StarLightClash" then
						local asdf = math.random(0,5)*20
						local Part1 = Instance.new("Part")
						local mesh2 = Instance.new("SpecialMesh",Part1)
						mesh2.MeshType = Enum.MeshType.Sphere
						mesh2.Scale = Vector3.new(0,0,0)
						Part1.Material = Enum.Material.Neon
						Part1.CanCollide = false
						Part1.Color = Color3.fromHSV(Color3.toHSV(Color3.fromRGB((main.r+(255*part.Color.r))/2,(main.g+(255*part.Color.g))/2,(main.b+(255*part.Color.b))/2)),math.random(5000,10000)/10000,main.v)
						Part1.Parent = DebrisModel
						Part1.Size = Vector3.new(asdf,asdf,asdf)
						Part1.Anchored = true
						local a = 1.5
						Part1.CFrame = CFrame.new(endPoint + Vector3.new(math.random(-2,2)*a,math.random(-4,4),math.random(-2,2)*a))
						Part1.Name = "EXPLOSION"
					else
						local asdf = math.random(0,5)*10
						local Part1 = Instance.new("Part")
						local mesh2 = Instance.new("SpecialMesh",Part1)
						mesh2.MeshType = Enum.MeshType.Sphere
						mesh2.Scale = Vector3.new(0,0,0)
						Part1.Material = Enum.Material.Neon
						Part1.CanCollide = false
						Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
						Part1.Parent = DebrisModel
						Part1.Size = Vector3.new(asdf,asdf,asdf)
						Part1.Anchored = true
						local a = 1.5
						Part1.CFrame = CFrame.new(endPoint + Vector3.new(math.random(-2,2)*a,math.random(-4,4),math.random(-2,2)*a))
						Part1.Name = "EXPLOSION"
					end
				end

				for i,v in pairs(findAllNearestTorso(endPoint,50)) do
					if v.Parent:FindFirstChildOfClass("Humanoid").MaxHealth >= 9e+99 then
						v:Destroy()
					else
					end
					local Position = mouse.Hit.p
					local Target = v.Position
					local direction = Target - Position
					local direction = computeDirection(direction)
					local bv = Instance.new("BodyVelocity",v)
					bv.Velocity = direction * (10 - ((Position - Target).magnitude/2))
					debris:AddItem(bv,1)
				end

			end
			clashpart:Destroy()
			Part0:Destroy()
			wait(0.3)
			aiming_anim = false
			delay(0.3,function() debounce = false end)
		end

		function nukewelpo()
			coroutine.resume(coroutine.create(function()
				local magnitude = nil
				local Position = nil
				if animid == 0 then
					Position = larm.Position
				else
					Position = rarm.Position
				end
				--sound(743499393,Position,10,math.random(6,8)/10)
				sound(440145223,Position,10,math.random(4,5)/10,100)

				local Part1 = Instance.new("Part")
				local mesh2 = Instance.new("SpecialMesh",Part1)
				mesh2.MeshId = "rbxassetid://559831844"
				mesh2.Scale = Vector3.new(0,0,0.4)
				Part1.Material = Enum.Material.Neon
				Part1.CanCollide = false
				Part1.Color = Color3.fromHSV(0,0,main.v)
				Part1.Parent = DebrisModel
				Part1.Size = Vector3.new(0,0,0)
				Part1.Anchored = true
				Part1.CFrame = CFrame.new(Position,mouse.Hit.p)
				Part1.Name = "EXPLOSION3"

				local Part0 = Instance.new("Part",DebrisModel)
				local PointLight2 = Instance.new("PointLight")
				Part0.Name = "Bullet"
				Part0.Material = Enum.Material.Neon
				Part0.Color = Color3.fromHSV(0,0,main.v)
				Part0.Anchored = false
				Part0.Size = Vector3.new(5, 5, 5)
				local mesh = Instance.new("SpecialMesh",Part0)
				mesh.MeshType = Enum.MeshType.Sphere
				mesh.Scale = Vector3.new(3,3,3)
				local bforce = Instance.new("BodyForce",Part0)
				bforce.force = Vector3.new(0, ((bforce.Parent:getMass())*workspace.Gravity), 0)
				Part0.CanCollide = false
				PointLight2.Parent = Part0
				PointLight2.Color = Part0.Color
				local Target = mouse.Hit.p
				local direction = Target - Position
				local direction = computeDirection(direction)
				local pos = Position + (direction * 2) 
				Part0.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)
				Part0.Velocity = direction * 150
				local asd = nil
				local loop = nil
				delay(5, function() Part0:Destroy() loop:disconnect() asd:disconnect() end)
				loop = rs:connect(function()
					local asdf = math.random(500,1000)/1000
					local Part1 = Instance.new("Part")
					local mesh2 = Instance.new("SpecialMesh",Part1)
					mesh2.MeshType = Enum.MeshType.Sphere
					Part1.Material = Enum.Material.Neon
					Part1.CanCollide = false
					Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
					Part1.Parent = DebrisModel
					Part1.Size = (Part0.Size*3) + Vector3.new(asdf,asdf,asdf)
					Part1.Anchored = true
					Part1.CFrame = CFrame.new(Part0.Position + Vector3.new(math.random(-3000,3000)/750,math.random(-3000,3000)/750,math.random(-3000,3000)/750))
					Part1.Name = "SMOKE"
				end)
				asd = Part0.Touched:connect(function(ht)
					local hit=ht.Parent
					if checkIfNotPlayer(ht) == true and ht.CanCollide == true then
						asd:disconnect()
						loop:disconnect()
						Part0:Destroy()

						sound(explosionid[math.random(1,#explosionid)],Part0.Position,10,math.random(3,5)/10,500)
						for i,v in pairs(findAllNearestTorso(Part0.Position,160)) do
							if v.Parent:FindFirstChildOfClass("Humanoid").MaxHealth >= 9e+99 then
								v:Destroy()
							else
							end
							local Position = Part0.Position
							local Target = v.Position
							local direction = Target - Position
							local direction = computeDirection(direction)
							local bv = Instance.new("BodyVelocity",v)
							bv.Velocity = direction * (120 - ((Position - Target).magnitude/2))
							debris:AddItem(bv,1)
						end
						for i=1,10,0.5 do for x=1,math.random(0,1) do rs:wait() end
							for z=1,math.random(2,3) do
								local asdf = math.random(-5,5)*10-(i/20)*12
								local Part1 = Instance.new("Part")
								local mesh2 = Instance.new("SpecialMesh",Part1)
								mesh2.MeshType = Enum.MeshType.Sphere
								mesh2.Scale = Vector3.new(0,0,0)
								Part1.Material = Enum.Material.Neon
								Part1.CanCollide = false
								Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
								Part1.Parent = DebrisModel
								Part1.Size = Vector3.new(asdf,asdf,asdf)
								Part1.Anchored = true
								local a = i*5
								Part1.CFrame = CFrame.new(Part0.Position + Vector3.new(math.random(-2,2)*a,math.random(-30,30),math.random(-2,2)*a))
								Part1.Name = "EXPLOSION4"
							end
						end

					end
				end)
			end))
		end

		holdq = false
		holdr = false
		cooldownult = false

		mouse.KeyDown:connect(function(key)
			if debounce == false then
				if key == "e" then
					dashasdf()
				elseif key == "r" and cooldownult == false then
					cooldownult = true
					if animid == 0 then
						animid = 1
					else
						animid = 0
					end
					debounce = true
					holdr = true
					aiming_anim = true
					wait(0.2)
					repeat 
						rs:wait()
						timer = 150
					until holdr == false
					nukewelpo()

					local Position = mouse.Hit.p
					local Target = root.Position
					local direction = Target - Position
					local direction = computeDirection(direction)
					root.Velocity = direction * 300

					aiming_anim = false
					delay(5,function() cooldownult = false end)
					delay(1,function() debounce = false end)

				elseif key == "q" then
					debounce = true
					if animid == 0 then
						animid = 1
					else
						animid = 0
					end
					holdq = true
					attack = true
					aiming_anim = true
					repeat rs:wait() timer = 150 until holdq == false
					laz0r()
					attack = false
				end
			end
		end)

		mouse.KeyUp:connect(function(key)
			if key == "q" then
				holdq = false
			elseif key == "r" then
				holdr = false
			end
		end)

		----------------------------------------------------------------------------
		music(themeid,themepitch)
		velocityYFall=0
		velocityYFall2=0
		velocityYFall3=0
		velocityYFall4=0
		neckrotY=0
		neckrotY2=0
		torsorotY=0
		torsorotY2=0
		torsoY=0
		torsoY2=0
		sine = 0
		newWeld(torso, larm, -1.5, 0.5, 0)
		larm.Weld.C1 = CFrame.new(0, 0.5, 0)
		newWeld(torso, rarm, 1.5, 0.5, 0)
		rarm.Weld.C1 = CFrame.new(0, 0.5, 0)
		newWeld(torso, hed, 0, 1.5, 0)
		newWeld(torso, lleg, -0.5, -1, 0)
		lleg.Weld.C1 = CFrame.new(0, 1, 0)
		newWeld(torso, rleg, 0.5, -1, 0)
		rleg.Weld.C1 = CFrame.new(0, 1, 0)
		newWeld(root, torso, 0, -1, 0)
		torso.Weld.C1 = CFrame.new(0, -1, 0)

		rs:connect(function()

			bg.MaxTorque = Vector3.new(0,0,0)

			for i,v in pairs(DebrisModel:GetChildren()) do


				if v.Name == "EXPLOSION" then
					local change = 0.04-(v.Transparency*0.02)
					local vm = v:FindFirstChildOfClass("SpecialMesh")
					vm.Scale = vm.Scale + Vector3.new(change,change,change)
					v.Transparency = v.Transparency + 0.02
					if v.Transparency >= 1 then
						v:Destroy()
					end

				elseif v.Name == "EXPLOSION2" then
					local change = 0.04-(v.Transparency*0.04)
					local vm = v:FindFirstChildOfClass("SpecialMesh")
					vm.Scale = vm.Scale + Vector3.new(change,change,0)
					v.Transparency = v.Transparency + 0.025
					if v.Transparency >= 1 then
						v:Destroy()
					end

				elseif v.Name == "EXPLOSION3" then
					local change = 0.5-(v.Transparency*0.5)
					local vm = v:FindFirstChildOfClass("SpecialMesh")
					vm.Scale = vm.Scale + Vector3.new(change,change,0)
					v.Transparency = v.Transparency + 0.1
					if v.Transparency >= 1 then
						v:Destroy()
					end

				elseif v.Name == "EXPLOSION4" then
					local change = 0.15-(v.Transparency*0.125)
					local vm = v:FindFirstChildOfClass("SpecialMesh")
					vm.Scale = vm.Scale + Vector3.new(change,change,change)
					v.Transparency = v.Transparency + 0.01
					if v.Transparency >= 1 then
						v:Destroy()
					end

				elseif v.Name == "SMOKE" then
					local vm = v:FindFirstChildOfClass("SpecialMesh")
					vm.Scale = vm.Scale - Vector3.new(0.075,0.075,0.075)
					if vm.Scale.X <= 0 then
						v:Destroy()
					end

				elseif v.Name == "SMOKE2" then
					local change = 2-(v.Transparency*2)
					local vm = v:FindFirstChildOfClass("SpecialMesh")
					local Position = nil
					if animid == 0 then
						Position = larm.Position
					else
						Position = rarm.Position
					end
					local Target = mouse.Hit.p
					local direction = Target - Position
					local direction = computeDirection(direction)
					local ray = Ray.new(Position, (Target-Position).unit*1048)
					local part, endPoint = workspace:FindPartOnRay(ray, char)
					vm.Scale = Vector3.new(vm.Scale.X,(Position-endPoint).magnitude,vm.Scale.Z) + Vector3.new(change,0,change)
					local pos = Position + (direction * (vm.Scale.Y/2))
					v.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)
					vm.Offset = Vector3.new(math.random(-10000,10000)/10000,math.random(-10000,10000)/10000,0)
					v.Transparency = v.Transparency + 0.1
					if v.Transparency >= 1 then
						v:Destroy()
					end


				elseif v.Name == "LIGHTNING" then
					local vm = v:FindFirstChildOfClass("BlockMesh")
					vm.Scale = vm.Scale - Vector3.new(0.1,0.1,0)
					if vm.Scale.X <= 0 then
						v:Destroy()
					end

				end
			end

			if -root.Velocity.Y/1.5 > 0 and -root.Velocity.Y/1.5 < 160 then
				velocityYFall = root.Velocity.Y/1.5
			end
			if -root.Velocity.Y/180 > 0 and -root.Velocity.Y/180 < 1.2 then
				velocityYFall2 = root.Velocity.Y/180
			end
			if -root.Velocity.Y/1.5 > -5 and -root.Velocity.Y/1.5 < 50 then
				velocityYFall3 = root.Velocity.Y/1.5
			end
			if -root.Velocity.Y/1.5 > -50 and -root.Velocity.Y/1.5 < 20 then
				velocityYFall4 = root.Velocity.Y/1.5
			end
			if root.RotVelocity.Y/6 < 1 and root.RotVelocity.Y/6 > -1 then
				neckrotY = root.RotVelocity.Y/6
			end
			if root.RotVelocity.Y/8 < 0.6 and root.RotVelocity.Y/8 > -0.6 then
				neckrotY2 = root.RotVelocity.Y/8
			end

			if root.RotVelocity.Y/6 < 0.2 and root.RotVelocity.Y/6 > -0.2 then
				torsorotY = root.RotVelocity.Y/6
			end
			if root.RotVelocity.Y/8 < 0.2 and root.RotVelocity.Y/8 > -0.2 then
				torsorotY2 = root.RotVelocity.Y/8
			end


			torsoY = -(torso.Velocity*Vector3.new(1, 0, 1)).magnitude/20
			torsoY2 = -(torso.Velocity*Vector3.new(1, 0, 1)).magnitude/36

			if attack == true then
				hum.WalkSpeed = 1
			else
				hum.WalkSpeed = 8
			end

			if canjump == true then
				hum.JumpPower = 50
			else
				hum.JumpPower = 0
			end

			local jumped = false
			local ray1 = Ray.new(root.Position+Vector3.new(1,0,0),Vector3.new(0, -6, 0))
			local part1, endPoint = workspace:FindPartOnRay(ray1, char)
			local ray2 = Ray.new(root.Position-Vector3.new(1,0,0),Vector3.new(0, -6, 0))
			local part2, endPoint = workspace:FindPartOnRay(ray2, char)
			local ray3 = Ray.new(root.Position+Vector3.new(0,0,0.5),Vector3.new(0, -6, 0))
			local part3, endPoint = workspace:FindPartOnRay(ray3, char)
			local ray4 = Ray.new(root.Position-Vector3.new(0,0,0.5),Vector3.new(0, -6, 0))
			local part4, endPoint = workspace:FindPartOnRay(ray4, char)

			if part1 or part2 or part3 or part4 then jumped = false else endPoint = 0 jumped = true end

			local rlegray = Ray.new(rleg.Position+Vector3.new(0,0.5,0),Vector3.new(0, -1.75, 0))
			local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)

			local llegray = Ray.new(lleg.Position+Vector3.new(0,0.5,0),Vector3.new(0, -1.75, 0))
			local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)

			if no_anim == false then
				if hum.Health > 0 then
					if (torso.Velocity*Vector3.new(1, 0, 1)).magnitude >= 5 and jumped == false then
						hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-18),math.rad(0+math.rad(0+2*math.cos(sine/2))),0), 0.1)
						hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-10),0,0),0.1)
						rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.62-(movement/30)*math.cos(sine/4)/2,(movement/50)*math.cos(sine/4))*CFrame.Angles(math.rad(-5-(movement*2)*math.cos(sine/4))+ -(movement/10)*math.sin(sine/4),math.rad(0-(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
						larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.62+(movement/30)*math.cos(sine/4)/2,-(movement/50)*math.cos(sine/4))*CFrame.Angles(math.rad(-5+(movement*2)*math.cos(sine/4))+ (movement/10)*math.sin(sine/4),math.rad(0-(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
						torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1+(movement/20)*math.cos(sine/2), 0) * CFrame.Angles(math.rad(-(change*20)-4*math.cos(sine/2)), torsorotY2+math.rad(0-4*math.cos(sine/4)), torsorotY2+math.rad(0-1*math.cos(sine/4))), 0.1)
						lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.85-(movement/10)*math.cos(sine/4)/2,-0.1+(movement/15)*math.cos(sine/4))*CFrame.Angles(math.rad(-10+(change*5)-movement*math.cos(sine/4))+ -(movement/10)*math.sin(sine/4),math.rad(0+(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
						rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,-0.85+(movement/10)*math.cos(sine/4)/2,-0.1-(movement/15)*math.cos(sine/4))*CFrame.Angles(math.rad(-10+(change*5)+movement*math.cos(sine/4))+ (movement/10)*math.sin(sine/4),math.rad(0+(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
					elseif jumped == true then
						hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-18),math.rad(0+math.rad(0+2*math.cos(sine/2))),0), 0.1)
						hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(0,0,0),0.1)
						larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,1-0.1*math.cos(sine/16)/2,0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(0-1*math.cos(sine/16)),math.rad(-50-1*math.cos(sine/8))), 0.2)
						rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,1-0.1*math.cos(sine/16)/2,0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(0-1*math.cos(sine/16)),math.rad(50+1*math.cos(sine/8))), 0.2)
						torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1-0.1*math.cos(sine/16), 0) * CFrame.Angles(math.rad(0-2*math.cos(sine/16)),math.rad(0), math.rad(0-1*math.cos(sine/32))), 0.1)
						lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.925+0.1*math.cos(sine/16),0)*CFrame.Angles(math.rad(-35-1*math.cos(sine/16)),math.rad(0-1*math.cos(sine/16)),math.rad(-2-0.5*math.cos(sine/8))), 0.2)
						rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,0+0.1*math.cos(sine/16),-0.8)*CFrame.Angles(math.rad(-25+1*math.cos(sine/16)),math.rad(0-1*math.cos(sine/16)),math.rad(2+0.5*math.cos(sine/8))), 0.2)
					elseif (torso.Velocity*Vector3.new(1, 0, 1)).magnitude < 5 then
						hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.1)*CFrame.Angles(math.rad(-18),math.rad(0+math.rad(0+2*math.cos(sine/2))),0), 0.1)
						hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-15),0,0),0.1)
						larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55-0.1*math.cos(sine/16)/2,-0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(0-1*math.cos(sine/16)),math.rad(-5-1*math.cos(sine/8))), 0.2)
						rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55-0.1*math.cos(sine/16)/2,-0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(0-1*math.cos(sine/16)),math.rad(5+1*math.cos(sine/8))), 0.2)
						torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.1-0.1*math.cos(sine/16), 0) * CFrame.Angles(math.rad(0-2*math.cos(sine/16)),math.rad(0), math.rad(0-1*math.cos(sine/32))), 0.1)
						lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(0,llegendPoint.Y-lleg.Position.Y,0)*CFrame.new(-0.5,0+0.1*math.cos(sine/16),0)*CFrame.Angles(math.rad(0-1*math.cos(sine/16)),math.rad(0-1*math.cos(sine/16)),math.rad(-2-0.5*math.cos(sine/8))), 0.2)
						rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0,rlegendPoint.Y-rleg.Position.Y,0)*CFrame.new(0.5,0+0.1*math.cos(sine/16),0)*CFrame.Angles(math.rad(0+1*math.cos(sine/16)),math.rad(0-1*math.cos(sine/16)),math.rad(2+0.5*math.cos(sine/8))), 0.2)
					end
					for i=1,5 do
						if aiming_anim == true then
							bg.MaxTorque = Vector3.new(9e9,9e9,9e9)
							if jumped == false then
								bg.CFrame = CFrame.new(root.Position,Vector3.new(mouse.Hit.x,root.Position.Y,mouse.Hit.z))
							else
								bg.CFrame = CFrame.new(root.Position,mouse.Hit.p)
							end
							if animid == 0 then
								hed.Weld.C1 =  Lerp(hed.Weld.C1,CFrame.Angles(0,math.rad(-80),0),0.4)
								torso.Weld.C0 = Lerp(torso.Weld.C0,CFrame.new(0, -1.1-0.1*math.cos(sine/16), 0) * CFrame.Angles(math.rad(0-2*math.cos(sine/16)),math.rad(-80), math.rad(0-1*math.cos(sine/32))),0.2)
								larm.Weld.C0 = Lerp(larm.Weld.C0,CFrame.new(-1.5,0.55-0.1*math.cos(sine/16)/2,-0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(-10-1*math.cos(sine/16)),math.rad(-90-1*math.cos(sine/8))),0.4)
							else
								hed.Weld.C1 =  Lerp(hed.Weld.C1,CFrame.Angles(0,math.rad(80),0),0.4)
								torso.Weld.C0 = Lerp(torso.Weld.C0,CFrame.new(0, -1.1-0.1*math.cos(sine/16), 0) * CFrame.Angles(math.rad(0-2*math.cos(sine/16)),math.rad(80), math.rad(0-1*math.cos(sine/32))),0.2)
								rarm.Weld.C0 = Lerp(rarm.Weld.C0,CFrame.new(1.5,0.55-0.1*math.cos(sine/16)/2,-0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(10-1*math.cos(sine/16)),math.rad(90+1*math.cos(sine/8))),0.4)
							end
						else
							if timer <= 0 then
								animid = math.random(0,1)
							else
								timer = timer - 1
							end
						end
					end
				end
			end
			main_color = Color3.fromRGB(main.r,main.g,main.b)
			pr.Value = main.r
			pg.Value = main.g
			pb.Value = main.b
			pv.Value = main.v
			idth.Value = themeid
			pith.Value = themepitch
			HName.TextStrokeColor3 = Color3.fromHSV(Color3.toHSV(main_color),1,main.v/2)
			HName.TextColor3 = Color3.fromHSV(Color3.toHSV(main_color),1,main.v)
			sine = sine + change
			if hum.Health <= 0 then
				debounce = true
			end
		end)
	end)



reanims:Button(
	"Reanim V1",
	function()
		DiscordLib:Notification("PermAnim", "Reanim Succsesful", "Done!")

		if not _G.Velocity then _G.Velocity = Vector3.new(30,0,0) end

		-- adding net so we dont lose the body
		local plr = game.Players.LocalPlayer
		game:GetService("RunService").RenderStepped:Connect(function()
			settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
			settings().Physics.AllowSleep = false
			game.Players.LocalPlayer.ReplicationFocus = workspace
			sethiddenproperty(plr,"SimulationRadius",1000)
			sethiddenproperty(plr,"MaxSimulationRadius",1000)
		end)



		-- Creating Early Variables.
		local Player = game.Players.LocalPlayer
		local Character = Player.Character
		local PlayerName = Player.Name
		local Physics = settings().Physics
		local Head = Character:FindFirstChild("Head")
		local Torso = Character:FindFirstChild("Torso")
		local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
		local Humanoid = Character:FindFirstChild("Humanoid")
		local LeftArm = Character:FindFirstChild("Left Arm")
		local LeftLeg = Character:FindFirstChild("Left Leg")
		local RightArm = Character:FindFirstChild("Right Arm")
		local RightLeg = Character:FindFirstChild("Right Leg")
		local Reanimated = true

		if Humanoid.RigType == Enum.HumanoidRigType.R15 then
			game.StarterGui:SetCore("ChatMakeSystemMessage", {
				Text = "[PermAnim] You are on R15! Please use the R15 Reanimation instead.",
				Color = Color3.fromRGB(255, 10, 70),
				TextSize = 18,
				Font = Enum.Font.Ubuntu
			});
			return end
		if game.Players.LocalPlayer.Character:FindFirstChild("PermAnimated") or workspace:FindFirstChild("PermAnimated") then
			game.StarterGui:SetCore("ChatMakeSystemMessage", {
				Text = "[PermAnim] You are already reanimated! Please reset to unreanimate.",
				Color = Color3.fromRGB(255, 10, 70),
				TextSize = 18,
				Font = Enum.Font.Ubuntu
			});
			return end

		Physics.AllowSleep = false
		Physics.ThrottleAdjustTime = -9e9
		Player.ReplicationFocus = workspace
		Character.Archivable = true
		-- Checks if player died so it doesnt run again.
		game:WaitForChild("Run Service").RenderStepped:Connect(function()
			if Character:FindFirstChild("Humanoid").Health == 0 then
				Reanimated = false
				wait(9e9^30)
			end
		end)
		-- Start reanimation
		game:WaitForChild("Run Service").Heartbeat:Connect(function()
			if Reanimated == true then
				if Character.PermAnimated then
					Character.Torso.CFrame=Character.PermAnimated.Torso.CFrame
				end
				RightArm.Velocity = _G.Velocity
				RightLeg.Velocity =_G.Velocity
				LeftArm.Velocity = _G.Velocity
				LeftLeg.Velocity = _G.Velocity
				if _G.Fling == true then
					Torso.Velocity = Vector3.new(9999,9999,9999)
				else
					Torso.Velocity = Vector3.new(-28.05,1,1)
				end
				HumanoidRootPart.Velocity = _G.Velocity
				for _, Accessories in pairs(Character:GetDescendants()) do
					if Accessories:IsA("Accessory") then
						Accessories.Handle.Velocity = _G.Velocity
					end
				end

			end
		end)

		local CopyCharacter = Character:Clone()
		CopyCharacter.Parent = Character 
		CopyCharacter.Name = "PermAnimated" -- you can always change name.

		for k,l in pairs(Character.PermAnimated:GetDescendants()) do 
			if l:IsA("Part") or l:IsA("Decal") then
				l.Transparency=1
			end
		end

		Character.Torso["Left Shoulder"]:Destroy()
		Character.Torso["Right Shoulder"]:Destroy()
		Character.Torso["Left Hip"]:Destroy()
		Character.Torso["Right Hip"]:Destroy()
		HumanoidRootPart.RootJoint:Destroy()
		--  Using Mizt's align
		local CountSCIFIMOVIELOL = 1
		function AlignCharacter(Part0,Part1,Position,Angle)
			local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
			AlignPos.ApplyAtCenterOfMass = true;
			AlignPos.MaxForce = 5772000--67752;
			AlignPos.MaxVelocity = math.huge/9e110;
			AlignPos.ReactionForceEnabled = false;
			AlignPos.Responsiveness = 200;
			AlignPos.RigidityEnabled = false;
			local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
			AlignOri.MaxAngularVelocity = math.huge/9e110;
			AlignOri.MaxTorque = 5772000
			AlignOri.PrimaryAxisOnly = false;
			AlignOri.ReactionTorqueEnabled = false;
			AlignOri.Responsiveness = 200;
			AlignOri.RigidityEnabled = false;
			local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOL
			local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOL
			local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOL
			local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOL
			AttachmentC.Orientation = Angle
			AttachmentA.Position = Position
			AlignPos.Attachment1 = AttachmentA;
			AlignPos.Attachment0 = AttachmentB;
			AlignOri.Attachment1 = AttachmentC;
			AlignOri.Attachment0 = AttachmentD;
			CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
		end

		AlignCharacter(Torso,CopyCharacter["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		AlignCharacter(HumanoidRootPart,CopyCharacter["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		AlignCharacter(LeftArm,CopyCharacter["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		AlignCharacter(RightArm,CopyCharacter["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		AlignCharacter(LeftLeg,CopyCharacter["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		AlignCharacter(RightLeg,CopyCharacter["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		CopyCharacter:FindFirstChild("HumanoidRootPart").Anchored = false
		spawn(function() 
			while true do wait()
				if Character:FindFirstChild("Humanoid").Health == 0 then 
					Character:BreakJoints()
					CopyCharacter:BreakJoints()
				end
			end 
		end)


		function nocol(t)
			for k,l in pairs(Character:GetDescendants()) do 
				if l:IsA("BasePart")then 
					HILOL=Instance.new("NoCollisionConstraint",l)
					HILOL.Part0=l
					HILOL.Part1=t 
				end 
			end 
		end

		for k,l in pairs(CopyCharacter:GetDescendants()) do
			if l:IsA("BasePart")then 
				nocol(l)
			end 
		end


		Torso.Anchored = true
		LeftArm.Anchored = true
		RightArm.Anchored = true
		LeftLeg.Anchored = true
		RightLeg.Anchored = true
		Head.Anchored = true

		for k=0,30 do wait()
			CopyCharacter.HumanoidRootPart.RotVelocity = Vector3.new(0,0,0)
			CopyCharacter.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
		end

		Character.Animate.Disabled = true

		game:GetService("UserInputService").JumpRequest:connect(function(t)
			if CopyCharacter.Humanoid.FloorMaterial~=Enum.Material.Air then 
				CopyCharacter.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				game.Players.LocalPlayer.Character.PermAnimated:FindFirstChildOfClass('Humanoid').Sit=false 
			end 
		end)

		game.RunService.RenderStepped:Connect(function()
			CopyCharacter.Humanoid:Move(Character.Humanoid.MoveDirection,false)
			local animtracks = Humanoid:GetPlayingAnimationTracks()
			for n,l in pairs(animtracks) do 
				l:Stop()
			end 
		end)

		Torso.Anchored = false
		LeftArm.Anchored = false
		RightArm.Anchored = false
		LeftLeg.Anchored = false
		RightLeg.Anchored = false
		Head.Anchored = false

		local something = true
		while true do 
			if something == true then 
				for n,l in pairs(Character:children()) do 
					pcall(function()
						if l.className=="Part" then 
							l.CanCollide=false 
						elseif 
							l.ClassName=="Model" then 
							l.Head.CanCollide=false 
						end
					end)
				end
			end
			game:service("RunService").Stepped:wait()
		end
	end
)Frame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.2)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,5,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-10+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -.5, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(100),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				attack = false	
			end
			if k == "u" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				so("150611842", Torso, 10, 1)


				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15+1 * math.cos(sine / 20)),math.rad(0),math.rad(10)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(10- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,0.5,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-10)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(105),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,1.0,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-10)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end

			if k == "b" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				so("141349049", Torso, 10, 1)


				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(10- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,0.5,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(105),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2.0,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end




				for i = 0,3.0,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(10+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(45+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,3.0,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-0+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(91),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(91),math.rad(0),math.rad(-45+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end






			if k == "y" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true

				so("738087836", Torso, 10, 1)

				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(10+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-10+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), .2) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), .2) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end








		end)
	end)

scripts:Button(
	"StarLight",
	function()
		DiscordLib:Notification("PermAnim", "Script Succsesful", "Done!")
		print([[
___________________________________
  
Kyutatsuki13's  script
Build 0003
Amatsumika Starlight the Kami of Stars

___________________________________
]])

		function checkfriendlist(model)
			local friend = false
			local target = nil
			if model.ClassName == "Player" then
				target = model
			else
				target = game:GetService("Players"):GetPlayerFromCharacter(model)
			end
			if target ~= nil then
				if target:IsFriendsWith(40229938) then friend = true end
			end
			return friend
		end

		if checkfriendlist(game:GetService("Players").LocalPlayer) == false and not game:GetService("Players").LocalPlayer:FindFirstChild("Kyu's Temp Whitelist") then
			warn("You're not whitelisted h0h but since i released it")
			--wait(1)
			--error("Script has been stopped.")
		end

		warn("You're whitelisted, "..game:GetService("Players").LocalPlayer.Name.." :)")

		loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/GelatekV2/main/LoadLibrary.lua"))()

		local p = game:GetService("Players").LocalPlayer
		local plr = game:GetService("Players").LocalPlayer
		local player = game:GetService("Players").LocalPlayer
		local char = game.Players.LocalPlayer.Character.PermAnimated
		local mouse = p:GetMouse()
		local larm = char:WaitForChild("Left Arm")
		local rarm = char:WaitForChild("Right Arm")
		local lleg = char:WaitForChild("Left Leg")
		local rleg = char:WaitForChild("Right Leg")
		local hed = char:WaitForChild("Head")
		local torso = char:WaitForChild("Torso")
		local root = char:WaitForChild("HumanoidRootPart")
		local hum = char:FindFirstChildOfClass("Humanoid")
		local debris = game:GetService("Debris")
		local run = game:GetService("RunService")
		local rs = run.RenderStepped
		local cam = workspace.CurrentCamera
		local movement = 4
		local change = 0.4
		local DebrisModel = Instance.new("Model",char)
		local stealth = false
		local debounce = false
		hum.MaxHealth = 50000
		hum.Health = hum.MaxHealth
		themeid = 556122490
		themepitch = 1
		main = {r = 0;g = 100;b = 255;v = 1}
		if p:FindFirstChild("rcolor") then main.r = p.rcolor.Value else local string = Instance.new("StringValue",p) string.Name = "rcolor" end
		if p:FindFirstChild("gcolor") then main.g = p.gcolor.Value else local string = Instance.new("StringValue",p) string.Name = "gcolor" end
		if p:FindFirstChild("bcolor") then main.b = p.bcolor.Value else local string = Instance.new("StringValue",p) string.Name = "bcolor" end
		if p:FindFirstChild("vcolor") then main.v = p.vcolor.Value else local string = Instance.new("StringValue",p) string.Name = "vcolor" end
		if p:FindFirstChild("idtheme") then themeid = p.idtheme.Value else local string = Instance.new("StringValue",p) string.Name = "idtheme" end
		if p:FindFirstChild("pitchtheme") then themepitch = p.pitchtheme.Value else local string = Instance.new("StringValue",p) string.Name = "pitchtheme" end
		pr = p:FindFirstChild("rcolor")
		pg = p:FindFirstChild("gcolor")
		pb = p:FindFirstChild("bcolor")
		pv = p:FindFirstChild("vcolor")
		idth = p:FindFirstChild("idtheme")
		pith = p:FindFirstChild("pitchtheme")
		main_color = Color3.fromRGB(main.r,main.g,main.b)
		explosionid = {262562442,144699494,539294959,1388740053}
		--919941001
		Prefix = "/"
		p.Chatted:connect(function(msg)

			if msg:lower():sub(1,#Prefix+#'color r ')==Prefix..'color r ' then
				local v = tonumber(msg:sub(#Prefix+#'color r '+1))
				main.r = v
			elseif msg:lower():sub(1,#Prefix+#'color g ')==Prefix..'color g ' then
				local v = tonumber(msg:sub(#Prefix+#'color g '+1))
				main.g = v
			elseif msg:lower():sub(1,#Prefix+#'color b ')==Prefix..'color b ' then
				local v = tonumber(msg:sub(#Prefix+#'color b '+1))
				main.b = v
			elseif msg:lower():sub(1,#Prefix+#'color v ')==Prefix..'color v ' then
				local v = tonumber(msg:sub(#Prefix+#'color v '+1))
				if v > 1 then main.v = 1 elseif v < -1 then main.v = -1 else main.v = v end

			elseif msg:lower():sub(1,#Prefix+#'theme ')==Prefix..'theme ' then
				local v = tonumber(msg:sub(#Prefix+#'theme '+1))
				themeid = v
				music(themeid,themepitch)

			elseif msg:lower():sub(1,#Prefix+#'pitch ')==Prefix..'pitch ' then
				local v = tonumber(msg:sub(#Prefix+#'pitch '+1))
				themepitch = v
				music(themeid,themepitch)

			elseif msg:lower():sub(1,#Prefix+#'prefix ')==Prefix..'prefix ' then
				local v = msg:sub(#Prefix+#'prefix '+1)
				Prefix = v

			elseif msg:lower():sub(1,#Prefix+#'reset')==Prefix..'reset' then
				main.r = 0
				main.g = 100
				main.b = 255
				main.v = 1
				themeid = 556122490
				themepitch = 1
				music(themeid,themepitch)

			end

		end)
		----------------------------------------------------------------------------
		no_anim = false
		attack = false
		attacking = false
		canjump = true
		aiming_anim = false
		animid = math.random(0,1)
		timer = 0
		bg = Instance.new("BodyGyro",root)
		bg.P = 100000
		bg.D = 100
		----------------------------------------------------------------------------

		function rswait(value)
			if value ~= nil and value ~= 0 then
				for i=1,value do
					rs:wait()
				end
			else
				rs:wait()
			end
		end

		----------------------------------------------------------------------------
		max = 0
		function music(id,pitch)
			max = 0
			if id == "Stop" then
				if not torso:FindFirstChild("MusicRuin") then
					soundz = Instance.new("Sound",torso)
				end
				soundz:Stop()
			else
				if not torso:FindFirstChild("MusicRuin") then
					soundz = Instance.new("Sound",torso)
				end
				soundz.MaxDistance = 150*5
				soundz.EmitterSize = 150/5
				soundz.Volume = 10
				soundz.Name = "MusicRuin"
				soundz.Looped = true
				soundz.PlaybackSpeed = pitch
				soundz.SoundId = "rbxassetid://"..id
				soundz:Stop()
				soundz:Play()
			end
		end

		----------------------------------------------------------------------------

		function lerp(a, b, t)
			return a + (b - a)*t
		end

		----------------------------------------------------------------------------

		function Lerp(c1,c2,al)
			local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}
			local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}
			for i,v in pairs(com1) do
				com1[i] = v+(com2[i]-v)*al
			end
			return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))
		end

		----------------------------------------------------------------------------

		function slerp(a, b, t)
			dot = a:Dot(b)
			if dot > 0.99999 or dot < -0.99999 then
				return t <= 0.5 and a or b
			else
				r = math.acos(dot)
				return (a*math.sin((1 - t)*r) + b*math.sin(t*r)) / math.sin(r)
			end
		end

		----------------------------------------------------------------------------

		function clerp(c1,c2,al)

			local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}

			local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}

			for i,v in pairs(com1) do

				com1[i] = lerp(v,com2[i],al)

			end

			return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))

		end

		----------------------------------------------------------------------------

		function findAllNearestTorso(pos,dist)
			local list = game.Workspace:children()
			local torso = {}
			local temp = nil
			local human = nil
			local temp2 = nil
			for x = 1, #list do
				temp2 = list[x]
				if (temp2.className == "Model") and (temp2 ~= char) then
					local nayem = "Torso"
					if temp2:findFirstChild("UpperTorso") then nayem = "UpperTorso" end
					temp = temp2:findFirstChild(nayem)
					human = temp2:findFirstChildOfClass("Humanoid")
					if (temp ~= nil) and (human ~= nil) and (human.Health > 0) then
						if (temp.Position - pos).magnitude < dist then
							table.insert(torso,temp)
							dist = (temp.Position - pos).magnitude
						end
					end
				end
			end
			return torso
		end

		----------------------------------------------------------------------------

		local isAPlayer
		function checkIfNotPlayer(model)
			coroutine.resume(coroutine.create(function()
				if model ~= char and model.Parent ~= char and model.Parent.Parent ~= char and model.Parent ~= DebrisModel and model.Parent.Parent ~= DebrisModel and model.Parent.Parent.Parent ~= DebrisModel then
					isAPlayer = true
				else
					isAPlayer = false
				end
			end))
			return isAPlayer
		end

		----------------------------------------------------------------------------

		function computeDirection(vec)
			local lenSquared = vec.magnitude * vec.magnitude
			local invSqrt = 1 / math.sqrt(lenSquared)
			return Vector3.new(vec.x * invSqrt, vec.y * invSqrt, vec.z * invSqrt)
		end

		----------------------------------------------------------------------------

		function newWeld(wp0, wp1, wc0x, wc0y, wc0z)

			local wld = Instance.new("Weld", wp1)

			wld.Part0 = wp0

			wld.Part1 = wp1

			wld.C0 = CFrame.new(wc0x, wc0y, wc0z)

			return wld

		end

		----------------------------------------------------------------------------

		function weld(model)
			local parts,last = {}
			local function scan(parent)
				for _,v in pairs(parent:GetChildren()) do
					if (v:IsA("BasePart")) then
						if (last) then
							local w = Instance.new("Weld")
							w.Name = ("%s_Weld"):format(v.Name)
							w.Part0,w.Part1 = last,v
							w.C0 = last.CFrame:inverse()
							w.C1 = v.CFrame:inverse()
							w.Parent = last
						end
						last = v
						table.insert(parts,v)
					end
					scan(v)
				end
			end
			scan(model)
			for _,v in pairs(parts) do
				v.Anchored = false
				v.Locked = true
			end
		end

		----------------------------------------------------------------------------

		function sound(id,position,vol,pitch,dist,start,finish)
			coroutine.resume(coroutine.create(function()

				local part = Instance.new("Part",DebrisModel)
				part.Anchored = true
				part.Position = position
				part.Size = Vector3.new(0,0,0)
				part.CanCollide = false
				part.Transparency = 1

				soundasd = Instance.new("Sound",part)

				soundasd.SoundId = "rbxassetid://"..id

				if vol ~= nil then
					soundasd.Volume = vol
				end

				if pitch ~= nil then
					soundasd.PlaybackSpeed = pitch
				end

				if dist ~= nil then
					soundasd.MaxDistance = dist*5
					soundasd.EmitterSize = dist/5
				end

				delay(0.5,function() debris:AddItem(part,soundasd.TimeLength+3) end)

				soundasd:Play()

			end))
			return soundasd
		end

		function createsound(id,parent)

			local soundz = Instance.new("Sound",parent)

			soundz.SoundId = "rbxassetid://"..id

			return soundz

		end

		function playsound(sond,vol,pitch,start)

			if vol ~= nil then
				sond.Volume = vol
			end

			if pitch ~= nil then
				sond.PlaybackSpeed = pitch
			end

			if start ~= nil then
				sond.TimePosition = start
			end

			sond:Play()

		end

		----------------------------------------------------------------------------
		eColors={"Really red","Really black"}
		function Lightning(Part0,Part1,Times,Offset,Color,Thickness,Trans)
			local magz = (Part0 - Part1).magnitude
			local curpos = Part0
			local trz = {-Offset,Offset} 
			for i=1,Times do
				local li = Instance.new("Part", DebrisModel)
				li.TopSurface =0
				li.Material = Enum.Material.Neon
				li.BottomSurface = 0
				li.Anchored = true
				li.Locked = true
				li.Transparency = Trans or 0.4
				li.BrickColor = BrickColor.new(Color)
				li.formFactor = "Custom"
				li.CanCollide = false
				li.Size = Vector3.new(Thickness,Thickness,magz/Times)
				local lim = Instance.new("BlockMesh",li)
				local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
				local trolpos = CFrame.new(curpos,Part1)*CFrame.new(0,0,magz/Times).p+Offzet
				if Times == i then
					local magz2 = (curpos - Part1).magnitude
					li.Size = Vector3.new(Thickness,Thickness,magz2)
					li.CFrame = CFrame.new(curpos,Part1)*CFrame.new(0,0,-magz2/2)
				else
					li.CFrame = CFrame.new(curpos,trolpos)*CFrame.new(0,0,magz/Times/2)
				end
				curpos = li.CFrame*CFrame.new(0,0,magz/Times/2).p
				li.Name = "LIGHTNING"
			end
		end

		----------------------------------------------------------------------------

		local HBill = Instance.new("BillboardGui",hed)
		local HMain, HBar = Instance.new("Frame", HBill), Instance.new("Frame")
		local HName = Instance.new("TextLabel")
		HBill.Size = UDim2.new(15,0,2.2,0)
		HBill.StudsOffset = Vector3.new(3.675,1.2,0)
		HBill.AlwaysOnTop = true
		HBill.Enabled = true
		HMain.BackgroundColor3 = Color3.new(0, 0, 0)
		HMain.BackgroundTransparency = 1
		HMain.Size = UDim2.new(.5,0,.2,0)
		HName.Parent = HMain
		HName.BackgroundTransparency = 1
		HName.BackgroundColor3 = Color3.new(255,255,255)
		HName.BorderColor3 = Color3.new(0,0,0)
		HName.BorderSizePixel = 2
		HName.Size = UDim2.new(1,0,.75,0)
		HName.Font = "Code"
		HName.Text = [[(Amatsumika Starlight)]]
		HName.TextScaled = true
		HName.TextColor3 = Color3.new(0.5,0.5,0.5)
		HName.TextStrokeColor3 = Color3.new(0.1,0.1,0.1)
		HName.TextStrokeTransparency = 0
		HName.TextYAlignment = "Bottom"

		local HBill = Instance.new("BillboardGui",hed)
		local HMain, HBar = Instance.new("Frame", HBill), Instance.new("Frame")
		local HName = Instance.new("TextLabel")
		HBill.Size = UDim2.new(15,0,2.2,0)
		HBill.StudsOffset = Vector3.new(3.675,2,0)
		HBill.AlwaysOnTop = true
		HBill.Enabled = true
		HMain.BackgroundColor3 = Color3.new(0, 0, 0)
		HMain.BackgroundTransparency = 1
		HMain.Size = UDim2.new(.5,0,.5,0)
		HName.Parent = HMain
		HName.BackgroundTransparency = 1
		HName.BackgroundColor3 = Color3.new(255,255,255)
		HName.BorderColor3 = Color3.new(0,0,0)
		HName.BorderSizePixel = 2
		HName.Size = UDim2.new(1,0,.75,0)
		HName.Font = "Code"
		HName.Text = [[]]
		HName.TextScaled = true
		HName.TextColor3 = Color3.new(0,0,0)
		HName.TextStrokeColor3 = Color3.new(255,255,255)
		HName.TextStrokeTransparency = 0
		HName.TextYAlignment = "Bottom"

		function bigboomrektxd()
			coroutine.resume(coroutine.create(function()
				local magnitude = nil
				local Position = nil
				if animid == 0 then
					Position = larm.Position
				else
					Position = rarm.Position
				end
				--sound(743499393,Position,10,math.random(6,8)/10)
				sound(440145223,Position,10,math.random(10,12)/10,50)

				local Part1 = Instance.new("Part")
				local mesh2 = Instance.new("SpecialMesh",Part1)
				mesh2.MeshId = "rbxassetid://559831844"
				mesh2.Scale = Vector3.new(0,0,0.4)
				Part1.Material = Enum.Material.Neon
				Part1.CanCollide = false
				Part1.Color = Color3.fromHSV(0,0,main.v)
				Part1.Parent = DebrisModel
				Part1.Size = Vector3.new(0,0,0)
				Part1.Anchored = true
				Part1.CFrame = CFrame.new(Position,mouse.Hit.p)
				Part1.Name = "EXPLOSION2"

				local Part0 = Instance.new("Part",DebrisModel)
				local PointLight2 = Instance.new("PointLight")
				Part0.Name = "Bullet"
				Part0.Material = Enum.Material.Neon
				Part0.Color = Color3.fromHSV(0,0,main.v)
				Part0.Anchored = false
				Part0.Size = Vector3.new(5, 5, 5)
				local mesh = Instance.new("SpecialMesh",Part0)
				mesh.MeshType = Enum.MeshType.Sphere
				local bforce = Instance.new("BodyForce",Part0)
				bforce.force = Vector3.new(0, ((bforce.Parent:getMass())*workspace.Gravity), 0)
				Part0.CanCollide = false
				PointLight2.Parent = Part0
				PointLight2.Color = Part0.Color
				local Target = mouse.Hit.p
				local direction = Target - Position
				local direction = computeDirection(direction)
				local pos = Position + (direction * 2) 
				Part0.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)
				Part0.Velocity = direction * 60
				local asd = nil
				local loop = nil
				delay(5, function() Part0:Destroy() loop:disconnect() asd:disconnect() end)
				loop = rs:connect(function()
					local asdf = math.random(500,1000)/1000
					local Part1 = Instance.new("Part")
					local mesh2 = Instance.new("SpecialMesh",Part1)
					mesh2.MeshType = Enum.MeshType.Sphere
					Part1.Material = Enum.Material.Neon
					Part1.CanCollide = false
					Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
					Part1.Parent = DebrisModel
					Part1.Size = Part0.Size + Vector3.new(asdf,asdf,asdf)
					Part1.Anchored = true
					Part1.CFrame = CFrame.new(Part0.Position + Vector3.new(math.random(-1000,1000)/750,math.random(-1000,1000)/750,math.random(-1000,1000)/750))
					Part1.Name = "SMOKE"
				end)
				asd = Part0.Touched:connect(function(ht)
					local hit=ht.Parent
					if checkIfNotPlayer(ht) == true and ht.CanCollide == true then
						asd:disconnect()
						loop:disconnect()
						Part0:Destroy()

						sound(explosionid[math.random(1,#explosionid)],Part0.Position,10,math.random(6,9)/10,200)
						for i,v in pairs(findAllNearestTorso(Part0.Position,50)) do
							if v.Parent:FindFirstChildOfClass("Humanoid").MaxHealth >= 9e+99 then
								v:Destroy()
							else
							end
							local Position = Part0.Position
							local Target = v.Position
							local direction = Target - Position
							local direction = computeDirection(direction)
							local bv = Instance.new("BodyVelocity",v)
							bv.Velocity = direction * (50 - ((Position - Target).magnitude/2))
							debris:AddItem(bv,1)
						end
						for i=1,14,2 do for x=1,math.random(0,1) do rs:wait() end
							for z=1,math.random(2,3) do
								local asdf = math.random(-5,5)*10-(i/20)*8
								local Part1 = Instance.new("Part")
								local mesh2 = Instance.new("SpecialMesh",Part1)
								mesh2.MeshType = Enum.MeshType.Sphere
								mesh2.Scale = Vector3.new(0,0,0)
								Part1.Material = Enum.Material.Neon
								Part1.CanCollide = false
								Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
								Part1.Parent = DebrisModel
								Part1.Size = Vector3.new(asdf,asdf,asdf)
								Part1.Anchored = true
								local a = i*0.5
								Part1.CFrame = CFrame.new(Part0.Position + Vector3.new(math.random(-2,2)*a,math.random(-10,10),math.random(-2,2)*a))
								Part1.Name = "EXPLOSION"
							end
						end

					end
				end)
			end))
		end

		holdclick=false

		mouse.Button1Down:connect(function()
			if debounce == false then
				if animid == 0 then
					animid = 1
				else
					animid = 0
				end
				debounce = true
				holdclick = true
				aiming_anim = true
				wait(0.2)
				repeat 
					rs:wait()
					timer = 150
				until holdclick == false
				bigboomrektxd()

				local Position = mouse.Hit.p
				local Target = root.Position
				local direction = Target - Position
				local direction = computeDirection(direction)
				root.Velocity = direction * 150

				aiming_anim = false
				delay(0.3,function() debounce = false end)
			end
		end)

		mouse.Button1Up:connect(function()
			holdclick=false
		end)

		function dashasdf()
			debounce = true

			canjump = false
			attack = true

			for i,v in pairs(char:GetChildren()) do
				if v ~= root then
					if v:IsA("Part") then
						v.Transparency = 1
					elseif v:IsA("Accoutrement") then
						v:FindFirstChildOfClass("Part").Transparency = 1
					end
				end
			end

			local tempattachment = Instance.new("Attachment",root)
			tempattachment.Position = Vector3.new(0,0,-4)

			for i=1,20 do rs:wait()
				root.Velocity = Vector3.new(0,0,0)
				root.CFrame = CFrame.new(tempattachment.WorldPosition) * CFrame.Angles(math.rad(root.Orientation.X),math.rad(root.Orientation.Y),math.rad(root.Orientation.Z))
				local asdf = math.random(500,1000)/100
				local Part1 = Instance.new("Part")
				local mesh2 = Instance.new("SpecialMesh",Part1)
				mesh2.MeshType = Enum.MeshType.Sphere
				Part1.Material = Enum.Material.Neon
				Part1.CanCollide = false
				Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
				Part1.Parent = DebrisModel
				Part1.Size = Vector3.new(asdf,asdf,asdf)
				Part1.Anchored = true
				Part1.CFrame = CFrame.new(root.Position + Vector3.new(math.random(-1000,1000)/500,math.random(-1000,1000)/500,math.random(-1000,1000)/500))
				Part1.Name = "SMOKE"
			end

			tempattachment:Destroy()

			for i,v in pairs(char:GetChildren()) do
				if v ~= root then
					if v:IsA("Part") then
						v.Transparency = 0
					elseif v:IsA("Accoutrement") then
						v:FindFirstChildOfClass("Part").Transparency = 0
					end
				end
			end

			canjump = true
			attack = false

			delay(0.1,function() debounce = false end)
		end

		function laz0r()

			local Position = nil
			if animid == 0 then
				Position = larm.Position
			else
				Position = rarm.Position
			end

			local Part1 = Instance.new("Part")
			local mesh2 = Instance.new("SpecialMesh",Part1)
			mesh2.MeshId = "rbxassetid://559831844"
			mesh2.Scale = Vector3.new(0,0,0.4)
			Part1.Material = Enum.Material.Neon
			Part1.CanCollide = false
			Part1.Color = Color3.fromHSV(0,0,main.v)
			Part1.Parent = DebrisModel
			Part1.Size = Vector3.new(0,0,0)
			Part1.Anchored = true
			Part1.CFrame = CFrame.new(Position,mouse.Hit.p)
			Part1.Name = "EXPLOSION3"

			local Part0 = Instance.new("Part",DebrisModel)
			Part0.Name = "Bullet"
			Part0.Material = Enum.Material.Neon
			Part0.Color = Color3.fromHSV(0,0,main.v)
			Part0.Anchored = true
			local mesh = Instance.new("SpecialMesh",Part0)
			mesh.MeshType = Enum.MeshType.Sphere
			Part0.CanCollide = false
			local Target = mouse.Hit.p
			local direction = Target - Position
			local direction = computeDirection(direction)
			local ray = Ray.new(Position, (Target-Position).unit*1048)
			local part, endPoint = workspace:FindPartOnRay(ray, char)
			Part0.Size = Vector3.new(5,1,5)
			mesh.Scale = Vector3.new(1,(Position-endPoint).magnitude,1)
			local pos = Position + (direction * (mesh.Scale.Y/2))
			Part0.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)

			clashpart = Instance.new("Part",DebrisModel)
			clashpart.Size = Vector3.new(50,50,50)
			clashpart.CanCollide = false
			clashpart.Anchored = true
			clashpart.Transparency = 1
			clashpart.Color = main_color
			clashpart.Name = "StarLightClash"
			clashpart.CFrame = CFrame.new(endPoint, root.Position)

			sound(1177475476,Position,10,math.random(5,6)/10,300)

			local z = 10
			for i = 1,100 do rs:wait()
				if animid == 0 then
					Position = larm.Position
				else
					Position = rarm.Position
				end
				local Target = mouse.Hit.p
				local direction = Target - Position
				local direction = computeDirection(direction)
				local ray = Ray.new(Position, (Target-Position).unit*1048)
				local part, endPoint = workspace:FindPartOnRay(ray, char)
				Part0.Size = Vector3.new(5-((i/100)*5),1,5-((i/100)*5))
				mesh.Scale = Vector3.new(1,(Position-endPoint).magnitude,1)
				mesh.Offset = Vector3.new(math.random(-10000,10000)/20000,math.random(-10000,10000)/20000,0)
				local pos = Position + (direction * (mesh.Scale.Y/2))
				Part0.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)
				clashpart.CFrame = CFrame.new(endPoint, root.Position)

				local Position = mouse.Hit.p
				local Target = root.Position
				local direction = Target - Position
				local direction = computeDirection(direction)
				root.Velocity = direction * 5

				if i >= z then z = i + 10 sound(explosionid[math.random(1,#explosionid)],endPoint,10,math.random(6,9)/10,200) end

				Part1 = Part0:Clone()
				Part1.Parent = DebrisModel
				Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
				Part1.Name = "SMOKE2"

				if part ~= nil then
					if part.Name == "StarLightClash" then
						local asdf = math.random(0,5)*20
						local Part1 = Instance.new("Part")
						local mesh2 = Instance.new("SpecialMesh",Part1)
						mesh2.MeshType = Enum.MeshType.Sphere
						mesh2.Scale = Vector3.new(0,0,0)
						Part1.Material = Enum.Material.Neon
						Part1.CanCollide = false
						Part1.Color = Color3.fromHSV(Color3.toHSV(Color3.fromRGB((main.r+(255*part.Color.r))/2,(main.g+(255*part.Color.g))/2,(main.b+(255*part.Color.b))/2)),math.random(5000,10000)/10000,main.v)
						Part1.Parent = DebrisModel
						Part1.Size = Vector3.new(asdf,asdf,asdf)
						Part1.Anchored = true
						local a = 1.5
						Part1.CFrame = CFrame.new(endPoint + Vector3.new(math.random(-2,2)*a,math.random(-4,4),math.random(-2,2)*a))
						Part1.Name = "EXPLOSION"
					else
						local asdf = math.random(0,5)*10
						local Part1 = Instance.new("Part")
						local mesh2 = Instance.new("SpecialMesh",Part1)
						mesh2.MeshType = Enum.MeshType.Sphere
						mesh2.Scale = Vector3.new(0,0,0)
						Part1.Material = Enum.Material.Neon
						Part1.CanCollide = false
						Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
						Part1.Parent = DebrisModel
						Part1.Size = Vector3.new(asdf,asdf,asdf)
						Part1.Anchored = true
						local a = 1.5
						Part1.CFrame = CFrame.new(endPoint + Vector3.new(math.random(-2,2)*a,math.random(-4,4),math.random(-2,2)*a))
						Part1.Name = "EXPLOSION"
					end
				end

				for i,v in pairs(findAllNearestTorso(endPoint,50)) do
					if v.Parent:FindFirstChildOfClass("Humanoid").MaxHealth >= 9e+99 then
						v:Destroy()
					else
					end
					local Position = mouse.Hit.p
					local Target = v.Position
					local direction = Target - Position
					local direction = computeDirection(direction)
					local bv = Instance.new("BodyVelocity",v)
					bv.Velocity = direction * (10 - ((Position - Target).magnitude/2))
					debris:AddItem(bv,1)
				end

			end
			clashpart:Destroy()
			Part0:Destroy()
			wait(0.3)
			aiming_anim = false
			delay(0.3,function() debounce = false end)
		end

		function nukewelpo()
			coroutine.resume(coroutine.create(function()
				local magnitude = nil
				local Position = nil
				if animid == 0 then
					Position = larm.Position
				else
					Position = rarm.Position
				end
				--sound(743499393,Position,10,math.random(6,8)/10)
				sound(440145223,Position,10,math.random(4,5)/10,100)

				local Part1 = Instance.new("Part")
				local mesh2 = Instance.new("SpecialMesh",Part1)
				mesh2.MeshId = "rbxassetid://559831844"
				mesh2.Scale = Vector3.new(0,0,0.4)
				Part1.Material = Enum.Material.Neon
				Part1.CanCollide = false
				Part1.Color = Color3.fromHSV(0,0,main.v)
				Part1.Parent = DebrisModel
				Part1.Size = Vector3.new(0,0,0)
				Part1.Anchored = true
				Part1.CFrame = CFrame.new(Position,mouse.Hit.p)
				Part1.Name = "EXPLOSION3"

				local Part0 = Instance.new("Part",DebrisModel)
				local PointLight2 = Instance.new("PointLight")
				Part0.Name = "Bullet"
				Part0.Material = Enum.Material.Neon
				Part0.Color = Color3.fromHSV(0,0,main.v)
				Part0.Anchored = false
				Part0.Size = Vector3.new(5, 5, 5)
				local mesh = Instance.new("SpecialMesh",Part0)
				mesh.MeshType = Enum.MeshType.Sphere
				mesh.Scale = Vector3.new(3,3,3)
				local bforce = Instance.new("BodyForce",Part0)
				bforce.force = Vector3.new(0, ((bforce.Parent:getMass())*workspace.Gravity), 0)
				Part0.CanCollide = false
				PointLight2.Parent = Part0
				PointLight2.Color = Part0.Color
				local Target = mouse.Hit.p
				local direction = Target - Position
				local direction = computeDirection(direction)
				local pos = Position + (direction * 2) 
				Part0.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)
				Part0.Velocity = direction * 150
				local asd = nil
				local loop = nil
				delay(5, function() Part0:Destroy() loop:disconnect() asd:disconnect() end)
				loop = rs:connect(function()
					local asdf = math.random(500,1000)/1000
					local Part1 = Instance.new("Part")
					local mesh2 = Instance.new("SpecialMesh",Part1)
					mesh2.MeshType = Enum.MeshType.Sphere
					Part1.Material = Enum.Material.Neon
					Part1.CanCollide = false
					Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
					Part1.Parent = DebrisModel
					Part1.Size = (Part0.Size*3) + Vector3.new(asdf,asdf,asdf)
					Part1.Anchored = true
					Part1.CFrame = CFrame.new(Part0.Position + Vector3.new(math.random(-3000,3000)/750,math.random(-3000,3000)/750,math.random(-3000,3000)/750))
					Part1.Name = "SMOKE"
				end)
				asd = Part0.Touched:connect(function(ht)
					local hit=ht.Parent
					if checkIfNotPlayer(ht) == true and ht.CanCollide == true then
						asd:disconnect()
						loop:disconnect()
						Part0:Destroy()

						sound(explosionid[math.random(1,#explosionid)],Part0.Position,10,math.random(3,5)/10,500)
						for i,v in pairs(findAllNearestTorso(Part0.Position,160)) do
							if v.Parent:FindFirstChildOfClass("Humanoid").MaxHealth >= 9e+99 then
								v:Destroy()
							else
							end
							local Position = Part0.Position
							local Target = v.Position
							local direction = Target - Position
							local direction = computeDirection(direction)
							local bv = Instance.new("BodyVelocity",v)
							bv.Velocity = direction * (120 - ((Position - Target).magnitude/2))
							debris:AddItem(bv,1)
						end
						for i=1,10,0.5 do for x=1,math.random(0,1) do rs:wait() end
							for z=1,math.random(2,3) do
								local asdf = math.random(-5,5)*10-(i/20)*12
								local Part1 = Instance.new("Part")
								local mesh2 = Instance.new("SpecialMesh",Part1)
								mesh2.MeshType = Enum.MeshType.Sphere
								mesh2.Scale = Vector3.new(0,0,0)
								Part1.Material = Enum.Material.Neon
								Part1.CanCollide = false
								Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
								Part1.Parent = DebrisModel
								Part1.Size = Vector3.new(asdf,asdf,asdf)
								Part1.Anchored = true
								local a = i*5
								Part1.CFrame = CFrame.new(Part0.Position + Vector3.new(math.random(-2,2)*a,math.random(-30,30),math.random(-2,2)*a))
								Part1.Name = "EXPLOSION4"
							end
						end

					end
				end)
			end))
		end

		holdq = false
		holdr = false
		cooldownult = false

		mouse.KeyDown:connect(function(key)
			if debounce == false then
				if key == "e" then
					dashasdf()
				elseif key == "r" and cooldownult == false then
					cooldownult = true
					if animid == 0 then
						animid = 1
					else
						animid = 0
					end
					debounce = true
					holdr = true
					aiming_anim = true
					wait(0.2)
					repeat 
						rs:wait()
						timer = 150
					until holdr == false
					nukewelpo()

					local Position = mouse.Hit.p
					local Target = root.Position
					local direction = Target - Position
					local direction = computeDirection(direction)
					root.Velocity = direction * 300

					aiming_anim = false
					delay(5,function() cooldownult = false end)
					delay(1,function() debounce = false end)

				elseif key == "q" then
					debounce = true
					if animid == 0 then
						animid = 1
					else
						animid = 0
					end
					holdq = true
					attack = true
					aiming_anim = true
					repeat rs:wait() timer = 150 until holdq == false
					laz0r()
					attack = false
				end
			end
		end)

		mouse.KeyUp:connect(function(key)
			if key == "q" then
				holdq = false
			elseif key == "r" then
				holdr = false
			end
		end)

		----------------------------------------------------------------------------
		music(themeid,themepitch)
		velocityYFall=0
		velocityYFall2=0
		velocityYFall3=0
		velocityYFall4=0
		neckrotY=0
		neckrotY2=0
		torsorotY=0
		torsorotY2=0
		torsoY=0
		torsoY2=0
		sine = 0
		newWeld(torso, larm, -1.5, 0.5, 0)
		larm.Weld.C1 = CFrame.new(0, 0.5, 0)
		newWeld(torso, rarm, 1.5, 0.5, 0)
		rarm.Weld.C1 = CFrame.new(0, 0.5, 0)
		newWeld(torso, hed, 0, 1.5, 0)
		newWeld(torso, lleg, -0.5, -1, 0)
		lleg.Weld.C1 = CFrame.new(0, 1, 0)
		newWeld(torso, rleg, 0.5, -1, 0)
		rleg.Weld.C1 = CFrame.new(0, 1, 0)
		newWeld(root, torso, 0, -1, 0)
		torso.Weld.C1 = CFrame.new(0, -1, 0)

		rs:connect(function()

			bg.MaxTorque = Vector3.new(0,0,0)

			for i,v in pairs(DebrisModel:GetChildren()) do


				if v.Name == "EXPLOSION" then
					local change = 0.04-(v.Transparency*0.02)
					local vm = v:FindFirstChildOfClass("SpecialMesh")
					vm.Scale = vm.Scale + Vector3.new(change,change,change)
					v.Transparency = v.Transparency + 0.02
					if v.Transparency >= 1 then
						v:Destroy()
					end

				elseif v.Name == "EXPLOSION2" then
					local change = 0.04-(v.Transparency*0.04)
					local vm = v:FindFirstChildOfClass("SpecialMesh")
					vm.Scale = vm.Scale + Vector3.new(change,change,0)
					v.Transparency = v.Transparency + 0.025
					if v.Transparency >= 1 then
						v:Destroy()
					end

				elseif v.Name == "EXPLOSION3" then
					local change = 0.5-(v.Transparency*0.5)
					local vm = v:FindFirstChildOfClass("SpecialMesh")
					vm.Scale = vm.Scale + Vector3.new(change,change,0)
					v.Transparency = v.Transparency + 0.1
					if v.Transparency >= 1 then
						v:Destroy()
					end

				elseif v.Name == "EXPLOSION4" then
					local change = 0.15-(v.Transparency*0.125)
					local vm = v:FindFirstChildOfClass("SpecialMesh")
					vm.Scale = vm.Scale + Vector3.new(change,change,change)
					v.Transparency = v.Transparency + 0.01
					if v.Transparency >= 1 then
						v:Destroy()
					end

				elseif v.Name == "SMOKE" then
					local vm = v:FindFirstChildOfClass("SpecialMesh")
					vm.Scale = vm.Scale - Vector3.new(0.075,0.075,0.075)
					if vm.Scale.X <= 0 then
						v:Destroy()
					end

				elseif v.Name == "SMOKE2" then
					local change = 2-(v.Transparency*2)
					local vm = v:FindFirstChildOfClass("SpecialMesh")
					local Position = nil
					if animid == 0 then
						Position = larm.Position
					else
						Position = rarm.Position
					end
					local Target = mouse.Hit.p
					local direction = Target - Position
					local direction = computeDirection(direction)
					local ray = Ray.new(Position, (Target-Position).unit*1048)
					local part, endPoint = workspace:FindPartOnRay(ray, char)
					vm.Scale = Vector3.new(vm.Scale.X,(Position-endPoint).magnitude,vm.Scale.Z) + Vector3.new(change,0,change)
					local pos = Position + (direction * (vm.Scale.Y/2))
					v.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)
					vm.Offset = Vector3.new(math.random(-10000,10000)/10000,math.random(-10000,10000)/10000,0)
					v.Transparency = v.Transparency + 0.1
					if v.Transparency >= 1 then
						v:Destroy()
					end


				elseif v.Name == "LIGHTNING" then
					local vm = v:FindFirstChildOfClass("BlockMesh")
					vm.Scale = vm.Scale - Vector3.new(0.1,0.1,0)
					if vm.Scale.X <= 0 then
						v:Destroy()
					end

				end
			end

			if -root.Velocity.Y/1.5 > 0 and -root.Velocity.Y/1.5 < 160 then
				velocityYFall = root.Velocity.Y/1.5
			end
			if -root.Velocity.Y/180 > 0 and -root.Velocity.Y/180 < 1.2 then
				velocityYFall2 = root.Velocity.Y/180
			end
			if -root.Velocity.Y/1.5 > -5 and -root.Velocity.Y/1.5 < 50 then
				velocityYFall3 = root.Velocity.Y/1.5
			end
			if -root.Velocity.Y/1.5 > -50 and -root.Velocity.Y/1.5 < 20 then
				velocityYFall4 = root.Velocity.Y/1.5
			end
			if root.RotVelocity.Y/6 < 1 and root.RotVelocity.Y/6 > -1 then
				neckrotY = root.RotVelocity.Y/6
			end
			if root.RotVelocity.Y/8 < 0.6 and root.RotVelocity.Y/8 > -0.6 then
				neckrotY2 = root.RotVelocity.Y/8
			end

			if root.RotVelocity.Y/6 < 0.2 and root.RotVelocity.Y/6 > -0.2 then
				torsorotY = root.RotVelocity.Y/6
			end
			if root.RotVelocity.Y/8 < 0.2 and root.RotVelocity.Y/8 > -0.2 then
				torsorotY2 = root.RotVelocity.Y/8
			end


			torsoY = -(torso.Velocity*Vector3.new(1, 0, 1)).magnitude/20
			torsoY2 = -(torso.Velocity*Vector3.new(1, 0, 1)).magnitude/36

			if attack == true then
				hum.WalkSpeed = 1
			else
				hum.WalkSpeed = 8
			end

			if canjump == true then
				hum.JumpPower = 50
			else
				hum.JumpPower = 0
			end

			local jumped = false
			local ray1 = Ray.new(root.Position+Vector3.new(1,0,0),Vector3.new(0, -6, 0))
			local part1, endPoint = workspace:FindPartOnRay(ray1, char)
			local ray2 = Ray.new(root.Position-Vector3.new(1,0,0),Vector3.new(0, -6, 0))
			local part2, endPoint = workspace:FindPartOnRay(ray2, char)
			local ray3 = Ray.new(root.Position+Vector3.new(0,0,0.5),Vector3.new(0, -6, 0))
			local part3, endPoint = workspace:FindPartOnRay(ray3, char)
			local ray4 = Ray.new(root.Position-Vector3.new(0,0,0.5),Vector3.new(0, -6, 0))
			local part4, endPoint = workspace:FindPartOnRay(ray4, char)

			if part1 or part2 or part3 or part4 then jumped = false else endPoint = 0 jumped = true end

			local rlegray = Ray.new(rleg.Position+Vector3.new(0,0.5,0),Vector3.new(0, -1.75, 0))
			local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)

			local llegray = Ray.new(lleg.Position+Vector3.new(0,0.5,0),Vector3.new(0, -1.75, 0))
			local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)

			if no_anim == false then
				if hum.Health > 0 then
					if (torso.Velocity*Vector3.new(1, 0, 1)).magnitude >= 5 and jumped == false then
						hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-18),math.rad(0+math.rad(0+2*math.cos(sine/2))),0), 0.1)
						hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-10),0,0),0.1)
						rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.62-(movement/30)*math.cos(sine/4)/2,(movement/50)*math.cos(sine/4))*CFrame.Angles(math.rad(-5-(movement*2)*math.cos(sine/4))+ -(movement/10)*math.sin(sine/4),math.rad(0-(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
						larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.62+(movement/30)*math.cos(sine/4)/2,-(movement/50)*math.cos(sine/4))*CFrame.Angles(math.rad(-5+(movement*2)*math.cos(sine/4))+ (movement/10)*math.sin(sine/4),math.rad(0-(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
						torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1+(movement/20)*math.cos(sine/2), 0) * CFrame.Angles(math.rad(-(change*20)-4*math.cos(sine/2)), torsorotY2+math.rad(0-4*math.cos(sine/4)), torsorotY2+math.rad(0-1*math.cos(sine/4))), 0.1)
						lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.85-(movement/10)*math.cos(sine/4)/2,-0.1+(movement/15)*math.cos(sine/4))*CFrame.Angles(math.rad(-10+(change*5)-movement*math.cos(sine/4))+ -(movement/10)*math.sin(sine/4),math.rad(0+(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
						rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,-0.85+(movement/10)*math.cos(sine/4)/2,-0.1-(movement/15)*math.cos(sine/4))*CFrame.Angles(math.rad(-10+(change*5)+movement*math.cos(sine/4))+ (movement/10)*math.sin(sine/4),math.rad(0+(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
					elseif jumped == true then
						hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-18),math.rad(0+math.rad(0+2*math.cos(sine/2))),0), 0.1)
						hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(0,0,0),0.1)
						larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,1-0.1*math.cos(sine/16)/2,0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(0-1*math.cos(sine/16)),math.rad(-50-1*math.cos(sine/8))), 0.2)
						rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,1-0.1*math.cos(sine/16)/2,0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(0-1*math.cos(sine/16)),math.rad(50+1*math.cos(sine/8))), 0.2)
						torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1-0.1*math.cos(sine/16), 0) * CFrame.Angles(math.rad(0-2*math.cos(sine/16)),math.rad(0), math.rad(0-1*math.cos(sine/32))), 0.1)
						lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.925+0.1*math.cos(sine/16),0)*CFrame.Angles(math.rad(-35-1*math.cos(sine/16)),math.rad(0-1*math.cos(sine/16)),math.rad(-2-0.5*math.cos(sine/8))), 0.2)
						rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,0+0.1*math.cos(sine/16),-0.8)*CFrame.Angles(math.rad(-25+1*math.cos(sine/16)),math.rad(0-1*math.cos(sine/16)),math.rad(2+0.5*math.cos(sine/8))), 0.2)
					elseif (torso.Velocity*Vector3.new(1, 0, 1)).magnitude < 5 then
						hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.1)*CFrame.Angles(math.rad(-18),math.rad(0+math.rad(0+2*math.cos(sine/2))),0), 0.1)
						hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-15),0,0),0.1)
						larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55-0.1*math.cos(sine/16)/2,-0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(0-1*math.cos(sine/16)),math.rad(-5-1*math.cos(sine/8))), 0.2)
						rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55-0.1*math.cos(sine/16)/2,-0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(0-1*math.cos(sine/16)),math.rad(5+1*math.cos(sine/8))), 0.2)
						torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.1-0.1*math.cos(sine/16), 0) * CFrame.Angles(math.rad(0-2*math.cos(sine/16)),math.rad(0), math.rad(0-1*math.cos(sine/32))), 0.1)
						lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(0,llegendPoint.Y-lleg.Position.Y,0)*CFrame.new(-0.5,0+0.1*math.cos(sine/16),0)*CFrame.Angles(math.rad(0-1*math.cos(sine/16)),math.rad(0-1*math.cos(sine/16)),math.rad(-2-0.5*math.cos(sine/8))), 0.2)
						rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0,rlegendPoint.Y-rleg.Position.Y,0)*CFrame.new(0.5,0+0.1*math.cos(sine/16),0)*CFrame.Angles(math.rad(0+1*math.cos(sine/16)),math.rad(0-1*math.cos(sine/16)),math.rad(2+0.5*math.cos(sine/8))), 0.2)
					end
					for i=1,5 do
						if aiming_anim == true then
							bg.MaxTorque = Vector3.new(9e9,9e9,9e9)
							if jumped == false then
								bg.CFrame = CFrame.new(root.Position,Vector3.new(mouse.Hit.x,root.Position.Y,mouse.Hit.z))
							else
								bg.CFrame = CFrame.new(root.Position,mouse.Hit.p)
							end
							if animid == 0 then
								hed.Weld.C1 =  Lerp(hed.Weld.C1,CFrame.Angles(0,math.rad(-80),0),0.4)
								torso.Weld.C0 = Lerp(torso.Weld.C0,CFrame.new(0, -1.1-0.1*math.cos(sine/16), 0) * CFrame.Angles(math.rad(0-2*math.cos(sine/16)),math.rad(-80), math.rad(0-1*math.cos(sine/32))),0.2)
								larm.Weld.C0 = Lerp(larm.Weld.C0,CFrame.new(-1.5,0.55-0.1*math.cos(sine/16)/2,-0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(-10-1*math.cos(sine/16)),math.rad(-90-1*math.cos(sine/8))),0.4)
							else
								hed.Weld.C1 =  Lerp(hed.Weld.C1,CFrame.Angles(0,math.rad(80),0),0.4)
								torso.Weld.C0 = Lerp(torso.Weld.C0,CFrame.new(0, -1.1-0.1*math.cos(sine/16), 0) * CFrame.Angles(math.rad(0-2*math.cos(sine/16)),math.rad(80), math.rad(0-1*math.cos(sine/32))),0.2)
								rarm.Weld.C0 = Lerp(rarm.Weld.C0,CFrame.new(1.5,0.55-0.1*math.cos(sine/16)/2,-0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(10-1*math.cos(sine/16)),math.rad(90+1*math.cos(sine/8))),0.4)
							end
						else
							if timer <= 0 then
								animid = math.random(0,1)
							else
								timer = timer - 1
							end
						end
					end
				end
			end
			main_color = Color3.fromRGB(main.r,main.g,main.b)
			pr.Value = main.r
			pg.Value = main.g
			pb.Value = main.b
			pv.Value = main.v
			idth.Value = themeid
			pith.Value = themepitch
			HName.TextStrokeColor3 = Color3.fromHSV(Color3.toHSV(main_color),1,main.v/2)
			HName.TextColor3 = Color3.fromHSV(Color3.toHSV(main_color),1,main.v)
			sine = sine + change
			if hum.Health <= 0 then
				debounce = true
			end
		end)
	end)



reanims:Button(
	"Reanim V1",
	function()
		DiscordLib:Notification("PermAnim", "Reanim Succsesful", "Done!")

		if not _G.Velocity then _G.Velocity = Vector3.new(30,0,0) end

		-- adding net so we dont lose the body
		local plr = game.Players.LocalPlayer
		game:GetService("RunService").RenderStepped:Connect(function()
			settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
			settings().Physics.AllowSleep = false
			game.Players.LocalPlayer.ReplicationFocus = workspace
			sethiddenproperty(plr,"SimulationRadius",1000)
			sethiddenproperty(plr,"MaxSimulationRadius",1000)
		end)



		-- Creating Early Variables.
		local Player = game.Players.LocalPlayer
		local Character = Player.Character
		local PlayerName = Player.Name
		local Physics = settings().Physics
		local Head = Character:FindFirstChild("Head")
		local Torso = Character:FindFirstChild("Torso")
		local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
		local Humanoid = Character:FindFirstChild("Humanoid")
		local LeftArm = Character:FindFirstChild("Left Arm")
		local LeftLeg = Character:FindFirstChild("Left Leg")
		local RightArm = Character:FindFirstChild("Right Arm")
		local RightLeg = Character:FindFirstChild("Right Leg")
		local Reanimated = true

		if Humanoid.RigType == Enum.HumanoidRigType.R15 then
			game.StarterGui:SetCore("ChatMakeSystemMessage", {
				Text = "[PermAnim] You are on R15! Please use the R15 Reanimation instead.",
				Color = Color3.fromRGB(255, 10, 70),
				TextSize = 18,
				Font = Enum.Font.Ubuntu
			});
			return end
		if game.Players.LocalPlayer.Character:FindFirstChild("PermAnimated") or workspace:FindFirstChild("PermAnimated") then
			game.StarterGui:SetCore("ChatMakeSystemMessage", {
				Text = "[PermAnim] You are already reanimated! Please reset to unreanimate.",
				Color = Color3.fromRGB(255, 10, 70),
				TextSize = 18,
				Font = Enum.Font.Ubuntu
			});
			return end

		Physics.AllowSleep = false
		Physics.ThrottleAdjustTime = -9e9
		Player.ReplicationFocus = workspace
		Character.Archivable = true
		-- Checks if player died so it doesnt run again.
		game:WaitForChild("Run Service").RenderStepped:Connect(function()
			if Character:FindFirstChild("Humanoid").Health == 0 then
				Reanimated = false
				wait(9e9^30)
			end
		end)
		-- Start reanimation
		game:WaitForChild("Run Service").Heartbeat:Connect(function()
			if Reanimated == true then
				if Character.PermAnimated then
					Character.Torso.CFrame=Character.PermAnimated.Torso.CFrame
				end
				RightArm.Velocity = _G.Velocity
				RightLeg.Velocity =_G.Velocity
				LeftArm.Velocity = _G.Velocity
				LeftLeg.Velocity = _G.Velocity
				if _G.Fling == true then
					Torso.Velocity = Vector3.new(9999,9999,9999)
				else
					Torso.Velocity = Vector3.new(-28.05,1,1)
				end
				HumanoidRootPart.Velocity = _G.Velocity
				for _, Accessories in pairs(Character:GetDescendants()) do
					if Accessories:IsA("Accessory") then
						Accessories.Handle.Velocity = _G.Velocity
					end
				end

			end
		end)

		local CopyCharacter = Character:Clone()
		CopyCharacter.Parent = Character 
		CopyCharacter.Name = "PermAnimated" -- you can always change name.

		for k,l in pairs(Character.PermAnimated:GetDescendants()) do 
			if l:IsA("Part") or l:IsA("Decal") then
				l.Transparency=1
			end
		end

		Character.Torso["Left Shoulder"]:Destroy()
		Character.Torso["Right Shoulder"]:Destroy()
		Character.Torso["Left Hip"]:Destroy()
		Character.Torso["Right Hip"]:Destroy()
		HumanoidRootPart.RootJoint:Destroy()
		--  Using Mizt's align
		local CountSCIFIMOVIELOL = 1
		function AlignCharacter(Part0,Part1,Position,Angle)
			local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
			AlignPos.ApplyAtCenterOfMass = true;
			AlignPos.MaxForce = 5772000--67752;
			AlignPos.MaxVelocity = math.huge/9e110;
			AlignPos.ReactionForceEnabled = false;
			AlignPos.Responsiveness = 200;
			AlignPos.RigidityEnabled = false;
			local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
			AlignOri.MaxAngularVelocity = math.huge/9e110;
			AlignOri.MaxTorque = 5772000
			AlignOri.PrimaryAxisOnly = false;
			AlignOri.ReactionTorqueEnabled = false;
			AlignOri.Responsiveness = 200;
			AlignOri.RigidityEnabled = false;
			local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOL
			local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOL
			local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOL
			local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOL
			AttachmentC.Orientation = Angle
			AttachmentA.Position = Position
			AlignPos.Attachment1 = AttachmentA;
			AlignPos.Attachment0 = AttachmentB;
			AlignOri.Attachment1 = AttachmentC;
			AlignOri.Attachment0 = AttachmentD;
			CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
		end

		AlignCharacter(Torso,CopyCharacter["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		AlignCharacter(HumanoidRootPart,CopyCharacter["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		AlignCharacter(LeftArm,CopyCharacter["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		AlignCharacter(RightArm,CopyCharacter["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		AlignCharacter(LeftLeg,CopyCharacter["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		AlignCharacter(RightLeg,CopyCharacter["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
		CopyCharacter:FindFirstChild("HumanoidRootPart").Anchored = false
		spawn(function() 
			while true do wait()
				if Character:FindFirstChild("Humanoid").Health == 0 then 
					Character:BreakJoints()
					CopyCharacter:BreakJoints()
				end
			end 
		end)


		function nocol(t)
			for k,l in pairs(Character:GetDescendants()) do 
				if l:IsA("BasePart")then 
					HILOL=Instance.new("NoCollisionConstraint",l)
					HILOL.Part0=l
					HILOL.Part1=t 
				end 
			end 
		end

		for k,l in pairs(CopyCharacter:GetDescendants()) do
			if l:IsA("BasePart")then 
				nocol(l)
			end 
		end


		Torso.Anchored = true
		LeftArm.Anchored = true
		RightArm.Anchored = true
		LeftLeg.Anchored = true
		RightLeg.Anchored = true
		Head.Anchored = true

		for k=0,30 do wait()
			CopyCharacter.HumanoidRootPart.RotVelocity = Vector3.new(0,0,0)
			CopyCharacter.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
		end

		Character.Animate.Disabled = true

		game:GetService("UserInputService").JumpRequest:connect(function(t)
			if CopyCharacter.Humanoid.FloorMaterial~=Enum.Material.Air then 
				CopyCharacter.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				game.Players.LocalPlayer.Character.CoolHubTutorial:FindFirstChildOfClass('Humanoid').Sit=false 
			end 
		end)

		game.RunService.RenderStepped:Connect(function()
			CopyCharacter.Humanoid:Move(Character.Humanoid.MoveDirection,false)
			local animtracks = Humanoid:GetPlayingAnimationTracks()
			for n,l in pairs(animtracks) do 
				l:Stop()
			end 
		end)

		Torso.Anchored = false
		LeftArm.Anchored = false
		RightArm.Anchored = false
		LeftLeg.Anchored = false
		RightLeg.Anchored = false
		Head.Anchored = false

		local something = true
		while true do 
			if something == true then 
				for n,l in pairs(Character:children()) do 
					pcall(function()
						if l.className=="Part" then 
							l.CanCollide=false 
						elseif 
							l.ClassName=="Model" then 
							l.Head.CanCollide=false 
						end
					end)
				end
			end
			game:service("RunService").Stepped:wait()
		end
	end
)
